
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>engine: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/gomockserver/mockserver/internal/engine/match_engine.go (58.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package engine

import (
        "context"
        "encoding/json"
        "fmt"
        "strings"

        "github.com/gomockserver/mockserver/internal/adapter"
        "github.com/gomockserver/mockserver/internal/models"
        "github.com/gomockserver/mockserver/internal/repository"
        "github.com/gomockserver/mockserver/pkg/logger"
        "go.uber.org/zap"
)

// MatchEngine 规则匹配引擎
type MatchEngine struct {
        ruleRepo repository.RuleRepository
}

// NewMatchEngine 创建匹配引擎
func NewMatchEngine(ruleRepo repository.RuleRepository) *MatchEngine <span class="cov0" title="0">{
        return &amp;MatchEngine{
                ruleRepo: ruleRepo,
        }
}</span>

// Match 匹配规则
func (e *MatchEngine) Match(ctx context.Context, request *adapter.Request, projectID, environmentID string) (*models.Rule, error) <span class="cov0" title="0">{
        // 加载环境下所有启用的规则
        rules, err := e.ruleRepo.FindEnabledByEnvironment(ctx, projectID, environmentID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to load rules", zap.Error(err))
                return nil, err
        }</span>

        // 按优先级已排序，逐条匹配
        <span class="cov0" title="0">for _, rule := range rules </span><span class="cov0" title="0">{
                // 检查协议类型
                if rule.Protocol != request.Protocol </span><span class="cov0" title="0">{
                        continue</span>
                }

                // 根据匹配类型执行匹配
                <span class="cov0" title="0">matched, err := e.matchRule(request, rule)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Warn("rule match error",
                                zap.String("rule_id", rule.ID),
                                zap.Error(err))
                        continue</span>
                }

                <span class="cov0" title="0">if matched </span><span class="cov0" title="0">{
                        logger.Info("rule matched",
                                zap.String("rule_id", rule.ID),
                                zap.String("rule_name", rule.Name))
                        return rule, nil
                }</span>
        }

        // 没有匹配的规则
        <span class="cov0" title="0">return nil, nil</span>
}

// matchRule 匹配单条规则
func (e *MatchEngine) matchRule(request *adapter.Request, rule *models.Rule) (bool, error) <span class="cov0" title="0">{
        switch rule.MatchType </span>{
        case models.MatchTypeSimple:<span class="cov0" title="0">
                return e.simpleMatch(request, rule)</span>
        case models.MatchTypeRegex:<span class="cov0" title="0">
                return e.regexMatch(request, rule)</span>
        case models.MatchTypeScript:<span class="cov0" title="0">
                return e.scriptMatch(request, rule)</span>
        default:<span class="cov0" title="0">
                return false, fmt.Errorf("unsupported match type: %s", rule.MatchType)</span>
        }
}

// simpleMatch 简单匹配
func (e *MatchEngine) simpleMatch(request *adapter.Request, rule *models.Rule) (bool, error) <span class="cov8" title="1">{
        if rule.Protocol != models.ProtocolHTTP </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        // 解析 HTTP 匹配条件
        <span class="cov8" title="1">conditionBytes, err := json.Marshal(rule.MatchCondition)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov8" title="1">var condition models.HTTPMatchCondition
        if err := json.Unmarshal(conditionBytes, &amp;condition); err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        // 获取请求方法
        <span class="cov8" title="1">method, _ := request.Metadata["method"].(string)

        // 匹配 Method
        if condition.Method != nil </span><span class="cov8" title="1">{
                if !matchMethod(method, condition.Method) </span><span class="cov8" title="1">{
                        return false, nil
                }</span>
        }

        // 匹配 Path
        <span class="cov8" title="1">if condition.Path != "" </span><span class="cov8" title="1">{
                if !matchPath(request.Path, condition.Path) </span><span class="cov0" title="0">{
                        return false, nil
                }</span>
        }

        // 匹配 Query 参数
        <span class="cov8" title="1">if len(condition.Query) &gt; 0 </span><span class="cov8" title="1">{
                query, _ := request.Metadata["query"].(map[string]string)
                if !matchQuery(query, condition.Query) </span><span class="cov0" title="0">{
                        return false, nil
                }</span>
        }

        // 匹配 Headers
        <span class="cov8" title="1">if len(condition.Headers) &gt; 0 </span><span class="cov8" title="1">{
                if !matchHeaders(request.Headers, condition.Headers) </span><span class="cov0" title="0">{
                        return false, nil
                }</span>
        }

        // 匹配 IP 白名单
        <span class="cov8" title="1">if len(condition.IPWhitelist) &gt; 0 </span><span class="cov0" title="0">{
                if !matchIPWhitelist(request.SourceIP, condition.IPWhitelist) </span><span class="cov0" title="0">{
                        return false, nil
                }</span>
        }

        <span class="cov8" title="1">return true, nil</span>
}

// regexMatch 正则表达式匹配（阶段一暂不实现）
func (e *MatchEngine) regexMatch(request *adapter.Request, rule *models.Rule) (bool, error) <span class="cov0" title="0">{
        // TODO: 阶段三实现
        return false, fmt.Errorf("regex match not implemented yet")
}</span>

// scriptMatch 脚本匹配（阶段一暂不实现）
func (e *MatchEngine) scriptMatch(request *adapter.Request, rule *models.Rule) (bool, error) <span class="cov0" title="0">{
        // TODO: 阶段三实现
        return false, fmt.Errorf("script match not implemented yet")
}</span>

// matchMethod 匹配请求方法
func matchMethod(requestMethod string, conditionMethod interface{}) bool <span class="cov8" title="1">{
        switch v := conditionMethod.(type) </span>{
        case string:<span class="cov8" title="1">
                return strings.EqualFold(requestMethod, v)</span>
        case []interface{}:<span class="cov8" title="1">
                for _, m := range v </span><span class="cov8" title="1">{
                        if method, ok := m.(string); ok </span><span class="cov8" title="1">{
                                if strings.EqualFold(requestMethod, method) </span><span class="cov8" title="1">{
                                        return true
                                }</span>
                        }
                }
                <span class="cov8" title="1">return false</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}

// matchPath 匹配路径（支持简单通配符）
func matchPath(requestPath, conditionPath string) bool <span class="cov8" title="1">{
        // 精确匹配
        if requestPath == conditionPath </span><span class="cov8" title="1">{
                return true
        }</span>

        // 支持简单的路径参数匹配，如 /api/users/:id
        <span class="cov8" title="1">conditionParts := strings.Split(conditionPath, "/")
        requestParts := strings.Split(requestPath, "/")

        if len(conditionParts) != len(requestParts) </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">for i, part := range conditionParts </span><span class="cov8" title="1">{
                if strings.HasPrefix(part, ":") </span><span class="cov8" title="1">{
                        // 路径参数，匹配任意值
                        continue</span>
                }
                <span class="cov8" title="1">if part != requestParts[i] </span><span class="cov8" title="1">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return true</span>
}

// matchQuery 匹配查询参数
func matchQuery(requestQuery, conditionQuery map[string]string) bool <span class="cov8" title="1">{
        for key, value := range conditionQuery </span><span class="cov8" title="1">{
                if requestQuery[key] != value </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

// matchHeaders 匹配请求头
func matchHeaders(requestHeaders, conditionHeaders map[string]string) bool <span class="cov8" title="1">{
        for key, value := range conditionHeaders </span><span class="cov8" title="1">{
                // Header 名称不区分大小写
                found := false
                for reqKey, reqValue := range requestHeaders </span><span class="cov8" title="1">{
                        if strings.EqualFold(reqKey, key) </span><span class="cov8" title="1">{
                                if reqValue != value </span><span class="cov8" title="1">{
                                        return false
                                }</span>
                                <span class="cov8" title="1">found = true
                                break</span>
                        }
                }
                <span class="cov8" title="1">if !found </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

// matchIPWhitelist 匹配 IP 白名单（简单实现）
func matchIPWhitelist(requestIP string, whitelist []string) bool <span class="cov0" title="0">{
        for _, ip := range whitelist </span><span class="cov0" title="0">{
                if requestIP == ip </span><span class="cov0" title="0">{
                        return true
                }</span>
                // TODO: 支持 CIDR 格式的 IP 段匹配
        }
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
