
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>adapter: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/gomockserver/mockserver/internal/adapter/http_adapter.go (96.3%)</option>
				
				<option value="file1">github.com/gomockserver/mockserver/internal/api/project_handler.go (100.0%)</option>
				
				<option value="file2">github.com/gomockserver/mockserver/internal/api/rule_handler.go (81.3%)</option>
				
				<option value="file3">github.com/gomockserver/mockserver/internal/config/config.go (94.4%)</option>
				
				<option value="file4">github.com/gomockserver/mockserver/internal/engine/match_engine.go (89.8%)</option>
				
				<option value="file5">github.com/gomockserver/mockserver/internal/executor/mock_executor.go (86.0%)</option>
				
				<option value="file6">github.com/gomockserver/mockserver/internal/repository/database.go (0.0%)</option>
				
				<option value="file7">github.com/gomockserver/mockserver/internal/repository/project_repository.go (0.0%)</option>
				
				<option value="file8">github.com/gomockserver/mockserver/internal/repository/rule_repository.go (0.0%)</option>
				
				<option value="file9">github.com/gomockserver/mockserver/internal/service/admin_service.go (26.1%)</option>
				
				<option value="file10">github.com/gomockserver/mockserver/internal/service/mock_service.go (72.7%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package adapter

import (
        "io"
        "strings"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/gomockserver/mockserver/internal/models"
        "github.com/google/uuid"
)

// HTTPAdapter HTTP 协议适配器
type HTTPAdapter struct{}

// NewHTTPAdapter 创建 HTTP 适配器
func NewHTTPAdapter() *HTTPAdapter <span class="cov8" title="1">{
        return &amp;HTTPAdapter{}
}</span>

// Parse 解析 HTTP 请求为统一模型
func (a *HTTPAdapter) Parse(rawRequest interface{}) (*Request, error) <span class="cov8" title="1">{
        c, ok := rawRequest.(*gin.Context)
        if !ok </span><span class="cov8" title="1">{
                return nil, nil
        }</span>

        // 生成请求ID
        <span class="cov8" title="1">requestID := uuid.New().String()

        // 读取请求体
        body, err := io.ReadAll(c.Request.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 提取Headers
        <span class="cov8" title="1">headers := make(map[string]string)
        for key, values := range c.Request.Header </span><span class="cov8" title="1">{
                if len(values) &gt; 0 </span><span class="cov8" title="1">{
                        headers[key] = values[0]
                }</span>
        }

        // 提取 Query 参数
        <span class="cov8" title="1">query := make(map[string]string)
        for key, values := range c.Request.URL.Query() </span><span class="cov8" title="1">{
                if len(values) &gt; 0 </span><span class="cov8" title="1">{
                        query[key] = values[0]
                }</span>
        }

        // 获取客户端IP
        <span class="cov8" title="1">clientIP := c.ClientIP()

        // 创建统一请求模型
        request := &amp;Request{
                ID:         requestID,
                Protocol:   models.ProtocolHTTP,
                Path:       c.Request.URL.Path,
                Headers:    headers,
                Body:       body,
                SourceIP:   clientIP,
                ReceivedAt: time.Now(),
                Metadata: map[string]interface{}{
                        "method":       c.Request.Method,
                        "query":        query,
                        "raw_query":    c.Request.URL.RawQuery,
                        "host":         c.Request.Host,
                        "user_agent":   c.Request.UserAgent(),
                        "content_type": c.ContentType(),
                },
        }

        return request, nil</span>
}

// Build 构建 HTTP 响应
func (a *HTTPAdapter) Build(response *Response) (interface{}, error) <span class="cov8" title="1">{
        // 返回响应配置，由调用方设置到 gin.Context
        return response, nil
}</span>

// WriteResponse 将响应写入 gin.Context
func (a *HTTPAdapter) WriteResponse(c *gin.Context, response *Response) <span class="cov8" title="1">{
        // 设置响应头
        for key, value := range response.Headers </span><span class="cov8" title="1">{
                c.Header(key, value)
        }</span>

        // 设置状态码和响应体
        <span class="cov8" title="1">c.Data(response.StatusCode, getContentType(response.Headers), response.Body)</span>
}

// getContentType 从响应头中获取 Content-Type
func getContentType(headers map[string]string) string <span class="cov8" title="1">{
        for key, value := range headers </span><span class="cov8" title="1">{
                if strings.ToLower(key) == "content-type" </span><span class="cov8" title="1">{
                        return value
                }</span>
        }
        <span class="cov8" title="1">return "application/json"</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package api

import (
        "net/http"

        "github.com/gin-gonic/gin"
        "github.com/gomockserver/mockserver/internal/models"
        "github.com/gomockserver/mockserver/internal/repository"
        "github.com/gomockserver/mockserver/pkg/logger"
        "go.uber.org/zap"
)

// ProjectHandler 项目处理器
type ProjectHandler struct {
        projectRepo     repository.ProjectRepository
        environmentRepo repository.EnvironmentRepository
}

// NewProjectHandler 创建项目处理器
func NewProjectHandler(projectRepo repository.ProjectRepository, environmentRepo repository.EnvironmentRepository) *ProjectHandler <span class="cov8" title="1">{
        return &amp;ProjectHandler{
                projectRepo:     projectRepo,
                environmentRepo: environmentRepo,
        }
}</span>

// CreateProject 创建项目
func (h *ProjectHandler) CreateProject(c *gin.Context) <span class="cov8" title="1">{
        var project models.Project
        if err := c.ShouldBindJSON(&amp;project); err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">if err := h.projectRepo.Create(c.Request.Context(), &amp;project); err != nil </span><span class="cov8" title="1">{
                logger.Error("failed to create project", zap.Error(err))
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create project"})
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusCreated, project)</span>
}

// GetProject 获取项目详情
func (h *ProjectHandler) GetProject(c *gin.Context) <span class="cov8" title="1">{
        id := c.Param("id")

        project, err := h.projectRepo.FindByID(c.Request.Context(), id)
        if err != nil </span><span class="cov8" title="1">{
                logger.Error("failed to get project", zap.Error(err))
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get project"})
                return
        }</span>

        <span class="cov8" title="1">if project == nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusNotFound, gin.H{"error": "Project not found"})
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, project)</span>
}

// UpdateProject 更新项目
func (h *ProjectHandler) UpdateProject(c *gin.Context) <span class="cov8" title="1">{
        id := c.Param("id")

        var project models.Project
        if err := c.ShouldBindJSON(&amp;project); err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">project.ID = id

        if err := h.projectRepo.Update(c.Request.Context(), &amp;project); err != nil </span><span class="cov8" title="1">{
                logger.Error("failed to update project", zap.Error(err))
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update project"})
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, project)</span>
}

// DeleteProject 删除项目
func (h *ProjectHandler) DeleteProject(c *gin.Context) <span class="cov8" title="1">{
        id := c.Param("id")

        if err := h.projectRepo.Delete(c.Request.Context(), id); err != nil </span><span class="cov8" title="1">{
                logger.Error("failed to delete project", zap.Error(err))
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to delete project"})
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{"message": "Project deleted successfully"})</span>
}

// CreateEnvironment 创建环境
func (h *ProjectHandler) CreateEnvironment(c *gin.Context) <span class="cov8" title="1">{
        var environment models.Environment
        if err := c.ShouldBindJSON(&amp;environment); err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">if err := h.environmentRepo.Create(c.Request.Context(), &amp;environment); err != nil </span><span class="cov8" title="1">{
                logger.Error("failed to create environment", zap.Error(err))
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create environment"})
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusCreated, environment)</span>
}

// GetEnvironment 获取环境详情
func (h *ProjectHandler) GetEnvironment(c *gin.Context) <span class="cov8" title="1">{
        id := c.Param("id")

        environment, err := h.environmentRepo.FindByID(c.Request.Context(), id)
        if err != nil </span><span class="cov8" title="1">{
                logger.Error("failed to get environment", zap.Error(err))
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get environment"})
                return
        }</span>

        <span class="cov8" title="1">if environment == nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusNotFound, gin.H{"error": "Environment not found"})
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, environment)</span>
}

// ListEnvironments 列出项目下的环境
func (h *ProjectHandler) ListEnvironments(c *gin.Context) <span class="cov8" title="1">{
        projectID := c.Query("project_id")
        if projectID == "" </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "project_id is required"})
                return
        }</span>

        <span class="cov8" title="1">environments, err := h.environmentRepo.FindByProject(c.Request.Context(), projectID)
        if err != nil </span><span class="cov8" title="1">{
                logger.Error("failed to list environments", zap.Error(err))
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to list environments"})
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{
                "data": environments,
        })</span>
}

// UpdateEnvironment 更新环境
func (h *ProjectHandler) UpdateEnvironment(c *gin.Context) <span class="cov8" title="1">{
        id := c.Param("id")

        var environment models.Environment
        if err := c.ShouldBindJSON(&amp;environment); err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">environment.ID = id

        if err := h.environmentRepo.Update(c.Request.Context(), &amp;environment); err != nil </span><span class="cov8" title="1">{
                logger.Error("failed to update environment", zap.Error(err))
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update environment"})
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, environment)</span>
}

// DeleteEnvironment 删除环境
func (h *ProjectHandler) DeleteEnvironment(c *gin.Context) <span class="cov8" title="1">{
        id := c.Param("id")

        if err := h.environmentRepo.Delete(c.Request.Context(), id); err != nil </span><span class="cov8" title="1">{
                logger.Error("failed to delete environment", zap.Error(err))
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to delete environment"})
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{"message": "Environment deleted successfully"})</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package api

import (
        "net/http"
        "strconv"

        "github.com/gin-gonic/gin"
        "github.com/gomockserver/mockserver/internal/models"
        "github.com/gomockserver/mockserver/internal/repository"
        "github.com/gomockserver/mockserver/pkg/logger"
        "go.uber.org/zap"
)

// RuleHandler 规则处理器
type RuleHandler struct {
        ruleRepo repository.RuleRepository
}

// NewRuleHandler 创建规则处理器
func NewRuleHandler(ruleRepo repository.RuleRepository) *RuleHandler <span class="cov8" title="1">{
        return &amp;RuleHandler{
                ruleRepo: ruleRepo,
        }
}</span>

// CreateRule 创建规则
func (h *RuleHandler) CreateRule(c *gin.Context) <span class="cov8" title="1">{
        var rule models.Rule
        if err := c.ShouldBindJSON(&amp;rule); err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        // 验证必填字段
        <span class="cov8" title="1">if rule.Name == "" || rule.ProjectID == "" || rule.EnvironmentID == "" </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "name, project_id and environment_id are required"})
                return
        }</span>

        // 创建规则
        <span class="cov8" title="1">if err := h.ruleRepo.Create(c.Request.Context(), &amp;rule); err != nil </span><span class="cov8" title="1">{
                logger.Error("failed to create rule", zap.Error(err))
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create rule"})
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusCreated, rule)</span>
}

// GetRule 获取规则详情
func (h *RuleHandler) GetRule(c *gin.Context) <span class="cov8" title="1">{
        id := c.Param("id")
        if id == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "id is required"})
                return
        }</span>

        <span class="cov8" title="1">rule, err := h.ruleRepo.FindByID(c.Request.Context(), id)
        if err != nil </span><span class="cov8" title="1">{
                logger.Error("failed to get rule", zap.Error(err))
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get rule"})
                return
        }</span>

        <span class="cov8" title="1">if rule == nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusNotFound, gin.H{"error": "Rule not found"})
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, rule)</span>
}

// UpdateRule 更新规则
func (h *RuleHandler) UpdateRule(c *gin.Context) <span class="cov8" title="1">{
        id := c.Param("id")
        if id == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "id is required"})
                return
        }</span>

        <span class="cov8" title="1">var rule models.Rule
        if err := c.ShouldBindJSON(&amp;rule); err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">rule.ID = id

        if err := h.ruleRepo.Update(c.Request.Context(), &amp;rule); err != nil </span><span class="cov8" title="1">{
                logger.Error("failed to update rule", zap.Error(err))
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update rule"})
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, rule)</span>
}

// DeleteRule 删除规则
func (h *RuleHandler) DeleteRule(c *gin.Context) <span class="cov8" title="1">{
        id := c.Param("id")
        if id == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "id is required"})
                return
        }</span>

        <span class="cov8" title="1">if err := h.ruleRepo.Delete(c.Request.Context(), id); err != nil </span><span class="cov8" title="1">{
                logger.Error("failed to delete rule", zap.Error(err))
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to delete rule"})
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{"message": "Rule deleted successfully"})</span>
}

// ListRules 列出规则
func (h *RuleHandler) ListRules(c *gin.Context) <span class="cov8" title="1">{
        // 分页参数
        page, _ := strconv.ParseInt(c.DefaultQuery("page", "1"), 10, 64)
        pageSize, _ := strconv.ParseInt(c.DefaultQuery("page_size", "20"), 10, 64)

        if page &lt; 1 </span><span class="cov0" title="0">{
                page = 1
        }</span>
        <span class="cov8" title="1">if pageSize &lt; 1 || pageSize &gt; 100 </span><span class="cov0" title="0">{
                pageSize = 20
        }</span>

        <span class="cov8" title="1">skip := (page - 1) * pageSize

        // 过滤条件
        filter := make(map[string]interface{})
        if projectID := c.Query("project_id"); projectID != "" </span><span class="cov8" title="1">{
                filter["project_id"] = projectID
        }</span>
        <span class="cov8" title="1">if environmentID := c.Query("environment_id"); environmentID != "" </span><span class="cov0" title="0">{
                filter["environment_id"] = environmentID
        }</span>
        <span class="cov8" title="1">if protocol := c.Query("protocol"); protocol != "" </span><span class="cov0" title="0">{
                filter["protocol"] = protocol
        }</span>
        <span class="cov8" title="1">if enabled := c.Query("enabled"); enabled != "" </span><span class="cov8" title="1">{
                filter["enabled"] = enabled == "true"
        }</span>

        <span class="cov8" title="1">rules, total, err := h.ruleRepo.List(c.Request.Context(), filter, skip, pageSize)
        if err != nil </span><span class="cov8" title="1">{
                logger.Error("failed to list rules", zap.Error(err))
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to list rules"})
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{
                "data":      rules,
                "total":     total,
                "page":      page,
                "page_size": pageSize,
        })</span>
}

// EnableRule 启用规则
func (h *RuleHandler) EnableRule(c *gin.Context) <span class="cov8" title="1">{
        id := c.Param("id")
        if id == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "id is required"})
                return
        }</span>

        <span class="cov8" title="1">rule, err := h.ruleRepo.FindByID(c.Request.Context(), id)
        if err != nil </span><span class="cov8" title="1">{
                logger.Error("failed to get rule", zap.Error(err))
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get rule"})
                return
        }</span>

        <span class="cov8" title="1">if rule == nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusNotFound, gin.H{"error": "Rule not found"})
                return
        }</span>

        <span class="cov8" title="1">rule.Enabled = true
        if err := h.ruleRepo.Update(c.Request.Context(), rule); err != nil </span><span class="cov8" title="1">{
                logger.Error("failed to enable rule", zap.Error(err))
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to enable rule"})
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{"message": "Rule enabled successfully"})</span>
}

// DisableRule 禁用规则
func (h *RuleHandler) DisableRule(c *gin.Context) <span class="cov8" title="1">{
        id := c.Param("id")
        if id == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "id is required"})
                return
        }</span>

        <span class="cov8" title="1">rule, err := h.ruleRepo.FindByID(c.Request.Context(), id)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to get rule", zap.Error(err))
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get rule"})
                return
        }</span>

        <span class="cov8" title="1">if rule == nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusNotFound, gin.H{"error": "Rule not found"})
                return
        }</span>

        <span class="cov8" title="1">rule.Enabled = false
        if err := h.ruleRepo.Update(c.Request.Context(), rule); err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to disable rule", zap.Error(err))
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to disable rule"})
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{"message": "Rule disabled successfully"})</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package config

import (
        "fmt"
        "time"

        "github.com/spf13/viper"
)

// Config 应用配置结构
type Config struct {
        Server      ServerConfig      `mapstructure:"server"`
        Database    DatabaseConfig    `mapstructure:"database"`
        Redis       RedisConfig       `mapstructure:"redis"`
        Security    SecurityConfig    `mapstructure:"security"`
        Logging     LoggingConfig     `mapstructure:"logging"`
        Performance PerformanceConfig `mapstructure:"performance"`
        Features    FeaturesConfig    `mapstructure:"features"`
}

// ServerConfig 服务器配置
type ServerConfig struct {
        Admin AdminServerConfig `mapstructure:"admin"`
        Mock  MockServerConfig  `mapstructure:"mock"`
}

// AdminServerConfig 管理 API 服务配置
type AdminServerConfig struct {
        Host string `mapstructure:"host"`
        Port int    `mapstructure:"port"`
}

// MockServerConfig Mock 服务配置
type MockServerConfig struct {
        Host string `mapstructure:"host"`
        Port int    `mapstructure:"port"`
}

// DatabaseConfig 数据库配置
type DatabaseConfig struct {
        MongoDB MongoDBConfig `mapstructure:"mongodb"`
}

// MongoDBConfig MongoDB 配置
type MongoDBConfig struct {
        URI      string         `mapstructure:"uri"`
        Database string         `mapstructure:"database"`
        Timeout  time.Duration  `mapstructure:"timeout"`
        Pool     ConnectionPool `mapstructure:"pool"`
}

// ConnectionPool 连接池配置
type ConnectionPool struct {
        Min int `mapstructure:"min"`
        Max int `mapstructure:"max"`
}

// RedisConfig Redis 配置
type RedisConfig struct {
        Enabled  bool           `mapstructure:"enabled"`
        Host     string         `mapstructure:"host"`
        Port     int            `mapstructure:"port"`
        Password string         `mapstructure:"password"`
        DB       int            `mapstructure:"db"`
        Pool     ConnectionPool `mapstructure:"pool"`
}

// SecurityConfig 安全配置
type SecurityConfig struct {
        JWT         JWTConfig         `mapstructure:"jwt"`
        APIKey      APIKeyConfig      `mapstructure:"api_key"`
        IPWhitelist IPWhitelistConfig `mapstructure:"ip_whitelist"`
}

// JWTConfig JWT 配置
type JWTConfig struct {
        Secret     string `mapstructure:"secret"`
        Expiration int    `mapstructure:"expiration"`
}

// APIKeyConfig API Key 配置
type APIKeyConfig struct {
        Enabled bool `mapstructure:"enabled"`
}

// IPWhitelistConfig IP 白名单配置
type IPWhitelistConfig struct {
        Enabled bool     `mapstructure:"enabled"`
        IPs     []string `mapstructure:"ips"`
}

// LoggingConfig 日志配置
type LoggingConfig struct {
        Level  string        `mapstructure:"level"`
        Format string        `mapstructure:"format"`
        Output string        `mapstructure:"output"`
        File   LogFileConfig `mapstructure:"file"`
}

// LogFileConfig 日志文件配置
type LogFileConfig struct {
        Path       string `mapstructure:"path"`
        MaxSize    int    `mapstructure:"max_size"`
        MaxBackups int    `mapstructure:"max_backups"`
        MaxAge     int    `mapstructure:"max_age"`
}

// PerformanceConfig 性能配置
type PerformanceConfig struct {
        LogRetentionDays int             `mapstructure:"log_retention_days"`
        Cache            CacheConfig     `mapstructure:"cache"`
        RateLimit        RateLimitConfig `mapstructure:"rate_limit"`
}

// CacheConfig 缓存配置
type CacheConfig struct {
        RuleTTL   int `mapstructure:"rule_ttl"`
        ConfigTTL int `mapstructure:"config_ttl"`
}

// RateLimitConfig 限流配置
type RateLimitConfig struct {
        Enabled     bool `mapstructure:"enabled"`
        IPLimit     int  `mapstructure:"ip_limit"`
        GlobalLimit int  `mapstructure:"global_limit"`
}

// FeaturesConfig 功能开关
type FeaturesConfig struct {
        VersionControl bool `mapstructure:"version_control"`
        AuditLog       bool `mapstructure:"audit_log"`
        Metrics        bool `mapstructure:"metrics"`
}

var globalConfig *Config

// Load 加载配置文件
func Load(configPath string) (*Config, error) <span class="cov8" title="1">{
        v := viper.New()

        // 设置配置文件路径
        if configPath != "" </span><span class="cov8" title="1">{
                v.SetConfigFile(configPath)
        }</span> else<span class="cov8" title="1"> {
                v.SetConfigName("config")
                v.SetConfigType("yaml")
                v.AddConfigPath(".")
                v.AddConfigPath("./config")
        }</span>

        // 读取环境变量
        <span class="cov8" title="1">v.AutomaticEnv()

        // 读取配置文件
        if err := v.ReadInConfig(); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to read config file: %w", err)
        }</span>

        // 解析配置
        <span class="cov8" title="1">var cfg Config
        if err := v.Unmarshal(&amp;cfg); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal config: %w", err)
        }</span>

        <span class="cov8" title="1">globalConfig = &amp;cfg
        return &amp;cfg, nil</span>
}

// Get 获取全局配置
func Get() *Config <span class="cov8" title="1">{
        return globalConfig
}</span>

// GetAdminAddress 获取管理服务地址
func (c *Config) GetAdminAddress() string <span class="cov8" title="1">{
        return fmt.Sprintf("%s:%d", c.Server.Admin.Host, c.Server.Admin.Port)
}</span>

// GetMockAddress 获取 Mock 服务地址
func (c *Config) GetMockAddress() string <span class="cov8" title="1">{
        return fmt.Sprintf("%s:%d", c.Server.Mock.Host, c.Server.Mock.Port)
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package engine

import (
        "context"
        "encoding/json"
        "fmt"
        "strings"

        "github.com/gomockserver/mockserver/internal/adapter"
        "github.com/gomockserver/mockserver/internal/models"
        "github.com/gomockserver/mockserver/internal/repository"
        "github.com/gomockserver/mockserver/pkg/logger"
        "go.uber.org/zap"
)

// MatchEngine 规则匹配引擎
type MatchEngine struct {
        ruleRepo repository.RuleRepository
}

// NewMatchEngine 创建匹配引擎
func NewMatchEngine(ruleRepo repository.RuleRepository) *MatchEngine <span class="cov8" title="1">{
        return &amp;MatchEngine{
                ruleRepo: ruleRepo,
        }
}</span>

// Match 匹配规则
func (e *MatchEngine) Match(ctx context.Context, request *adapter.Request, projectID, environmentID string) (*models.Rule, error) <span class="cov8" title="1">{
        // 加载环境下所有启用的规则
        rules, err := e.ruleRepo.FindEnabledByEnvironment(ctx, projectID, environmentID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to load rules", zap.Error(err))
                return nil, err
        }</span>

        // 按优先级已排序，逐条匹配
        <span class="cov8" title="1">for _, rule := range rules </span><span class="cov8" title="1">{
                // 检查协议类型
                if rule.Protocol != request.Protocol </span><span class="cov8" title="1">{
                        continue</span>
                }

                // 根据匹配类型执行匹配
                <span class="cov8" title="1">matched, err := e.matchRule(request, rule)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Warn("rule match error",
                                zap.String("rule_id", rule.ID),
                                zap.Error(err))
                        continue</span>
                }

                <span class="cov8" title="1">if matched </span><span class="cov8" title="1">{
                        logger.Info("rule matched",
                                zap.String("rule_id", rule.ID),
                                zap.String("rule_name", rule.Name))
                        return rule, nil
                }</span>
        }

        // 没有匹配的规则
        <span class="cov8" title="1">return nil, nil</span>
}

// matchRule 匹配单条规则
func (e *MatchEngine) matchRule(request *adapter.Request, rule *models.Rule) (bool, error) <span class="cov8" title="1">{
        switch rule.MatchType </span>{
        case models.MatchTypeSimple:<span class="cov8" title="1">
                return e.simpleMatch(request, rule)</span>
        case models.MatchTypeRegex:<span class="cov8" title="1">
                return e.regexMatch(request, rule)</span>
        case models.MatchTypeScript:<span class="cov8" title="1">
                return e.scriptMatch(request, rule)</span>
        default:<span class="cov8" title="1">
                return false, fmt.Errorf("unsupported match type: %s", rule.MatchType)</span>
        }
}

// simpleMatch 简单匹配
func (e *MatchEngine) simpleMatch(request *adapter.Request, rule *models.Rule) (bool, error) <span class="cov8" title="1">{
        if rule.Protocol != models.ProtocolHTTP </span><span class="cov8" title="1">{
                return false, nil
        }</span>

        // 解析 HTTP 匹配条件
        <span class="cov8" title="1">conditionBytes, err := json.Marshal(rule.MatchCondition)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov8" title="1">var condition models.HTTPMatchCondition
        if err := json.Unmarshal(conditionBytes, &amp;condition); err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        // 获取请求方法
        <span class="cov8" title="1">method, _ := request.Metadata["method"].(string)

        // 匹配 Method
        if condition.Method != nil </span><span class="cov8" title="1">{
                if !matchMethod(method, condition.Method) </span><span class="cov8" title="1">{
                        return false, nil
                }</span>
        }

        // 匹配 Path
        <span class="cov8" title="1">if condition.Path != "" </span><span class="cov8" title="1">{
                if !matchPath(request.Path, condition.Path) </span><span class="cov0" title="0">{
                        return false, nil
                }</span>
        }

        // 匹配 Query 参数
        <span class="cov8" title="1">if len(condition.Query) &gt; 0 </span><span class="cov8" title="1">{
                query, _ := request.Metadata["query"].(map[string]string)
                if !matchQuery(query, condition.Query) </span><span class="cov8" title="1">{
                        return false, nil
                }</span>
        }

        // 匹配 Headers
        <span class="cov8" title="1">if len(condition.Headers) &gt; 0 </span><span class="cov8" title="1">{
                if !matchHeaders(request.Headers, condition.Headers) </span><span class="cov8" title="1">{
                        return false, nil
                }</span>
        }

        // 匹配 IP 白名单
        <span class="cov8" title="1">if len(condition.IPWhitelist) &gt; 0 </span><span class="cov8" title="1">{
                if !matchIPWhitelist(request.SourceIP, condition.IPWhitelist) </span><span class="cov8" title="1">{
                        return false, nil
                }</span>
        }

        <span class="cov8" title="1">return true, nil</span>
}

// regexMatch 正则表达式匹配（阶段一暂不实现）
func (e *MatchEngine) regexMatch(request *adapter.Request, rule *models.Rule) (bool, error) <span class="cov8" title="1">{
        // TODO: 阶段三实现
        return false, fmt.Errorf("regex match not implemented yet")
}</span>

// scriptMatch 脚本匹配（阶段一暂不实现）
func (e *MatchEngine) scriptMatch(request *adapter.Request, rule *models.Rule) (bool, error) <span class="cov8" title="1">{
        // TODO: 阶段三实现
        return false, fmt.Errorf("script match not implemented yet")
}</span>

// matchMethod 匹配请求方法
func matchMethod(requestMethod string, conditionMethod interface{}) bool <span class="cov8" title="1">{
        switch v := conditionMethod.(type) </span>{
        case string:<span class="cov8" title="1">
                return strings.EqualFold(requestMethod, v)</span>
        case []interface{}:<span class="cov8" title="1">
                for _, m := range v </span><span class="cov8" title="1">{
                        if method, ok := m.(string); ok </span><span class="cov8" title="1">{
                                if strings.EqualFold(requestMethod, method) </span><span class="cov8" title="1">{
                                        return true
                                }</span>
                        }
                }
                <span class="cov8" title="1">return false</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}

// matchPath 匹配路径（支持简单通配符）
func matchPath(requestPath, conditionPath string) bool <span class="cov8" title="1">{
        // 精确匹配
        if requestPath == conditionPath </span><span class="cov8" title="1">{
                return true
        }</span>

        // 支持简单的路径参数匹配，如 /api/users/:id
        <span class="cov8" title="1">conditionParts := strings.Split(conditionPath, "/")
        requestParts := strings.Split(requestPath, "/")

        if len(conditionParts) != len(requestParts) </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">for i, part := range conditionParts </span><span class="cov8" title="1">{
                if strings.HasPrefix(part, ":") </span><span class="cov8" title="1">{
                        // 路径参数，匹配任意值
                        continue</span>
                }
                <span class="cov8" title="1">if part != requestParts[i] </span><span class="cov8" title="1">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return true</span>
}

// matchQuery 匹配查询参数
func matchQuery(requestQuery, conditionQuery map[string]string) bool <span class="cov8" title="1">{
        for key, value := range conditionQuery </span><span class="cov8" title="1">{
                if requestQuery[key] != value </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

// matchHeaders 匹配请求头
func matchHeaders(requestHeaders, conditionHeaders map[string]string) bool <span class="cov8" title="1">{
        for key, value := range conditionHeaders </span><span class="cov8" title="1">{
                // Header 名称不区分大小写
                found := false
                for reqKey, reqValue := range requestHeaders </span><span class="cov8" title="1">{
                        if strings.EqualFold(reqKey, key) </span><span class="cov8" title="1">{
                                if reqValue != value </span><span class="cov8" title="1">{
                                        return false
                                }</span>
                                <span class="cov8" title="1">found = true
                                break</span>
                        }
                }
                <span class="cov8" title="1">if !found </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

// matchIPWhitelist 匹配 IP 白名单（简单实现）
func matchIPWhitelist(requestIP string, whitelist []string) bool <span class="cov8" title="1">{
        for _, ip := range whitelist </span><span class="cov8" title="1">{
                if requestIP == ip </span><span class="cov8" title="1">{
                        return true
                }</span>
                // TODO: 支持 CIDR 格式的 IP 段匹配
        }
        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package executor

import (
        "encoding/json"
        "fmt"
        "math/rand"
        "time"

        "github.com/gomockserver/mockserver/internal/adapter"
        "github.com/gomockserver/mockserver/internal/models"
        "github.com/gomockserver/mockserver/pkg/logger"
        "go.uber.org/zap"
)

// MockExecutor Mock 执行器
type MockExecutor struct{}

// NewMockExecutor 创建 Mock 执行器
func NewMockExecutor() *MockExecutor <span class="cov8" title="1">{
        return &amp;MockExecutor{}
}</span>

// Execute 执行 Mock 响应生成
func (e *MockExecutor) Execute(request *adapter.Request, rule *models.Rule) (*adapter.Response, error) <span class="cov8" title="1">{
        // 应用延迟
        if rule.Response.Delay != nil </span><span class="cov8" title="1">{
                delay := e.calculateDelay(rule.Response.Delay)
                if delay &gt; 0 </span><span class="cov8" title="1">{
                        time.Sleep(time.Duration(delay) * time.Millisecond)
                }</span>
        }

        // 根据响应类型生成响应
        <span class="cov8" title="1">switch rule.Response.Type </span>{
        case models.ResponseTypeStatic:<span class="cov8" title="1">
                return e.staticResponse(request, rule)</span>
        case models.ResponseTypeDynamic:<span class="cov8" title="1">
                // TODO: 阶段三实现
                return nil, fmt.Errorf("dynamic response not implemented yet")</span>
        case models.ResponseTypeScript:<span class="cov8" title="1">
                // TODO: 阶段三实现
                return nil, fmt.Errorf("script response not implemented yet")</span>
        case models.ResponseTypeProxy:<span class="cov8" title="1">
                // TODO: 阶段三实现
                return nil, fmt.Errorf("proxy response not implemented yet")</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported response type: %s", rule.Response.Type)</span>
        }
}

// staticResponse 生成静态响应
func (e *MockExecutor) staticResponse(request *adapter.Request, rule *models.Rule) (*adapter.Response, error) <span class="cov8" title="1">{
        if rule.Protocol != models.ProtocolHTTP </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("only HTTP protocol is supported in static response")
        }</span>

        // 解析 HTTP 响应配置
        <span class="cov8" title="1">contentBytes, err := json.Marshal(rule.Response.Content)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to marshal response content", zap.Error(err))
                return nil, err
        }</span>

        <span class="cov8" title="1">var httpResp models.HTTPResponse
        if err := json.Unmarshal(contentBytes, &amp;httpResp); err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to unmarshal http response", zap.Error(err))
                return nil, err
        }</span>

        // 构建响应体
        <span class="cov8" title="1">var body []byte
        switch httpResp.ContentType </span>{
        case models.ContentTypeJSON:<span class="cov8" title="1">
                body, err = json.Marshal(httpResp.Body)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        case models.ContentTypeText, models.ContentTypeHTML, models.ContentTypeXML:<span class="cov8" title="1">
                if str, ok := httpResp.Body.(string); ok </span><span class="cov8" title="1">{
                        body = []byte(str)
                }</span> else<span class="cov8" title="1"> {
                        body, err = json.Marshal(httpResp.Body)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                }
        case models.ContentTypeBinary:<span class="cov8" title="1">
                // TODO: 处理二进制数据
                body = []byte{}</span>
        default:<span class="cov8" title="1">
                body, err = json.Marshal(httpResp.Body)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        // 设置默认 Content-Type
        <span class="cov8" title="1">if httpResp.Headers == nil </span><span class="cov8" title="1">{
                httpResp.Headers = make(map[string]string)
        }</span>
        <span class="cov8" title="1">if _, ok := httpResp.Headers["Content-Type"]; !ok </span><span class="cov8" title="1">{
                httpResp.Headers["Content-Type"] = e.getDefaultContentType(httpResp.ContentType)
        }</span>

        // 构建统一响应模型
        <span class="cov8" title="1">response := &amp;adapter.Response{
                StatusCode: httpResp.StatusCode,
                Headers:    httpResp.Headers,
                Body:       body,
                Metadata:   make(map[string]interface{}),
        }

        return response, nil</span>
}

// calculateDelay 计算延迟时间（毫秒）
func (e *MockExecutor) calculateDelay(config *models.DelayConfig) int <span class="cov8" title="1">{
        switch config.Type </span>{
        case "fixed":<span class="cov8" title="1">
                return config.Fixed</span>
        case "random":<span class="cov8" title="1">
                if config.Max &lt;= config.Min </span><span class="cov8" title="1">{
                        return config.Min
                }</span>
                <span class="cov8" title="1">return config.Min + rand.Intn(config.Max-config.Min)</span>
        case "normal":<span class="cov8" title="1">
                // TODO: 实现正态分布延迟
                return config.Mean</span>
        case "step":<span class="cov8" title="1">
                // TODO: 实现阶梯延迟
                return config.Fixed</span>
        default:<span class="cov8" title="1">
                return 0</span>
        }
}

// getDefaultContentType 获取默认 Content-Type
func (e *MockExecutor) getDefaultContentType(contentType models.ContentType) string <span class="cov8" title="1">{
        switch contentType </span>{
        case models.ContentTypeJSON:<span class="cov8" title="1">
                return "application/json"</span>
        case models.ContentTypeXML:<span class="cov8" title="1">
                return "application/xml"</span>
        case models.ContentTypeHTML:<span class="cov8" title="1">
                return "text/html"</span>
        case models.ContentTypeText:<span class="cov8" title="1">
                return "text/plain"</span>
        case models.ContentTypeBinary:<span class="cov8" title="1">
                return "application/octet-stream"</span>
        default:<span class="cov8" title="1">
                return "application/json"</span>
        }
}

// GetDefaultResponse 获取默认 404 响应
func (e *MockExecutor) GetDefaultResponse() *adapter.Response <span class="cov8" title="1">{
        return &amp;adapter.Response{
                StatusCode: 404,
                Headers: map[string]string{
                        "Content-Type": "application/json",
                },
                Body: []byte(`{"error": "No matching rule found"}`),
        }
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package repository

import (
        "context"
        "fmt"
        "time"

        "github.com/gomockserver/mockserver/internal/config"
        "go.mongodb.org/mongo-driver/mongo"
        "go.mongodb.org/mongo-driver/mongo/options"
)

var (
        client   *mongo.Client
        database *mongo.Database
)

// Init 初始化数据库连接
func Init(cfg *config.Config) error <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), cfg.Database.MongoDB.Timeout)
        defer cancel()

        // 创建客户端选项
        clientOptions := options.Client().
                ApplyURI(cfg.Database.MongoDB.URI).
                SetMinPoolSize(uint64(cfg.Database.MongoDB.Pool.Min)).
                SetMaxPoolSize(uint64(cfg.Database.MongoDB.Pool.Max))

        // 连接数据库
        var err error
        client, err = mongo.Connect(ctx, clientOptions)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to connect to MongoDB: %w", err)
        }</span>

        // 验证连接
        <span class="cov0" title="0">if err = client.Ping(ctx, nil); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to ping MongoDB: %w", err)
        }</span>

        // 获取数据库实例
        <span class="cov0" title="0">database = client.Database(cfg.Database.MongoDB.Database)

        // 创建索引
        if err := createIndexes(ctx); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create indexes: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// createIndexes 创建索引
func createIndexes(ctx context.Context) error <span class="cov0" title="0">{
        // Rules 集合索引
        rulesCollection := database.Collection("rules")
        rulesIndexes := []mongo.IndexModel{
                {
                        Keys: map[string]interface{}{
                                "project_id":     1,
                                "environment_id": 1,
                        },
                },
                {
                        Keys: map[string]interface{}{
                                "protocol": 1,
                        },
                },
                {
                        Keys: map[string]interface{}{
                                "enabled": 1,
                        },
                },
                {
                        Keys: map[string]interface{}{
                                "priority": 1,
                        },
                },
                {
                        Keys: map[string]interface{}{
                                "tags": 1,
                        },
                },
                {
                        Keys: map[string]interface{}{
                                "created_at": 1,
                        },
                },
        }
        if _, err := rulesCollection.Indexes().CreateMany(ctx, rulesIndexes); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Projects 集合索引
        <span class="cov0" title="0">projectsCollection := database.Collection("projects")
        projectsIndexes := []mongo.IndexModel{
                {
                        Keys: map[string]interface{}{
                                "workspace_id": 1,
                        },
                },
        }
        if _, err := projectsCollection.Indexes().CreateMany(ctx, projectsIndexes); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Environments 集合索引
        <span class="cov0" title="0">environmentsCollection := database.Collection("environments")
        environmentsIndexes := []mongo.IndexModel{
                {
                        Keys: map[string]interface{}{
                                "project_id": 1,
                        },
                },
        }
        if _, err := environmentsCollection.Indexes().CreateMany(ctx, environmentsIndexes); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Logs 集合索引（带 TTL）
        <span class="cov0" title="0">logsCollection := database.Collection("logs")
        logsIndexes := []mongo.IndexModel{
                {
                        Keys: map[string]interface{}{
                                "request_id": 1,
                        },
                },
                {
                        Keys: map[string]interface{}{
                                "rule_id": 1,
                        },
                },
                {
                        Keys: map[string]interface{}{
                                "protocol": 1,
                        },
                },
                {
                        Keys: map[string]interface{}{
                                "timestamp": 1,
                        },
                        Options: options.Index().SetExpireAfterSeconds(7 * 24 * 60 * 60), // 7天过期
                },
                {
                        Keys: map[string]interface{}{
                                "project_id":     1,
                                "environment_id": 1,
                        },
                },
        }
        if _, err := logsCollection.Indexes().CreateMany(ctx, logsIndexes); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Versions 集合索引
        <span class="cov0" title="0">versionsCollection := database.Collection("versions")
        versionsIndexes := []mongo.IndexModel{
                {
                        Keys: map[string]interface{}{
                                "rule_id": 1,
                        },
                },
                {
                        Keys: map[string]interface{}{
                                "created_at": 1,
                        },
                },
        }
        if _, err := versionsCollection.Indexes().CreateMany(ctx, versionsIndexes); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Users 集合索引
        <span class="cov0" title="0">usersCollection := database.Collection("users")
        usersIndexes := []mongo.IndexModel{
                {
                        Keys: map[string]interface{}{
                                "username": 1,
                        },
                        Options: options.Index().SetUnique(true),
                },
                {
                        Keys: map[string]interface{}{
                                "email": 1,
                        },
                        Options: options.Index().SetUnique(true),
                },
        }
        if _, err := usersCollection.Indexes().CreateMany(ctx, usersIndexes); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetDatabase 获取数据库实例
func GetDatabase() *mongo.Database <span class="cov0" title="0">{
        return database
}</span>

// GetCollection 获取集合
func GetCollection(name string) *mongo.Collection <span class="cov0" title="0">{
        return database.Collection(name)
}</span>

// Close 关闭数据库连接
func Close() error <span class="cov0" title="0">{
        if client != nil </span><span class="cov0" title="0">{
                ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
                defer cancel()
                return client.Disconnect(ctx)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package repository

import (
        "context"
        "time"

        "github.com/gomockserver/mockserver/internal/models"
        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/bson/primitive"
        "go.mongodb.org/mongo-driver/mongo"
        "go.mongodb.org/mongo-driver/mongo/options"
)

// ProjectRepository 项目仓库接口
type ProjectRepository interface {
        Create(ctx context.Context, project *models.Project) error
        Update(ctx context.Context, project *models.Project) error
        Delete(ctx context.Context, id string) error
        FindByID(ctx context.Context, id string) (*models.Project, error)
        FindByWorkspace(ctx context.Context, workspaceID string) ([]*models.Project, error)
        List(ctx context.Context, skip, limit int64) ([]*models.Project, int64, error)
}

type projectRepository struct {
        collection *mongo.Collection
}

// NewProjectRepository 创建项目仓库
func NewProjectRepository() ProjectRepository <span class="cov0" title="0">{
        return &amp;projectRepository{
                collection: GetCollection("projects"),
        }
}</span>

// Create 创建项目
func (r *projectRepository) Create(ctx context.Context, project *models.Project) error <span class="cov0" title="0">{
        project.CreatedAt = time.Now()
        project.UpdatedAt = time.Now()

        result, err := r.collection.InsertOne(ctx, project)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if oid, ok := result.InsertedID.(primitive.ObjectID); ok </span><span class="cov0" title="0">{
                project.ID = oid.Hex()
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Update 更新项目
func (r *projectRepository) Update(ctx context.Context, project *models.Project) error <span class="cov0" title="0">{
        project.UpdatedAt = time.Now()

        objectID, err := primitive.ObjectIDFromHex(project.ID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">filter := bson.M{"_id": objectID}
        // 排除 _id 字段，避免更新不可变字段
        update := bson.M{"$set": bson.M{
                "name":         project.Name,
                "workspace_id":  project.WorkspaceID,
                "description":  project.Description,
                "updated_at":   project.UpdatedAt,
        }}

        _, err = r.collection.UpdateOne(ctx, filter, update)
        return err</span>
}

// Delete 删除项目
func (r *projectRepository) Delete(ctx context.Context, id string) error <span class="cov0" title="0">{
        objectID, err := primitive.ObjectIDFromHex(id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">filter := bson.M{"_id": objectID}
        _, err = r.collection.DeleteOne(ctx, filter)
        return err</span>
}

// FindByID 根据ID查找项目
func (r *projectRepository) FindByID(ctx context.Context, id string) (*models.Project, error) <span class="cov0" title="0">{
        objectID, err := primitive.ObjectIDFromHex(id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">filter := bson.M{"_id": objectID}

        var project models.Project
        err = r.collection.FindOne(ctx, filter).Decode(&amp;project)
        if err != nil </span><span class="cov0" title="0">{
                if err == mongo.ErrNoDocuments </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov0" title="0">return &amp;project, nil</span>
}

// FindByWorkspace 查找工作空间下的所有项目
func (r *projectRepository) FindByWorkspace(ctx context.Context, workspaceID string) ([]*models.Project, error) <span class="cov0" title="0">{
        filter := bson.M{"workspace_id": workspaceID}

        cursor, err := r.collection.Find(ctx, filter)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer cursor.Close(ctx)

        var projects []*models.Project
        if err = cursor.All(ctx, &amp;projects); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return projects, nil</span>
}

// List 列出项目（支持分页）
func (r *projectRepository) List(ctx context.Context, skip, limit int64) ([]*models.Project, int64, error) <span class="cov0" title="0">{
        filter := bson.M{}

        // 获取总数
        total, err := r.collection.CountDocuments(ctx, filter)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        // 查询数据
        <span class="cov0" title="0">opts := options.Find().
                SetSkip(skip).
                SetLimit(limit).
                SetSort(bson.D{primitive.E{Key: "created_at", Value: -1}})

        cursor, err := r.collection.Find(ctx, filter, opts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>
        <span class="cov0" title="0">defer cursor.Close(ctx)

        var projects []*models.Project
        if err = cursor.All(ctx, &amp;projects); err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">return projects, total, nil</span>
}

// EnvironmentRepository 环境仓库接口
type EnvironmentRepository interface {
        Create(ctx context.Context, environment *models.Environment) error
        Update(ctx context.Context, environment *models.Environment) error
        Delete(ctx context.Context, id string) error
        FindByID(ctx context.Context, id string) (*models.Environment, error)
        FindByProject(ctx context.Context, projectID string) ([]*models.Environment, error)
}

type environmentRepository struct {
        collection *mongo.Collection
}

// NewEnvironmentRepository 创建环境仓库
func NewEnvironmentRepository() EnvironmentRepository <span class="cov0" title="0">{
        return &amp;environmentRepository{
                collection: GetCollection("environments"),
        }
}</span>

// Create 创建环境
func (r *environmentRepository) Create(ctx context.Context, environment *models.Environment) error <span class="cov0" title="0">{
        environment.CreatedAt = time.Now()
        environment.UpdatedAt = time.Now()

        result, err := r.collection.InsertOne(ctx, environment)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if oid, ok := result.InsertedID.(primitive.ObjectID); ok </span><span class="cov0" title="0">{
                environment.ID = oid.Hex()
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Update 更新环境
func (r *environmentRepository) Update(ctx context.Context, environment *models.Environment) error <span class="cov0" title="0">{
        environment.UpdatedAt = time.Now()

        objectID, err := primitive.ObjectIDFromHex(environment.ID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">filter := bson.M{"_id": objectID}
        // 排除 _id 字段，避免更新不可变字段
        update := bson.M{"$set": bson.M{
                "name":        environment.Name,
                "project_id":  environment.ProjectID,
                "base_url":    environment.BaseURL,
                "variables":   environment.Variables,
                "updated_at":  environment.UpdatedAt,
        }}

        _, err = r.collection.UpdateOne(ctx, filter, update)
        return err</span>
}

// Delete 删除环境
func (r *environmentRepository) Delete(ctx context.Context, id string) error <span class="cov0" title="0">{
        objectID, err := primitive.ObjectIDFromHex(id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">filter := bson.M{"_id": objectID}
        _, err = r.collection.DeleteOne(ctx, filter)
        return err</span>
}

// FindByID 根据ID查找环境
func (r *environmentRepository) FindByID(ctx context.Context, id string) (*models.Environment, error) <span class="cov0" title="0">{
        objectID, err := primitive.ObjectIDFromHex(id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">filter := bson.M{"_id": objectID}

        var environment models.Environment
        err = r.collection.FindOne(ctx, filter).Decode(&amp;environment)
        if err != nil </span><span class="cov0" title="0">{
                if err == mongo.ErrNoDocuments </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov0" title="0">return &amp;environment, nil</span>
}

// FindByProject 查找项目下的所有环境
func (r *environmentRepository) FindByProject(ctx context.Context, projectID string) ([]*models.Environment, error) <span class="cov0" title="0">{
        filter := bson.M{"project_id": projectID}

        cursor, err := r.collection.Find(ctx, filter)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer cursor.Close(ctx)

        var environments []*models.Environment
        if err = cursor.All(ctx, &amp;environments); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return environments, nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package repository

import (
        "context"
        "time"

        "github.com/gomockserver/mockserver/internal/models"
        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/bson/primitive"
        "go.mongodb.org/mongo-driver/mongo"
        "go.mongodb.org/mongo-driver/mongo/options"
)

// RuleRepository 规则仓库接口
type RuleRepository interface {
        Create(ctx context.Context, rule *models.Rule) error
        Update(ctx context.Context, rule *models.Rule) error
        Delete(ctx context.Context, id string) error
        FindByID(ctx context.Context, id string) (*models.Rule, error)
        FindByEnvironment(ctx context.Context, projectID, environmentID string) ([]*models.Rule, error)
        FindEnabledByEnvironment(ctx context.Context, projectID, environmentID string) ([]*models.Rule, error)
        List(ctx context.Context, filter map[string]interface{}, skip, limit int64) ([]*models.Rule, int64, error)
}

type ruleRepository struct {
        collection *mongo.Collection
}

// NewRuleRepository 创建规则仓库
func NewRuleRepository() RuleRepository <span class="cov0" title="0">{
        return &amp;ruleRepository{
                collection: GetCollection("rules"),
        }
}</span>

// Create 创建规则
func (r *ruleRepository) Create(ctx context.Context, rule *models.Rule) error <span class="cov0" title="0">{
        rule.CreatedAt = time.Now()
        rule.UpdatedAt = time.Now()

        result, err := r.collection.InsertOne(ctx, rule)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if oid, ok := result.InsertedID.(primitive.ObjectID); ok </span><span class="cov0" title="0">{
                rule.ID = oid.Hex()
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Update 更新规则
func (r *ruleRepository) Update(ctx context.Context, rule *models.Rule) error <span class="cov0" title="0">{
        rule.UpdatedAt = time.Now()

        objectID, err := primitive.ObjectIDFromHex(rule.ID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">filter := bson.M{"_id": objectID}
        // 排除 _id 字段，避免更新不可变字段
        update := bson.M{"$set": bson.M{
                "name":             rule.Name,
                "project_id":       rule.ProjectID,
                "environment_id":   rule.EnvironmentID,
                "protocol":         rule.Protocol,
                "match_type":       rule.MatchType,
                "priority":         rule.Priority,
                "enabled":          rule.Enabled,
                "match_condition":  rule.MatchCondition,
                "response":         rule.Response,
                "tags":             rule.Tags,
                "creator":          rule.Creator,
                "updated_at":       rule.UpdatedAt,
        }}

        _, err = r.collection.UpdateOne(ctx, filter, update)
        return err</span>
}

// Delete 删除规则
func (r *ruleRepository) Delete(ctx context.Context, id string) error <span class="cov0" title="0">{
        objectID, err := primitive.ObjectIDFromHex(id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">filter := bson.M{"_id": objectID}
        _, err = r.collection.DeleteOne(ctx, filter)
        return err</span>
}

// FindByID 根据ID查找规则
func (r *ruleRepository) FindByID(ctx context.Context, id string) (*models.Rule, error) <span class="cov0" title="0">{
        objectID, err := primitive.ObjectIDFromHex(id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">filter := bson.M{"_id": objectID}

        var rule models.Rule
        err = r.collection.FindOne(ctx, filter).Decode(&amp;rule)
        if err != nil </span><span class="cov0" title="0">{
                if err == mongo.ErrNoDocuments </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov0" title="0">return &amp;rule, nil</span>
}

// FindByEnvironment 查找环境下的所有规则
func (r *ruleRepository) FindByEnvironment(ctx context.Context, projectID, environmentID string) ([]*models.Rule, error) <span class="cov0" title="0">{
        filter := bson.M{
                "project_id":     projectID,
                "environment_id": environmentID,
        }

        opts := options.Find().SetSort(bson.D{{Key: "priority", Value: -1}})

        cursor, err := r.collection.Find(ctx, filter, opts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer cursor.Close(ctx)

        var rules []*models.Rule
        if err = cursor.All(ctx, &amp;rules); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return rules, nil</span>
}

// FindEnabledByEnvironment 查找环境下所有启用的规则
func (r *ruleRepository) FindEnabledByEnvironment(ctx context.Context, projectID, environmentID string) ([]*models.Rule, error) <span class="cov0" title="0">{
        filter := bson.M{
                "project_id":     projectID,
                "environment_id": environmentID,
                "enabled":        true,
        }

        opts := options.Find().SetSort(bson.D{{Key: "priority", Value: -1}})

        cursor, err := r.collection.Find(ctx, filter, opts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer cursor.Close(ctx)

        var rules []*models.Rule
        if err = cursor.All(ctx, &amp;rules); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return rules, nil</span>
}

// List 列出规则（支持分页和过滤）
func (r *ruleRepository) List(ctx context.Context, filter map[string]interface{}, skip, limit int64) ([]*models.Rule, int64, error) <span class="cov0" title="0">{
        // 转换过滤条件
        mongoFilter := bson.M{}
        for k, v := range filter </span><span class="cov0" title="0">{
                mongoFilter[k] = v
        }</span>

        // 获取总数
        <span class="cov0" title="0">total, err := r.collection.CountDocuments(ctx, mongoFilter)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        // 查询数据
        <span class="cov0" title="0">opts := options.Find().
                SetSkip(skip).
                SetLimit(limit).
                SetSort(bson.D{{Key: "created_at", Value: -1}})

        cursor, err := r.collection.Find(ctx, mongoFilter, opts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>
        <span class="cov0" title="0">defer cursor.Close(ctx)

        var rules []*models.Rule
        if err = cursor.All(ctx, &amp;rules); err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">return rules, total, nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package service

import (
        "github.com/gin-gonic/gin"
        "github.com/gomockserver/mockserver/internal/api"
        "github.com/gomockserver/mockserver/pkg/logger"
        "go.uber.org/zap"
)

// AdminService 管理服务
type AdminService struct {
        ruleHandler    *api.RuleHandler
        projectHandler *api.ProjectHandler
}

// NewAdminService 创建管理服务
func NewAdminService(ruleHandler *api.RuleHandler, projectHandler *api.ProjectHandler) *AdminService <span class="cov8" title="1">{
        return &amp;AdminService{
                ruleHandler:    ruleHandler,
                projectHandler: projectHandler,
        }
}</span>

// StartAdminServer 启动管理服务器
func StartAdminServer(addr string, service *AdminService) error <span class="cov0" title="0">{
        gin.SetMode(gin.ReleaseMode)
        r := gin.New()
        r.Use(gin.Recovery())
        r.Use(CORSMiddleware())

        // API 路由组
        v1 := r.Group("/api/v1")
        </span><span class="cov0" title="0">{
                // 规则管理 API
                rules := v1.Group("/rules")
                </span><span class="cov0" title="0">{
                        rules.GET("", service.ruleHandler.ListRules)
                        rules.POST("", service.ruleHandler.CreateRule)
                        rules.GET("/:id", service.ruleHandler.GetRule)
                        rules.PUT("/:id", service.ruleHandler.UpdateRule)
                        rules.DELETE("/:id", service.ruleHandler.DeleteRule)
                        rules.POST("/:id/enable", service.ruleHandler.EnableRule)
                        rules.POST("/:id/disable", service.ruleHandler.DisableRule)
                }</span>

                // 项目管理 API
                <span class="cov0" title="0">projects := v1.Group("/projects")
                </span><span class="cov0" title="0">{
                        projects.POST("", service.projectHandler.CreateProject)
                        projects.GET("/:id", service.projectHandler.GetProject)
                        projects.PUT("/:id", service.projectHandler.UpdateProject)
                        projects.DELETE("/:id", service.projectHandler.DeleteProject)
                }</span>

                // 环境管理 API
                <span class="cov0" title="0">environments := v1.Group("/environments")
                </span><span class="cov0" title="0">{
                        environments.GET("", service.projectHandler.ListEnvironments)
                        environments.POST("", service.projectHandler.CreateEnvironment)
                        environments.GET("/:id", service.projectHandler.GetEnvironment)
                        environments.PUT("/:id", service.projectHandler.UpdateEnvironment)
                        environments.DELETE("/:id", service.projectHandler.DeleteEnvironment)
                }</span>

                // 系统管理 API
                <span class="cov0" title="0">system := v1.Group("/system")
                </span><span class="cov0" title="0">{
                        system.GET("/health", HealthCheck)
                        system.GET("/version", GetVersion)
                }</span>
        }

        <span class="cov0" title="0">logger.Info("starting admin server", zap.String("address", addr))
        return r.Run(addr)</span>
}

// CORSMiddleware CORS 中间件
func CORSMiddleware() gin.HandlerFunc <span class="cov8" title="1">{
        return func(c *gin.Context) </span><span class="cov8" title="1">{
                c.Writer.Header().Set("Access-Control-Allow-Origin", "*")
                c.Writer.Header().Set("Access-Control-Allow-Credentials", "true")
                c.Writer.Header().Set("Access-Control-Allow-Headers", "Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, Authorization, accept, origin, Cache-Control, X-Requested-With")
                c.Writer.Header().Set("Access-Control-Allow-Methods", "POST, OPTIONS, GET, PUT, DELETE")

                if c.Request.Method == "OPTIONS" </span><span class="cov8" title="1">{
                        c.AbortWithStatus(204)
                        return
                }</span>

                <span class="cov8" title="1">c.Next()</span>
        }
}

// HealthCheck 健康检查
func HealthCheck(c *gin.Context) <span class="cov8" title="1">{
        c.JSON(200, gin.H{
                "status": "healthy",
        })
}</span>

// GetVersion 获取版本信息
func GetVersion(c *gin.Context) <span class="cov8" title="1">{
        c.JSON(200, gin.H{
                "version": "0.1.0",
                "name":    "MockServer",
        })
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package service

import (
        "context"

        "github.com/gin-gonic/gin"
        "github.com/gomockserver/mockserver/internal/adapter"
        "github.com/gomockserver/mockserver/internal/models"
        "github.com/gomockserver/mockserver/pkg/logger"
        "go.uber.org/zap"
)

// MatchEngineInterface 匹配引擎接口
type MatchEngineInterface interface {
        Match(ctx context.Context, request *adapter.Request, projectID, environmentID string) (*models.Rule, error)
}

// MockExecutorInterface Mock 执行器接口
type MockExecutorInterface interface {
        Execute(request *adapter.Request, rule *models.Rule) (*adapter.Response, error)
        GetDefaultResponse() *adapter.Response
}

// MockService Mock 服务
type MockService struct {
        httpAdapter  *adapter.HTTPAdapter
        matchEngine  MatchEngineInterface
        mockExecutor MockExecutorInterface
}

// NewMockService 创建 Mock 服务
func NewMockService(matchEngine MatchEngineInterface, mockExecutor MockExecutorInterface) *MockService <span class="cov8" title="1">{
        return &amp;MockService{
                httpAdapter:  adapter.NewHTTPAdapter(),
                matchEngine:  matchEngine,
                mockExecutor: mockExecutor,
        }
}</span>

// HandleMockRequest 处理 Mock 请求
func (s *MockService) HandleMockRequest(c *gin.Context) <span class="cov8" title="1">{
        // 从路径中提取项目ID和环境ID
        // 请求格式：/:projectID/:environmentID/*path
        projectID := c.Param("projectID")
        environmentID := c.Param("environmentID")

        if projectID == "" || environmentID == "" </span><span class="cov8" title="1">{
                c.JSON(400, gin.H{
                        "error": "projectID and environmentID are required",
                })
                return
        }</span>

        // 解析请求为统一模型
        <span class="cov8" title="1">request, err := s.httpAdapter.Parse(c)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to parse request", zap.Error(err))
                c.JSON(500, gin.H{
                        "error": "Failed to parse request",
                })
                return
        }</span>

        // 匹配规则
        <span class="cov8" title="1">ctx := context.Background()
        rule, err := s.matchEngine.Match(ctx, request, projectID, environmentID)
        if err != nil </span><span class="cov8" title="1">{
                logger.Error("failed to match rule", zap.Error(err))
                c.JSON(500, gin.H{
                        "error": "Failed to match rule",
                })
                return
        }</span>

        <span class="cov8" title="1">var response *adapter.Response

        // 如果没有匹配的规则，返回默认响应
        if rule == nil </span><span class="cov8" title="1">{
                logger.Info("no rule matched, using default response",
                        zap.String("path", request.Path),
                        zap.String("project_id", projectID),
                        zap.String("environment_id", environmentID))
                response = s.mockExecutor.GetDefaultResponse()
        }</span> else<span class="cov8" title="1"> {
                // 执行 Mock 响应生成
                response, err = s.mockExecutor.Execute(request, rule)
                if err != nil </span><span class="cov8" title="1">{
                        logger.Error("failed to execute mock", zap.Error(err))
                        c.JSON(500, gin.H{
                                "error": "Failed to execute mock",
                        })
                        return
                }</span>
        }

        // 写入响应
        <span class="cov8" title="1">s.httpAdapter.WriteResponse(c, response)</span>
}

// StartMockServer 启动 Mock 服务器
func StartMockServer(addr string, service *MockService) error <span class="cov0" title="0">{
        gin.SetMode(gin.ReleaseMode)
        r := gin.New()
        r.Use(gin.Recovery())

        // Mock 请求处理路由
        // 格式：/:projectID/:environmentID/*path
        r.Any("/:projectID/:environmentID/*path", service.HandleMockRequest)

        logger.Info("starting mock server", zap.String("address", addr))
        return r.Run(addr)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
