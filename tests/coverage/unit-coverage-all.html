
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>adapter: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/gomockserver/mockserver/internal/adapter/http_adapter.go (96.7%)</option>
				
				<option value="file1">github.com/gomockserver/mockserver/internal/adapter/websocket_adapter.go (70.9%)</option>
				
				<option value="file2">github.com/gomockserver/mockserver/internal/config/config.go (94.4%)</option>
				
				<option value="file3">github.com/gomockserver/mockserver/internal/engine/common_patterns.go (83.3%)</option>
				
				<option value="file4">github.com/gomockserver/mockserver/internal/engine/lru_cache.go (100.0%)</option>
				
				<option value="file5">github.com/gomockserver/mockserver/internal/engine/match_engine.go (72.0%)</option>
				
				<option value="file6">github.com/gomockserver/mockserver/internal/engine/regex_validator.go (100.0%)</option>
				
				<option value="file7">github.com/gomockserver/mockserver/internal/engine/script_engine.go (84.7%)</option>
				
				<option value="file8">github.com/gomockserver/mockserver/internal/executor/mock_executor.go (74.5%)</option>
				
				<option value="file9">github.com/gomockserver/mockserver/internal/executor/proxy_executor.go (90.9%)</option>
				
				<option value="file10">github.com/gomockserver/mockserver/internal/executor/template_engine.go (82.3%)</option>
				
				<option value="file11">github.com/gomockserver/mockserver/internal/metrics/metrics.go (100.0%)</option>
				
				<option value="file12">github.com/gomockserver/mockserver/internal/middleware/cors.go (100.0%)</option>
				
				<option value="file13">github.com/gomockserver/mockserver/internal/middleware/request_logger.go (97.2%)</option>
				
				<option value="file14">github.com/gomockserver/mockserver/internal/models/errors.go (0.0%)</option>
				
				<option value="file15">github.com/gomockserver/mockserver/internal/monitoring/metrics.go (100.0%)</option>
				
				<option value="file16">github.com/gomockserver/mockserver/internal/repository/database.go (0.0%)</option>
				
				<option value="file17">github.com/gomockserver/mockserver/internal/repository/project_repository.go (0.0%)</option>
				
				<option value="file18">github.com/gomockserver/mockserver/internal/repository/request_log_repository.go (72.6%)</option>
				
				<option value="file19">github.com/gomockserver/mockserver/internal/repository/rule_repository.go (0.0%)</option>
				
				<option value="file20">github.com/gomockserver/mockserver/internal/service/admin_service.go (4.5%)</option>
				
				<option value="file21">github.com/gomockserver/mockserver/internal/service/batch_operation_service.go (92.2%)</option>
				
				<option value="file22">github.com/gomockserver/mockserver/internal/service/health.go (93.2%)</option>
				
				<option value="file23">github.com/gomockserver/mockserver/internal/service/import_export_service.go (83.1%)</option>
				
				<option value="file24">github.com/gomockserver/mockserver/internal/service/log_cleanup_service.go (92.3%)</option>
				
				<option value="file25">github.com/gomockserver/mockserver/internal/service/middleware.go (100.0%)</option>
				
				<option value="file26">github.com/gomockserver/mockserver/internal/service/mock_service.go (70.6%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package adapter

import (
        "io"
        "strings"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/gomockserver/mockserver/internal/models"
        "github.com/google/uuid"
)

// HTTPAdapter HTTP 协议适配器
type HTTPAdapter struct{}

// NewHTTPAdapter 创建 HTTP 适配器
func NewHTTPAdapter() *HTTPAdapter <span class="cov8" title="1">{
        return &amp;HTTPAdapter{}
}</span>

// Parse 解析 HTTP 请求为统一模型
func (a *HTTPAdapter) Parse(rawRequest interface{}) (*Request, error) <span class="cov8" title="1">{
        c, ok := rawRequest.(*gin.Context)
        if !ok </span><span class="cov8" title="1">{
                return nil, nil
        }</span>

        // 生成请求ID
        <span class="cov8" title="1">requestID := uuid.New().String()

        // 读取请求体
        body, err := io.ReadAll(c.Request.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 提取Headers
        <span class="cov8" title="1">headers := make(map[string]string)
        for key, values := range c.Request.Header </span><span class="cov8" title="1">{
                if len(values) &gt; 0 </span><span class="cov8" title="1">{
                        headers[key] = values[0]
                }</span>
        }

        // 提取 Query 参数
        <span class="cov8" title="1">query := make(map[string]string)
        for key, values := range c.Request.URL.Query() </span><span class="cov8" title="1">{
                if len(values) &gt; 0 </span><span class="cov8" title="1">{
                        query[key] = values[0]
                }</span>
        }

        // 获取客户端IP
        <span class="cov8" title="1">clientIP := c.ClientIP()

        // 获取实际的API路径（移除 /:projectID/:environmentID 前缀）
        // Gin的路由格式：/:projectID/:environmentID/*path
        // c.Param("path") 会返回包含前导斜杠的路径，如 "/api/users/1"
        actualPath := c.Param("path")
        if actualPath == "" </span><span class="cov8" title="1">{
                // 如果没有path参数，使用完整路径
                actualPath = c.Request.URL.Path
        }</span>

        // 创建统一请求模型
        <span class="cov8" title="1">request := &amp;Request{
                ID:         requestID,
                Protocol:   models.ProtocolHTTP,
                Path:       actualPath,
                Headers:    headers,
                Body:       body,
                SourceIP:   clientIP,
                ReceivedAt: time.Now(),
                Metadata: map[string]interface{}{
                        "method":       c.Request.Method,
                        "query":        query,
                        "raw_query":    c.Request.URL.RawQuery,
                        "host":         c.Request.Host,
                        "user_agent":   c.Request.UserAgent(),
                        "content_type": c.ContentType(),
                },
        }

        return request, nil</span>
}

// Build 构建 HTTP 响应
func (a *HTTPAdapter) Build(response *Response) (interface{}, error) <span class="cov8" title="1">{
        // 返回响应配置，由调用方设置到 gin.Context
        return response, nil
}</span>

// WriteResponse 将响应写入 gin.Context
func (a *HTTPAdapter) WriteResponse(c *gin.Context, response *Response) <span class="cov8" title="1">{
        // 设置响应头
        for key, value := range response.Headers </span><span class="cov8" title="1">{
                c.Header(key, value)
        }</span>

        // 设置状态码和响应体
        <span class="cov8" title="1">c.Data(response.StatusCode, getContentType(response.Headers), response.Body)</span>
}

// getContentType 从响应头中获取 Content-Type
func getContentType(headers map[string]string) string <span class="cov8" title="1">{
        for key, value := range headers </span><span class="cov8" title="1">{
                if strings.ToLower(key) == "content-type" </span><span class="cov8" title="1">{
                        return value
                }</span>
        }
        <span class="cov8" title="1">return "application/json"</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package adapter

import (
        "errors"
        "net/http"
        "sync"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/gomockserver/mockserver/internal/models"
        "github.com/gomockserver/mockserver/pkg/logger"
        "github.com/google/uuid"
        "github.com/gorilla/websocket"
        "go.uber.org/zap"
)

// MessageHandler 消息处理函数类型
type MessageHandler func(request *Request, conn *WebSocketConnection)

// WebSocketAdapter WebSocket 协议适配器
type WebSocketAdapter struct {
        upgrader websocket.Upgrader
        // 连接管理
        connections     map[string]*WebSocketConnection
        connectionsLock sync.RWMutex
        // 配置
        maxConnections int
        pingInterval   time.Duration
        pongWait       time.Duration
        writeWait      time.Duration
        maxMessageSize int64
        // 消息处理器
        messageHandler MessageHandler
}

// WebSocketConnection WebSocket 连接
type WebSocketConnection struct {
        ID         string
        Conn       *websocket.Conn
        ProjectID  string
        EnvID      string
        Send       chan []byte
        Done       chan struct{}
        LastPing   time.Time
        LastPong   time.Time
        Metadata   map[string]interface{}
        mu         sync.RWMutex
}

// WebSocketMessage WebSocket 消息
type WebSocketMessage struct {
        Type      string                 `json:"type"`      // message, ping, pong, close
        Data      interface{}            `json:"data"`      // 消息数据
        Timestamp time.Time              `json:"timestamp"` // 时间戳
        Metadata  map[string]interface{} `json:"metadata"`  // 元数据
}

// NewWebSocketAdapter 创建 WebSocket 适配器
func NewWebSocketAdapter() *WebSocketAdapter <span class="cov8" title="1">{
        return &amp;WebSocketAdapter{
                upgrader: websocket.Upgrader{
                        ReadBufferSize:  1024,
                        WriteBufferSize: 1024,
                        CheckOrigin: func(r *http.Request) bool </span><span class="cov8" title="1">{
                                // 允许所有来源（生产环境需要根据需求限制）
                                return true
                        }</span>,
                },
                connections:    make(map[string]*WebSocketConnection),
                maxConnections: 1000,            // 默认最大连接数
                pingInterval:   30 * time.Second, // Ping 间隔
                pongWait:       60 * time.Second, // Pong 等待时间
                writeWait:      10 * time.Second, // 写超时
                maxMessageSize: 512 * 1024,       // 最大消息大小 512KB
        }
}

// Parse 解析 WebSocket 请求为统一模型
func (a *WebSocketAdapter) Parse(rawRequest interface{}) (*Request, error) <span class="cov8" title="1">{
        c, ok := rawRequest.(*gin.Context)
        if !ok </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        // 升级 HTTP 连接为 WebSocket
        <span class="cov8" title="1">conn, err := a.upgrader.Upgrade(c.Writer, c.Request, nil)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to upgrade websocket", zap.Error(err))
                return nil, err
        }</span>

        // 生成连接 ID
        <span class="cov8" title="1">connID := uuid.New().String()

        // 创建连接对象
        wsConn := &amp;WebSocketConnection{
                ID:       connID,
                Conn:     conn,
                Send:     make(chan []byte, 256),
                Done:     make(chan struct{}),
                LastPing: time.Now(),
                LastPong: time.Now(),
                Metadata: make(map[string]interface{}),
        }

        // 从 URL 参数获取项目和环境 ID
        projectID := c.Param("projectID")
        envID := c.Param("environmentID")
        wsConn.ProjectID = projectID
        wsConn.EnvID = envID

        // 保存连接
        a.addConnection(wsConn)

        // 启动读写协程
        go a.readPump(wsConn)
        go a.writePump(wsConn)
        go a.pingPump(wsConn)

        // 创建统一请求模型（用于首次连接）
        request := &amp;Request{
                ID:         connID,
                Protocol:   models.ProtocolWebSocket,
                Path:       c.Request.URL.Path,
                Headers:    extractHeaders(c.Request.Header),
                SourceIP:   c.ClientIP(),
                ReceivedAt: time.Now(),
                Metadata: map[string]interface{}{
                        "connection_id": connID,
                        "project_id":    projectID,
                        "environment_id": envID,
                        "query":         extractQuery(c.Request.URL.Query()),
                        "event":         "connect",
                },
        }

        logger.Info("websocket connection established",
                zap.String("connection_id", connID),
                zap.String("project_id", projectID),
                zap.String("environment_id", envID),
        )

        return request, nil</span>
}

// Build 构建 WebSocket 响应
func (a *WebSocketAdapter) Build(response *Response) (interface{}, error) <span class="cov0" title="0">{
        // WebSocket 响应通过 Send channel 发送，这里不需要处理
        return response, nil
}</span>

// addConnection 添加连接
func (a *WebSocketAdapter) addConnection(conn *WebSocketConnection) error <span class="cov8" title="1">{
        a.connectionsLock.Lock()
        defer a.connectionsLock.Unlock()

        // 检查连接数限制
        if len(a.connections) &gt;= a.maxConnections </span><span class="cov8" title="1">{
                logger.Warn("max connections reached", zap.Int("max", a.maxConnections))
                if conn.Conn != nil </span><span class="cov0" title="0">{
                        conn.Conn.Close()
                }</span>
                <span class="cov8" title="1">return ErrMaxConnectionsReached</span>
        }

        <span class="cov8" title="1">a.connections[conn.ID] = conn
        return nil</span>
}

// removeConnection 移除连接
func (a *WebSocketAdapter) removeConnection(connID string) <span class="cov8" title="1">{
        a.connectionsLock.Lock()
        defer a.connectionsLock.Unlock()

        if conn, exists := a.connections[connID]; exists </span><span class="cov8" title="1">{
                close(conn.Done)
                close(conn.Send)
                delete(a.connections, connID)
                logger.Info("websocket connection removed", zap.String("connection_id", connID))
        }</span>
}

// GetConnection 获取连接
func (a *WebSocketAdapter) GetConnection(connID string) (*WebSocketConnection, bool) <span class="cov8" title="1">{
        a.connectionsLock.RLock()
        defer a.connectionsLock.RUnlock()
        conn, exists := a.connections[connID]
        return conn, exists
}</span>

// GetConnectionCount 获取当前连接数
func (a *WebSocketAdapter) GetConnectionCount() int <span class="cov8" title="1">{
        a.connectionsLock.RLock()
        defer a.connectionsLock.RUnlock()
        return len(a.connections)
}</span>

// BroadcastMessage 广播消息到所有连接
func (a *WebSocketAdapter) BroadcastMessage(message []byte) <span class="cov8" title="1">{
        a.connectionsLock.RLock()
        defer a.connectionsLock.RUnlock()

        for _, conn := range a.connections </span><span class="cov8" title="1">{
                select </span>{
                case conn.Send &lt;- message:<span class="cov8" title="1"></span>
                default:<span class="cov0" title="0">
                        logger.Warn("failed to send broadcast message, channel full",
                                zap.String("connection_id", conn.ID))</span>
                }
        }
}

// SendToConnection 发送消息到指定连接
func (a *WebSocketAdapter) SendToConnection(connID string, message []byte) error <span class="cov8" title="1">{
        conn, exists := a.GetConnection(connID)
        if !exists </span><span class="cov8" title="1">{
                return ErrConnectionNotFound
        }</span>

        <span class="cov8" title="1">select </span>{
        case conn.Send &lt;- message:<span class="cov8" title="1">
                return nil</span>
        case &lt;-time.After(a.writeWait):<span class="cov0" title="0">
                return ErrSendTimeout</span>
        }
}

// SetMessageHandler 设置消息处理器
func (a *WebSocketAdapter) SetMessageHandler(handler MessageHandler) <span class="cov0" title="0">{
        a.messageHandler = handler
}</span>

// readPump 从 WebSocket 读取消息
func (a *WebSocketAdapter) readPump(conn *WebSocketConnection) <span class="cov8" title="1">{
        defer func() </span><span class="cov8" title="1">{
                a.removeConnection(conn.ID)
                conn.Conn.Close()
        }</span>()

        <span class="cov8" title="1">conn.Conn.SetReadLimit(a.maxMessageSize)
        conn.Conn.SetReadDeadline(time.Now().Add(a.pongWait))
        conn.Conn.SetPongHandler(func(string) error </span><span class="cov0" title="0">{
                conn.mu.Lock()
                conn.LastPong = time.Now()
                conn.mu.Unlock()
                conn.Conn.SetReadDeadline(time.Now().Add(a.pongWait))
                return nil
        }</span>)

        <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                messageType, message, err := conn.Conn.ReadMessage()
                if err != nil </span><span class="cov8" title="1">{
                        if websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway, websocket.CloseAbnormalClosure) </span><span class="cov0" title="0">{
                                logger.Error("websocket read error", zap.Error(err))
                        }</span>
                        <span class="cov8" title="1">break</span>
                }

                // 处理接收到的消息
                <span class="cov0" title="0">logger.Debug("websocket message received",
                        zap.String("connection_id", conn.ID),
                        zap.Int("type", messageType),
                        zap.Int("size", len(message)),
                )

                // 将消息传递给消息处理器
                if a.messageHandler != nil </span><span class="cov0" title="0">{
                        request := a.createMessageRequest(conn, message)
                        a.messageHandler(request, conn)
                }</span>
        }
}

// createMessageRequest 创建消息请求
func (a *WebSocketAdapter) createMessageRequest(conn *WebSocketConnection, message []byte) *Request <span class="cov0" title="0">{
        return &amp;Request{
                ID:         uuid.New().String(),
                Protocol:   models.ProtocolWebSocket,
                Path:       "", // WebSocket 没有路径概念
                Body:       message,
                SourceIP:   "", // 从连接获取
                ReceivedAt: time.Now(),
                Metadata: map[string]interface{}{
                        "connection_id":  conn.ID,
                        "project_id":     conn.ProjectID,
                        "environment_id": conn.EnvID,
                        "event":          "message",
                },
        }
}</span>

// writePump 向 WebSocket 写入消息
func (a *WebSocketAdapter) writePump(conn *WebSocketConnection) <span class="cov8" title="1">{
        ticker := time.NewTicker(a.pingInterval)
        defer func() </span><span class="cov8" title="1">{
                ticker.Stop()
                conn.Conn.Close()
        }</span>()

        <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                select </span>{
                case message, ok := &lt;-conn.Send:<span class="cov0" title="0">
                        conn.Conn.SetWriteDeadline(time.Now().Add(a.writeWait))
                        if !ok </span><span class="cov0" title="0">{
                                // Channel 已关闭
                                conn.Conn.WriteMessage(websocket.CloseMessage, []byte{})
                                return
                        }</span>

                        <span class="cov0" title="0">err := conn.Conn.WriteMessage(websocket.TextMessage, message)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Error("websocket write error", zap.Error(err))
                                return
                        }</span>

                case &lt;-conn.Done:<span class="cov8" title="1">
                        return</span>
                }
        }
}

// pingPump 发送心跳 Ping
func (a *WebSocketAdapter) pingPump(conn *WebSocketConnection) <span class="cov8" title="1">{
        ticker := time.NewTicker(a.pingInterval)
        defer ticker.Stop()

        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ticker.C:<span class="cov0" title="0">
                        conn.mu.Lock()
                        conn.LastPing = time.Now()
                        conn.mu.Unlock()

                        conn.Conn.SetWriteDeadline(time.Now().Add(a.writeWait))
                        if err := conn.Conn.WriteMessage(websocket.PingMessage, nil); err != nil </span><span class="cov0" title="0">{
                                logger.Error("failed to send ping", zap.Error(err))
                                return
                        }</span>

                case &lt;-conn.Done:<span class="cov8" title="1">
                        return</span>
                }
        }
}

// extractHeaders 提取 HTTP headers
func extractHeaders(headers map[string][]string) map[string]string <span class="cov8" title="1">{
        result := make(map[string]string)
        for key, values := range headers </span><span class="cov8" title="1">{
                if len(values) &gt; 0 </span><span class="cov8" title="1">{
                        result[key] = values[0]
                }</span>
        }
        <span class="cov8" title="1">return result</span>
}

// extractQuery 提取查询参数
func extractQuery(query map[string][]string) map[string]string <span class="cov8" title="1">{
        result := make(map[string]string)
        for key, values := range query </span><span class="cov8" title="1">{
                if len(values) &gt; 0 </span><span class="cov8" title="1">{
                        result[key] = values[0]
                }</span>
        }
        <span class="cov8" title="1">return result</span>
}

// 错误定义
var (
        ErrMaxConnectionsReached = errors.New("maximum connections reached")
        ErrConnectionNotFound    = errors.New("connection not found")
        ErrSendTimeout          = errors.New("send message timeout")
)
</pre>
		
		<pre class="file" id="file2" style="display: none">package config

import (
        "fmt"
        "time"

        "github.com/spf13/viper"
)

// Config 应用配置结构
type Config struct {
        Server      ServerConfig      `mapstructure:"server"`
        Database    DatabaseConfig    `mapstructure:"database"`
        Redis       RedisConfig       `mapstructure:"redis"`
        Security    SecurityConfig    `mapstructure:"security"`
        Logging     LoggingConfig     `mapstructure:"logging"`
        Performance PerformanceConfig `mapstructure:"performance"`
        Features    FeaturesConfig    `mapstructure:"features"`
}

// ServerConfig 服务器配置
type ServerConfig struct {
        Admin AdminServerConfig `mapstructure:"admin"`
        Mock  MockServerConfig  `mapstructure:"mock"`
}

// AdminServerConfig 管理 API 服务配置
type AdminServerConfig struct {
        Host string `mapstructure:"host"`
        Port int    `mapstructure:"port"`
}

// MockServerConfig Mock 服务配置
type MockServerConfig struct {
        Host string `mapstructure:"host"`
        Port int    `mapstructure:"port"`
}

// DatabaseConfig 数据库配置
type DatabaseConfig struct {
        MongoDB MongoDBConfig `mapstructure:"mongodb"`
}

// MongoDBConfig MongoDB 配置
type MongoDBConfig struct {
        URI      string         `mapstructure:"uri"`
        Database string         `mapstructure:"database"`
        Timeout  time.Duration  `mapstructure:"timeout"`
        Pool     ConnectionPool `mapstructure:"pool"`
}

// ConnectionPool 连接池配置
type ConnectionPool struct {
        Min int `mapstructure:"min"`
        Max int `mapstructure:"max"`
}

// RedisConfig Redis 配置
type RedisConfig struct {
        Enabled  bool           `mapstructure:"enabled"`
        Host     string         `mapstructure:"host"`
        Port     int            `mapstructure:"port"`
        Password string         `mapstructure:"password"`
        DB       int            `mapstructure:"db"`
        Pool     ConnectionPool `mapstructure:"pool"`
}

// SecurityConfig 安全配置
type SecurityConfig struct {
        JWT         JWTConfig         `mapstructure:"jwt"`
        APIKey      APIKeyConfig      `mapstructure:"api_key"`
        IPWhitelist IPWhitelistConfig `mapstructure:"ip_whitelist"`
}

// JWTConfig JWT 配置
type JWTConfig struct {
        Secret     string `mapstructure:"secret"`
        Expiration int    `mapstructure:"expiration"`
}

// APIKeyConfig API Key 配置
type APIKeyConfig struct {
        Enabled bool `mapstructure:"enabled"`
}

// IPWhitelistConfig IP 白名单配置
type IPWhitelistConfig struct {
        Enabled bool     `mapstructure:"enabled"`
        IPs     []string `mapstructure:"ips"`
}

// LoggingConfig 日志配置
type LoggingConfig struct {
        Level  string        `mapstructure:"level"`
        Format string        `mapstructure:"format"`
        Output string        `mapstructure:"output"`
        File   LogFileConfig `mapstructure:"file"`
}

// LogFileConfig 日志文件配置
type LogFileConfig struct {
        Path       string `mapstructure:"path"`
        MaxSize    int    `mapstructure:"max_size"`
        MaxBackups int    `mapstructure:"max_backups"`
        MaxAge     int    `mapstructure:"max_age"`
}

// PerformanceConfig 性能配置
type PerformanceConfig struct {
        LogRetentionDays int             `mapstructure:"log_retention_days"`
        Cache            CacheConfig     `mapstructure:"cache"`
        RateLimit        RateLimitConfig `mapstructure:"rate_limit"`
}

// CacheConfig 缓存配置
type CacheConfig struct {
        RuleTTL   int `mapstructure:"rule_ttl"`
        ConfigTTL int `mapstructure:"config_ttl"`
}

// RateLimitConfig 限流配置
type RateLimitConfig struct {
        Enabled     bool `mapstructure:"enabled"`
        IPLimit     int  `mapstructure:"ip_limit"`
        GlobalLimit int  `mapstructure:"global_limit"`
}

// FeaturesConfig 功能开关
type FeaturesConfig struct {
        VersionControl bool `mapstructure:"version_control"`
        AuditLog       bool `mapstructure:"audit_log"`
        Metrics        bool `mapstructure:"metrics"`
}

var globalConfig *Config

// Load 加载配置文件
func Load(configPath string) (*Config, error) <span class="cov8" title="1">{
        v := viper.New()

        // 设置配置文件路径
        if configPath != "" </span><span class="cov8" title="1">{
                v.SetConfigFile(configPath)
        }</span> else<span class="cov8" title="1"> {
                v.SetConfigName("config")
                v.SetConfigType("yaml")
                v.AddConfigPath(".")
                v.AddConfigPath("./config")
        }</span>

        // 读取环境变量
        <span class="cov8" title="1">v.AutomaticEnv()

        // 读取配置文件
        if err := v.ReadInConfig(); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to read config file: %w", err)
        }</span>

        // 解析配置
        <span class="cov8" title="1">var cfg Config
        if err := v.Unmarshal(&amp;cfg); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal config: %w", err)
        }</span>

        <span class="cov8" title="1">globalConfig = &amp;cfg
        return &amp;cfg, nil</span>
}

// Get 获取全局配置
func Get() *Config <span class="cov8" title="1">{
        return globalConfig
}</span>

// GetAdminAddress 获取管理服务地址
func (c *Config) GetAdminAddress() string <span class="cov8" title="1">{
        return fmt.Sprintf("%s:%d", c.Server.Admin.Host, c.Server.Admin.Port)
}</span>

// GetMockAddress 获取 Mock 服务地址
func (c *Config) GetMockAddress() string <span class="cov8" title="1">{
        return fmt.Sprintf("%s:%d", c.Server.Mock.Host, c.Server.Mock.Port)
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">// Package engine provides the rule matching engine for the mock server.
package engine

import (
        "regexp"
        
        "github.com/gomockserver/mockserver/internal/monitoring"
)

// CommonRegexPatterns 定义常用的正则表达式模式
var CommonRegexPatterns = []string{
        // HTTP路径相关
        `^/api/.*$`,                    // API路径
        `^/api/v[0-9]+/.*$`,            // 带版本的API路径
        `^/users/[^/]+$`,               // 用户路径
        `^/users/[0-9]+$`,              // 数字用户ID路径
        `^/users/[^/]+/.*$`,            // 用户子路径
        `^/products/[^/]+$`,            // 产品路径
        `^/products/[0-9]+$`,           // 数字产品ID路径
        `^/orders/[^/]+$`,              // 订单路径
        `^/orders/[0-9]+$`,             // 数字订单ID路径
        
        // 查询参数相关
        `^[0-9]+$`,                     // 数字
        `^[a-zA-Z0-9_-]+$`,             // 字母数字下划线横线
        `^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$`, // UUID
        `^\d{4}-\d{2}-\d{2}$`,          // 日期 (YYYY-MM-DD)
        `^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}Z$`, // ISO 8601 日期时间
        
        // HTTP头相关
        `^[a-zA-Z0-9._-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$`, // 邮箱
        `^Bearer\s+[a-zA-Z0-9._-]+$`,   // Bearer Token
        `^Basic\s+[a-zA-Z0-9+/=]+$`,    // Basic Auth
        `^[A-Za-z0-9+/]*={0,2}$`,       // Base64
        
        // 通用模式
        `.*`,                           // 任意字符
        `^.*$`,                         // 任意字符（锚定）
        `[a-zA-Z0-9]+`,                 // 字母数字
        `[0-9]+`,                       // 数字
        `[a-zA-Z]+`,                    // 字母
}

// PrecompileCommonPatterns 预编译常用正则表达式模式
func (e *MatchEngine) PrecompileCommonPatterns() <span class="cov8" title="1">{
        for _, pattern := range CommonRegexPatterns </span><span class="cov8" title="1">{
                // 验证模式
                if err := validateRegexPattern(pattern); err != nil </span><span class="cov0" title="0">{
                        continue</span> // 跳过无效模式
                }
                
                // 编译并缓存
                <span class="cov8" title="1">if re, err := regexp.Compile(pattern); err == nil </span><span class="cov8" title="1">{
                        e.regexCache.Put(pattern, re)
                }</span>
        }
        
        // 更新缓存统计
        <span class="cov8" title="1">monitoring.SetRegexCacheSize(int64(e.regexCache.Size()))</span>
}</pre>
		
		<pre class="file" id="file4" style="display: none">// Package engine provides the rule matching engine for the mock server.
package engine

import (
        "container/list"
        "regexp"
        "sync"
)

// LRURegexCache LRU正则表达式缓存
type LRURegexCache struct {
        capacity int
        cache    map[string]*list.Element
        list     *list.List
        mu       sync.RWMutex
}

// regexCacheItem 缓存项
type regexCacheItem struct {
        pattern string
        regex   *regexp.Regexp
}

// NewLRURegexCache 创建LRU正则表达式缓存
func NewLRURegexCache(capacity int) *LRURegexCache <span class="cov8" title="1">{
        return &amp;LRURegexCache{
                capacity: capacity,
                cache:    make(map[string]*list.Element),
                list:     list.New(),
        }
}</span>

// Get 获取缓存的正则表达式
func (c *LRURegexCache) Get(pattern string) (*regexp.Regexp, bool) <span class="cov8" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()
        
        if element, exists := c.cache[pattern]; exists </span><span class="cov8" title="1">{
                // 移动到列表头部（最近使用）
                c.list.MoveToFront(element)
                return element.Value.(*regexCacheItem).regex, true
        }</span>
        
        <span class="cov8" title="1">return nil, false</span>
}

// Put 存储正则表达式到缓存
func (c *LRURegexCache) Put(pattern string, regex *regexp.Regexp) <span class="cov8" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()
        
        if element, exists := c.cache[pattern]; exists </span><span class="cov8" title="1">{
                // 更新现有项
                c.list.MoveToFront(element)
                element.Value.(*regexCacheItem).regex = regex
        }</span> else<span class="cov8" title="1"> {
                // 添加新项
                if c.list.Len() &gt;= c.capacity </span><span class="cov8" title="1">{
                        // 移除最久未使用的项
                        back := c.list.Back()
                        if back != nil </span><span class="cov8" title="1">{
                                c.list.Remove(back)
                                item := back.Value.(*regexCacheItem)
                                delete(c.cache, item.pattern)
                        }</span>
                }
                
                // 添加到列表头部
                <span class="cov8" title="1">item := &amp;regexCacheItem{pattern: pattern, regex: regex}
                element := c.list.PushFront(item)
                c.cache[pattern] = element</span>
        }
}

// Size 获取缓存大小
func (c *LRURegexCache) Size() int <span class="cov8" title="1">{
        c.mu.RLock()
        defer c.mu.RUnlock()
        return len(c.cache)
}</span>

// Clear 清空缓存
func (c *LRURegexCache) Clear() <span class="cov8" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()
        c.cache = make(map[string]*list.Element)
        c.list = list.New()
}</pre>
		
		<pre class="file" id="file5" style="display: none">package engine

import (
        "context"
        "encoding/json"
        "fmt"
        "net"
        "regexp"
        "strings"
        "sync"

        "github.com/gomockserver/mockserver/internal/adapter"
        "github.com/gomockserver/mockserver/internal/models"
        "github.com/gomockserver/mockserver/internal/repository"
        "github.com/gomockserver/mockserver/pkg/logger"
        "go.uber.org/zap"
)

// RegexCacheStats 缓存统计信息
type RegexCacheStats struct {
        Hits   int64
        Misses int64
        Size   int
}

// MatchEngine 规则匹配引擎
type MatchEngine struct {
        ruleRepo     repository.RuleRepository
        regexCache   *LRURegexCache
        cacheStats   RegexCacheStats
        statsMu      sync.RWMutex
}

// NewMatchEngine 创建匹配引擎
func NewMatchEngine(ruleRepo repository.RuleRepository) *MatchEngine <span class="cov8" title="1">{
        return &amp;MatchEngine{
                ruleRepo:   ruleRepo,
                regexCache: NewLRURegexCache(1000), // 默认缓存容量1000
        }
}</span>

// Match 匹配规则
func (e *MatchEngine) Match(ctx context.Context, request *adapter.Request, projectID, environmentID string) (*models.Rule, error) <span class="cov8" title="1">{
        // 加载环境下所有启用的规则
        rules, err := e.ruleRepo.FindEnabledByEnvironment(ctx, projectID, environmentID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to load rules", zap.Error(err))
                return nil, err
        }</span>

        // 按优先级已排序，逐条匹配
        <span class="cov8" title="1">for _, rule := range rules </span><span class="cov8" title="1">{
                // 检查协议类型
                if rule.Protocol != request.Protocol </span><span class="cov8" title="1">{
                        continue</span>
                }

                // 根据匹配类型执行匹配
                <span class="cov8" title="1">matched, err := e.matchRule(request, rule)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Warn("rule match error",
                                zap.String("rule_id", rule.ID),
                                zap.Error(err))
                        continue</span>
                }

                <span class="cov8" title="1">if matched </span><span class="cov8" title="1">{
                        logger.Info("rule matched",
                                zap.String("rule_id", rule.ID),
                                zap.String("rule_name", rule.Name))
                        return rule, nil
                }</span>
        }

        // 没有匹配的规则
        <span class="cov8" title="1">return nil, nil</span>
}

// matchRule 匹配单条规则
func (e *MatchEngine) matchRule(request *adapter.Request, rule *models.Rule) (bool, error) <span class="cov8" title="1">{
        switch rule.MatchType </span>{
        case models.MatchTypeSimple:<span class="cov8" title="1">
                return e.simpleMatch(request, rule)</span>
        case models.MatchTypeRegex:<span class="cov8" title="1">
                return e.regexMatch(request, rule)</span>
        case models.MatchTypeScript:<span class="cov8" title="1">
                return e.scriptMatch(request, rule)</span>
        default:<span class="cov8" title="1">
                return false, fmt.Errorf("unsupported match type: %s", rule.MatchType)</span>
        }
}

// simpleMatch 简单匹配
func (e *MatchEngine) simpleMatch(request *adapter.Request, rule *models.Rule) (bool, error) <span class="cov8" title="1">{
        if rule.Protocol != models.ProtocolHTTP </span><span class="cov8" title="1">{
                return false, nil
        }</span>

        // 解析 HTTP 匹配条件
        <span class="cov8" title="1">conditionBytes, err := json.Marshal(rule.MatchCondition)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov8" title="1">var condition models.HTTPMatchCondition
        if err := json.Unmarshal(conditionBytes, &amp;condition); err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        // 获取请求方法
        <span class="cov8" title="1">method, _ := request.Metadata["method"].(string)

        // 匹配 Method
        if condition.Method != nil </span><span class="cov8" title="1">{
                if !matchMethod(method, condition.Method) </span><span class="cov8" title="1">{
                        return false, nil
                }</span>
        }

        // 匹配 Path
        <span class="cov8" title="1">if condition.Path != "" </span><span class="cov8" title="1">{
                if !matchPath(request.Path, condition.Path) </span><span class="cov0" title="0">{
                        return false, nil
                }</span>
        }

        // 匹配 Query 参数
        <span class="cov8" title="1">if len(condition.Query) &gt; 0 </span><span class="cov8" title="1">{
                query, _ := request.Metadata["query"].(map[string]string)
                if !matchQuery(query, condition.Query) </span><span class="cov8" title="1">{
                        return false, nil
                }</span>
        }

        // 匹配 Headers
        <span class="cov8" title="1">if len(condition.Headers) &gt; 0 </span><span class="cov8" title="1">{
                if !matchHeaders(request.Headers, condition.Headers) </span><span class="cov8" title="1">{
                        return false, nil
                }</span>
        }

        // 匹配 IP 白名单
        <span class="cov8" title="1">if len(condition.IPWhitelist) &gt; 0 </span><span class="cov8" title="1">{
                if !matchIPWhitelist(request.SourceIP, condition.IPWhitelist) </span><span class="cov8" title="1">{
                        return false, nil
                }</span>
        }

        <span class="cov8" title="1">return true, nil</span>
}

// compileRegex 编译正则表达式并缓存
func (e *MatchEngine) compileRegex(pattern string) (*regexp.Regexp, error) <span class="cov8" title="1">{
        // 先尝试从缓存中获取
        if re, exists := e.regexCache.Get(pattern); exists </span><span class="cov8" title="1">{
                e.statsMu.Lock()
                e.cacheStats.Hits++
                e.statsMu.Unlock()
                return re, nil
        }</span>

        <span class="cov8" title="1">e.statsMu.Lock()
        e.cacheStats.Misses++
        e.statsMu.Unlock()

        // 编译正则表达式
        re, err := regexp.Compile(pattern)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 存入缓存
        <span class="cov8" title="1">e.regexCache.Put(pattern, re)

        return re, nil</span>
}

// GetCacheStats 获取缓存统计信息
func (e *MatchEngine) GetCacheStats() RegexCacheStats <span class="cov8" title="1">{
        e.statsMu.RLock()
        defer e.statsMu.RUnlock()
        stats := e.cacheStats
        stats.Size = e.regexCache.Size()
        return stats
}</span>

// regexMatch 正则表达式匹配
func (e *MatchEngine) regexMatch(request *adapter.Request, rule *models.Rule) (bool, error) <span class="cov8" title="1">{
        if rule.Protocol != models.ProtocolHTTP </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        // 解析 HTTP 匹配条件
        <span class="cov8" title="1">conditionBytes, err := json.Marshal(rule.MatchCondition)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov8" title="1">var condition models.HTTPMatchCondition
        if err := json.Unmarshal(conditionBytes, &amp;condition); err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        // 获取请求方法
        <span class="cov8" title="1">method, _ := request.Metadata["method"].(string)

        // 匹配 Method
        if condition.Method != nil </span><span class="cov0" title="0">{
                if !matchMethod(method, condition.Method) </span><span class="cov0" title="0">{
                        return false, nil
                }</span>
        }

        // 匹配 Path (支持正则表达式)
        <span class="cov8" title="1">if condition.Path != "" </span><span class="cov8" title="1">{
                // 编译正则表达式
                re, err := e.compileRegex(condition.Path)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Warn("failed to compile regex pattern for path",
                                zap.String("pattern", condition.Path),
                                zap.Error(err))
                        return false, nil
                }</span>

                // 执行正则匹配
                <span class="cov8" title="1">if !re.MatchString(request.Path) </span><span class="cov0" title="0">{
                        return false, nil
                }</span>
        }

        // 匹配 Query 参数 (支持正则表达式)
        <span class="cov8" title="1">if len(condition.Query) &gt; 0 </span><span class="cov0" title="0">{
                query, _ := request.Metadata["query"].(map[string]string)
                for key, pattern := range condition.Query </span><span class="cov0" title="0">{
                        value, exists := query[key]
                        if !exists </span><span class="cov0" title="0">{
                                return false, nil
                        }</span>

                        // 编译正则表达式
                        <span class="cov0" title="0">re, err := e.compileRegex(pattern)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Warn("failed to compile regex pattern for query",
                                        zap.String("key", key),
                                        zap.String("pattern", pattern),
                                        zap.Error(err))
                                return false, nil
                        }</span>

                        // 执行正则匹配
                        <span class="cov0" title="0">if !re.MatchString(value) </span><span class="cov0" title="0">{
                                return false, nil
                        }</span>
                }
        }

        // 匹配 Headers (支持正则表达式)
        <span class="cov8" title="1">if len(condition.Headers) &gt; 0 </span><span class="cov0" title="0">{
                for key, pattern := range condition.Headers </span><span class="cov0" title="0">{
                        // Header 名称不区分大小写查找
                        found := false
                        var value string
                        for reqKey, reqValue := range request.Headers </span><span class="cov0" title="0">{
                                if strings.EqualFold(reqKey, key) </span><span class="cov0" title="0">{
                                        value = reqValue
                                        found = true
                                        break</span>
                                }
                        }

                        <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                                return false, nil
                        }</span>

                        // 编译正则表达式
                        <span class="cov0" title="0">re, err := e.compileRegex(pattern)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Warn("failed to compile regex pattern for header",
                                        zap.String("key", key),
                                        zap.String("pattern", pattern),
                                        zap.Error(err))
                                return false, nil
                        }</span>

                        // 执行正则匹配
                        <span class="cov0" title="0">if !re.MatchString(value) </span><span class="cov0" title="0">{
                                return false, nil
                        }</span>
                }
        }

        // 匹配 IP 白名单
        <span class="cov8" title="1">if len(condition.IPWhitelist) &gt; 0 </span><span class="cov0" title="0">{
                if !matchIPWhitelist(request.SourceIP, condition.IPWhitelist) </span><span class="cov0" title="0">{
                        return false, nil
                }</span>
        }

        <span class="cov8" title="1">return true, nil</span>
}

// scriptMatch 脚本匹配（阶段一暂不实现）
func (e *MatchEngine) scriptMatch(request *adapter.Request, rule *models.Rule) (bool, error) <span class="cov8" title="1">{
        // TODO: 阶段三实现
        return false, fmt.Errorf("script match not implemented yet")
}</span>

// matchMethod 匹配请求方法
func matchMethod(requestMethod string, conditionMethod interface{}) bool <span class="cov8" title="1">{
        switch v := conditionMethod.(type) </span>{
        case string:<span class="cov8" title="1">
                return strings.EqualFold(requestMethod, v)</span>
        case []interface{}:<span class="cov8" title="1">
                for _, m := range v </span><span class="cov8" title="1">{
                        if method, ok := m.(string); ok </span><span class="cov8" title="1">{
                                if strings.EqualFold(requestMethod, method) </span><span class="cov8" title="1">{
                                        return true
                                }</span>
                        }
                }
                <span class="cov8" title="1">return false</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}

// matchPath 匹配路径（支持简单通配符）
func matchPath(requestPath, conditionPath string) bool <span class="cov8" title="1">{
        // 精确匹配
        if requestPath == conditionPath </span><span class="cov8" title="1">{
                return true
        }</span>

        // 支持简单的路径参数匹配，如 /api/users/:id
        <span class="cov8" title="1">conditionParts := strings.Split(conditionPath, "/")
        requestParts := strings.Split(requestPath, "/")

        if len(conditionParts) != len(requestParts) </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">for i, part := range conditionParts </span><span class="cov8" title="1">{
                if strings.HasPrefix(part, ":") </span><span class="cov8" title="1">{
                        // 路径参数，匹配任意值
                        continue</span>
                }
                <span class="cov8" title="1">if part != requestParts[i] </span><span class="cov8" title="1">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return true</span>
}

// matchQuery 匹配查询参数
func matchQuery(requestQuery, conditionQuery map[string]string) bool <span class="cov8" title="1">{
        for key, value := range conditionQuery </span><span class="cov8" title="1">{
                if requestQuery[key] != value </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

// matchHeaders 匹配请求头
func matchHeaders(requestHeaders, conditionHeaders map[string]string) bool <span class="cov8" title="1">{
        for key, value := range conditionHeaders </span><span class="cov8" title="1">{
                // Header 名称不区分大小写
                found := false
                for reqKey, reqValue := range requestHeaders </span><span class="cov8" title="1">{
                        if strings.EqualFold(reqKey, key) </span><span class="cov8" title="1">{
                                if reqValue != value </span><span class="cov8" title="1">{
                                        return false
                                }</span>
                                <span class="cov8" title="1">found = true
                                break</span>
                        }
                }
                <span class="cov8" title="1">if !found </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

// matchIPWhitelist 匹配 IP 白名单（支持精确IP和CIDR格式）
func matchIPWhitelist(requestIP string, whitelist []string) bool <span class="cov8" title="1">{
        // 解析请求IP
        requestIPAddr := net.ParseIP(requestIP)
        if requestIPAddr == nil </span><span class="cov8" title="1">{
                logger.Warn("invalid request IP address", zap.String("ip", requestIP))
                return false
        }</span>

        <span class="cov8" title="1">for _, ipEntry := range whitelist </span><span class="cov8" title="1">{
                // 尝试解析为CIDR格式
                if _, ipNet, err := net.ParseCIDR(ipEntry); err == nil </span><span class="cov8" title="1">{
                        // CIDR格式匹配
                        if ipNet.Contains(requestIPAddr) </span><span class="cov8" title="1">{
                                return true
                        }</span>
                        <span class="cov8" title="1">continue</span>
                }

                // 尝试解析为精确IP格式
                <span class="cov8" title="1">if ip := net.ParseIP(ipEntry); ip != nil </span><span class="cov8" title="1">{
                        // 精确IP匹配
                        if ip.Equal(requestIPAddr) </span><span class="cov8" title="1">{
                                return true
                        }</span>
                        <span class="cov8" title="1">continue</span>
                }

                // 无效的IP格式，记录警告但不中断其他白名单条目的处理
                <span class="cov8" title="1">logger.Warn("invalid IP format in whitelist", zap.String("ip", ipEntry))</span>
        }

        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">// Package engine provides the rule matching engine for the mock server.
package engine

import (
        "fmt"
        "regexp"
        "strings"
)

// RegexValidationError represents a regex validation error
type RegexValidationError struct {
        Pattern string
        Message string
}

func (e *RegexValidationError) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("regex validation error for pattern '%s': %s", e.Pattern, e.Message)
}</span>

// validateRegexPattern validates a regex pattern for complexity and security
func validateRegexPattern(pattern string) error <span class="cov8" title="1">{
        // Check pattern length
        if len(pattern) &gt; 1000 </span><span class="cov8" title="1">{
                return &amp;RegexValidationError{
                        Pattern: pattern,
                        Message: "pattern too long (max 1000 characters)",
                }
        }</span>

        // Check nesting depth
        <span class="cov8" title="1">nestingDepth := 0
        maxNesting := 0
        for _, char := range pattern </span><span class="cov8" title="1">{
                switch char </span>{
                case '(', '[', '{':<span class="cov8" title="1">
                        nestingDepth++
                        if nestingDepth &gt; maxNesting </span><span class="cov8" title="1">{
                                maxNesting = nestingDepth
                        }</span>
                case ')', ']', '}':<span class="cov8" title="1">
                        if nestingDepth &gt; 0 </span><span class="cov8" title="1">{
                                nestingDepth--
                        }</span>
                }
        }

        <span class="cov8" title="1">if maxNesting &gt; 10 </span><span class="cov8" title="1">{
                return &amp;RegexValidationError{
                        Pattern: pattern,
                        Message: fmt.Sprintf("nesting too deep (max 10 levels, got %d)", maxNesting),
                }
        }</span>

        // Check for potentially dangerous patterns
        <span class="cov8" title="1">dangerousPatterns := []string{
                ".*.*",     // Nested wildcards
                ".*+",      // Wildcard followed by +
                ".*{",      // Wildcard followed by repetition
                "a?a?a?a?", // Catastrophic backtracking pattern example
        }

        for _, dangerous := range dangerousPatterns </span><span class="cov8" title="1">{
                if strings.Contains(pattern, dangerous) </span><span class="cov8" title="1">{
                        return &amp;RegexValidationError{
                                Pattern: pattern,
                                Message: fmt.Sprintf("contains potentially dangerous pattern: %s", dangerous),
                        }
                }</span>
        }

        // Check for excessive repetition
        <span class="cov8" title="1">repetitionRegex := regexp.MustCompile(`\{(\d+),(\d+)\}`)
        matches := repetitionRegex.FindAllStringSubmatch(pattern, -1)
        for _, match := range matches </span><span class="cov8" title="1">{
                if len(match) == 3 </span><span class="cov8" title="1">{
                        min, max := 0, 0
                        fmt.Sscanf(match[1], "%d", &amp;min)
                        fmt.Sscanf(match[2], "%d", &amp;max)
                        if max-min &gt; 1000 </span><span class="cov8" title="1">{
                                return &amp;RegexValidationError{
                                        Pattern: pattern,
                                        Message: fmt.Sprintf("excessive repetition range: {%d,%d}", min, max),
                                }
                        }</span>
                }
        }

        // Check for excessive consecutive quantifiers
        <span class="cov8" title="1">consecutiveQuantifiers := 0
        maxConsecutive := 0
        for _, char := range pattern </span><span class="cov8" title="1">{
                if char == '*' || char == '+' || char == '?' || char == '{' </span><span class="cov8" title="1">{
                        consecutiveQuantifiers++
                        if consecutiveQuantifiers &gt; maxConsecutive </span><span class="cov8" title="1">{
                                maxConsecutive = consecutiveQuantifiers
                        }</span>
                } else<span class="cov8" title="1"> {
                        consecutiveQuantifiers = 0
                }</span>
        }

        <span class="cov8" title="1">if maxConsecutive &gt; 5 </span><span class="cov8" title="1">{
                return &amp;RegexValidationError{
                        Pattern: pattern,
                        Message: fmt.Sprintf("too many consecutive quantifiers (max 5, got %d)", maxConsecutive),
                }
        }</span>

        <span class="cov8" title="1">return nil</span>
}</pre>
		
		<pre class="file" id="file7" style="display: none">package engine

import (
        "context"
        "errors"
        "fmt"
        "time"

        "github.com/dop251/goja"
        "github.com/gomockserver/mockserver/internal/adapter"
        "github.com/gomockserver/mockserver/internal/models"
        "github.com/gomockserver/mockserver/pkg/logger"
        "go.uber.org/zap"
)

// ScriptEngine 脚本匹配引擎
type ScriptEngine struct {
        // 资源限制
        maxExecutionTime time.Duration
        maxMemory        int64
        // 审计日志
        auditLog bool
}

// ScriptMatchConfig 脚本匹配配置
type ScriptMatchConfig struct {
        Script string `json:"script"` // JavaScript 脚本代码
}

// ScriptContext 脚本执行上下文
type ScriptContext struct {
        Request *adapter.Request
        Rule    *models.Rule
        Env     map[string]interface{}
}

// NewScriptEngine 创建脚本引擎
func NewScriptEngine() *ScriptEngine <span class="cov8" title="1">{
        return &amp;ScriptEngine{
                maxExecutionTime: 5 * time.Second, // 默认最大执行时间 5 秒
                maxMemory:        10 * 1024 * 1024, // 默认最大内存 10MB
                auditLog:         true,
        }
}</span>

// Match 执行脚本匹配
func (e *ScriptEngine) Match(request *adapter.Request, rule *models.Rule) (bool, error) <span class="cov8" title="1">{
        // 检查规则类型
        if rule.MatchType != models.MatchTypeScript </span><span class="cov8" title="1">{
                return false, errors.New("not a script match rule")
        }</span>

        // 提取脚本配置
        <span class="cov8" title="1">script, ok := rule.MatchCondition["script"].(string)
        if !ok || script == "" </span><span class="cov8" title="1">{
                return false, errors.New("script not found in match condition")
        }</span>

        // 创建脚本上下文
        <span class="cov8" title="1">ctx := &amp;ScriptContext{
                Request: request,
                Rule:    rule,
                Env:     make(map[string]interface{}),
        }

        // 执行脚本
        startTime := time.Now()
        result, err := e.executeScript(script, ctx)
        duration := time.Since(startTime)

        // 审计日志
        if e.auditLog </span><span class="cov8" title="1">{
                logger.Info("script execution",
                        zap.String("rule_id", rule.ID),
                        zap.String("rule_name", rule.Name),
                        zap.Duration("duration", duration),
                        zap.Bool("result", result),
                        zap.Error(err),
                )
        }</span>

        <span class="cov8" title="1">return result, err</span>
}

// executeScript 执行 JavaScript 脚本
func (e *ScriptEngine) executeScript(script string, ctx *ScriptContext) (bool, error) <span class="cov8" title="1">{
        // 创建超时上下文
        execCtx, cancel := context.WithTimeout(context.Background(), e.maxExecutionTime)
        defer cancel()

        // 创建 goja 运行时
        vm := goja.New()
        
        // 设置中断处理
        done := make(chan struct{})
        defer close(done)
        
        go func() </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-execCtx.Done():<span class="cov8" title="1">
                        vm.Interrupt("execution timeout")</span>
                case &lt;-done:<span class="cov8" title="1"></span>
                }
        }()

        // 注入安全 API
        <span class="cov8" title="1">e.injectSecureAPI(vm, ctx)

        // 执行脚本
        result, err := vm.RunString(script)
        if err != nil </span><span class="cov8" title="1">{
                logger.Error("script execution error", 
                        zap.String("script", script),
                        zap.Error(err),
                )
                return false, fmt.Errorf("script execution failed: %w", err)
        }</span>

        // 转换结果为布尔值
        <span class="cov8" title="1">matched, ok := result.Export().(bool)
        if !ok </span><span class="cov8" title="1">{
                return false, errors.New("script must return a boolean value")
        }</span>

        <span class="cov8" title="1">return matched, nil</span>
}

// injectSecureAPI 注入安全的 API 到脚本环境
func (e *ScriptEngine) injectSecureAPI(vm *goja.Runtime, ctx *ScriptContext) <span class="cov8" title="1">{
        // 注入 request 对象
        vm.Set("request", map[string]interface{}{
                "id":       ctx.Request.ID,
                "protocol": string(ctx.Request.Protocol),
                "path":     ctx.Request.Path,
                "headers":  ctx.Request.Headers,
                "body":     string(ctx.Request.Body),
                "sourceIP": ctx.Request.SourceIP,
                "metadata": ctx.Request.Metadata,
        })

        // 注入 rule 对象（只读）
        vm.Set("rule", map[string]interface{}{
                "id":          ctx.Rule.ID,
                "name":        ctx.Rule.Name,
                "project_id":  ctx.Rule.ProjectID,
                "environment": ctx.Rule.EnvironmentID,
                "priority":    ctx.Rule.Priority,
        })

        // 注入工具函数
        vm.Set("log", func(msg string) </span><span class="cov0" title="0">{
                logger.Info("script log", zap.String("message", msg))
        }</span>)

        <span class="cov8" title="1">vm.Set("match", func(pattern string, text string) bool </span><span class="cov0" title="0">{
                // 简单的字符串匹配
                return contains(text, pattern)
        }</span>)

        <span class="cov8" title="1">vm.Set("hasHeader", func(key string) bool </span><span class="cov8" title="1">{
                _, exists := ctx.Request.Headers[key]
                return exists
        }</span>)

        <span class="cov8" title="1">vm.Set("getHeader", func(key string) string </span><span class="cov8" title="1">{
                return ctx.Request.Headers[key]
        }</span>)

        <span class="cov8" title="1">vm.Set("hasQuery", func(key string) bool </span><span class="cov8" title="1">{
                if query, ok := ctx.Request.Metadata["query"].(map[string]string); ok </span><span class="cov8" title="1">{
                        _, exists := query[key]
                        return exists
                }</span>
                <span class="cov0" title="0">return false</span>
        })

        <span class="cov8" title="1">vm.Set("getQuery", func(key string) string </span><span class="cov8" title="1">{
                if query, ok := ctx.Request.Metadata["query"].(map[string]string); ok </span><span class="cov8" title="1">{
                        return query[key]
                }</span>
                <span class="cov0" title="0">return ""</span>
        })

        // 禁用危险功能
        <span class="cov8" title="1">vm.Set("require", goja.Undefined())
        vm.Set("import", goja.Undefined())
        vm.Set("eval", goja.Undefined())
        vm.Set("Function", goja.Undefined())</span>
}

// contains 检查字符串是否包含子串
func contains(s, substr string) bool <span class="cov0" title="0">{
        return len(s) &gt;= len(substr) &amp;&amp; (s == substr || len(substr) == 0 || 
                (len(s) &gt; 0 &amp;&amp; len(substr) &gt; 0 &amp;&amp; findSubstring(s, substr)))
}</span>

func findSubstring(s, substr string) bool <span class="cov0" title="0">{
        for i := 0; i &lt;= len(s)-len(substr); i++ </span><span class="cov0" title="0">{
                if s[i:i+len(substr)] == substr </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package executor

import (
        "encoding/base64"
        "encoding/json"
        "fmt"
        "io"
        "math"
        "math/rand"
        "os"
        "sync"
        "time"

        "github.com/gomockserver/mockserver/internal/adapter"
        "github.com/gomockserver/mockserver/internal/models"
        "github.com/gomockserver/mockserver/pkg/logger"
        "go.uber.org/zap"
)

// MockExecutor Mock 执行器
type MockExecutor struct {
        normalRandMu sync.Mutex
        normalRandS  float64
        normalRandV  float64
        normalRandOK bool

        // 阶梯延迟相关字段
        stepCounters   map[string]int64
        stepCountersMu sync.RWMutex

        // 模板引擎
        templateEngine *TemplateEngine

        // 代理执行器
        proxyExecutor *ProxyExecutor
}

// NewMockExecutor 创建 Mock 执行器
func NewMockExecutor() *MockExecutor <span class="cov8" title="1">{
        return &amp;MockExecutor{
                stepCounters:   make(map[string]int64),
                templateEngine: NewTemplateEngine(),
                proxyExecutor:  NewProxyExecutor(),
        }
}</span>

// Execute 执行 Mock 响应生成
func (e *MockExecutor) Execute(request *adapter.Request, rule *models.Rule) (*adapter.Response, error) <span class="cov8" title="1">{
        // 应用延迟
        if rule.Response.Delay != nil </span><span class="cov8" title="1">{
                delay := e.calculateDelay(rule.Response.Delay)
                if delay &gt; 0 </span><span class="cov8" title="1">{
                        time.Sleep(time.Duration(delay) * time.Millisecond)
                }</span>
        }

        // 根据响应类型生成响应
        <span class="cov8" title="1">switch rule.Response.Type </span>{
        case models.ResponseTypeStatic:<span class="cov8" title="1">
                return e.staticResponse(request, rule)</span>
        case models.ResponseTypeDynamic:<span class="cov0" title="0">
                return e.dynamicResponse(request, rule, nil)</span>
        case models.ResponseTypeScript:<span class="cov8" title="1">
                // TODO: v0.4.0 实现
                return nil, fmt.Errorf("script response not implemented yet")</span>
        case models.ResponseTypeProxy:<span class="cov0" title="0">
                return e.proxyResponse(request, rule)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported response type: %s", rule.Response.Type)</span>
        }
}

// staticResponse 生成静态响应
func (e *MockExecutor) staticResponse(request *adapter.Request, rule *models.Rule) (*adapter.Response, error) <span class="cov8" title="1">{
        if rule.Protocol != models.ProtocolHTTP </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("only HTTP protocol is supported in static response")
        }</span>

        // 解析 HTTP 响应配置
        <span class="cov8" title="1">contentBytes, err := json.Marshal(rule.Response.Content)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to marshal response content", zap.Error(err))
                return nil, err
        }</span>

        <span class="cov8" title="1">var httpResp models.HTTPResponse
        if err := json.Unmarshal(contentBytes, &amp;httpResp); err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to unmarshal http response", zap.Error(err))
                return nil, err
        }</span>

        // 构建响应体
        <span class="cov8" title="1">var body []byte

        // 检查是否使用文件路径引用
        if bodyMap, ok := httpResp.Body.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                if filePath, ok := bodyMap["file_path"].(string); ok </span><span class="cov0" title="0">{
                        // 从文件读取
                        body, err = e.readFileResponse(filePath)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Error("failed to read file", zap.String("file_path", filePath), zap.Error(err))
                                return nil, fmt.Errorf("failed to read file %s: %w", filePath, err)
                        }</span>
                } else<span class="cov8" title="1"> {
                        // 使用map内容
                        body, err = json.Marshal(httpResp.Body)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                }
        } else<span class="cov8" title="1"> {
                // 使用内嵌内容
                switch httpResp.ContentType </span>{
                case models.ContentTypeJSON:<span class="cov0" title="0">
                        body, err = json.Marshal(httpResp.Body)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                case models.ContentTypeText, models.ContentTypeHTML, models.ContentTypeXML:<span class="cov8" title="1">
                        if str, ok := httpResp.Body.(string); ok </span><span class="cov8" title="1">{
                                body = []byte(str)
                        }</span> else<span class="cov0" title="0"> {
                                body, err = json.Marshal(httpResp.Body)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                        }
                case models.ContentTypeBinary:<span class="cov8" title="1">
                        // 处理二进制数据 - 支持Base64编码
                        if str, ok := httpResp.Body.(string); ok </span><span class="cov8" title="1">{
                                // 尝试Base64解码
                                decoded, err := base64.StdEncoding.DecodeString(str)
                                if err != nil </span><span class="cov8" title="1">{
                                        // 如果解码失败，记录警告并返回原始数据
                                        logger.Warn("failed to decode base64 binary data, returning raw data", zap.Error(err))
                                        body = []byte(str)
                                }</span> else<span class="cov8" title="1"> {
                                        body = decoded
                                }</span>
                        } else<span class="cov0" title="0"> {
                                // 非字符串类型，尝试JSON序列化
                                body, err = json.Marshal(httpResp.Body)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("failed to marshal binary body: %w", err)
                                }</span>
                        }
                default:<span class="cov8" title="1">
                        body, err = json.Marshal(httpResp.Body)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                }
        }

        // 设置默认 Content-Type
        <span class="cov8" title="1">if httpResp.Headers == nil </span><span class="cov8" title="1">{
                httpResp.Headers = make(map[string]string)
        }</span>
        <span class="cov8" title="1">if _, ok := httpResp.Headers["Content-Type"]; !ok </span><span class="cov8" title="1">{
                httpResp.Headers["Content-Type"] = e.getDefaultContentType(httpResp.ContentType)
        }</span>

        // 构建统一响应模型
        <span class="cov8" title="1">response := &amp;adapter.Response{
                StatusCode: httpResp.StatusCode,
                Headers:    httpResp.Headers,
                Body:       body,
                Metadata:   make(map[string]interface{}),
        }

        return response, nil</span>
}

// dynamicResponse 生成动态响应
func (e *MockExecutor) dynamicResponse(request *adapter.Request, rule *models.Rule, env *models.Environment) (*adapter.Response, error) <span class="cov8" title="1">{
        if rule.Protocol != models.ProtocolHTTP </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("only HTTP protocol is supported in dynamic response")
        }</span>

        // 解析 HTTP 响应配置
        <span class="cov8" title="1">contentBytes, err := json.Marshal(rule.Response.Content)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to marshal response content", zap.Error(err))
                return nil, err
        }</span>

        <span class="cov8" title="1">var httpResp models.HTTPResponse
        if err := json.Unmarshal(contentBytes, &amp;httpResp); err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to unmarshal http response", zap.Error(err))
                return nil, err
        }</span>

        // 构建模板上下文
        <span class="cov8" title="1">ctx := e.templateEngine.BuildContext(request, rule, env)

        // 渲染响应体
        var body []byte
        switch httpResp.ContentType </span>{
        case models.ContentTypeJSON:<span class="cov8" title="1">
                // JSON模板渲染
                rendered, err := e.templateEngine.RenderJSON(httpResp.Body, ctx)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to render json template", zap.Error(err))
                        return nil, fmt.Errorf("failed to render json template: %w", err)
                }</span>
                <span class="cov8" title="1">body, err = json.Marshal(rendered)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        case models.ContentTypeText, models.ContentTypeHTML, models.ContentTypeXML:<span class="cov8" title="1">
                // 文本模板渲染
                var templateStr string
                if str, ok := httpResp.Body.(string); ok </span><span class="cov8" title="1">{
                        templateStr = str
                }</span> else<span class="cov0" title="0"> {
                        // 如果不是字符串，先转为JSON
                        tempBytes, err := json.Marshal(httpResp.Body)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">templateStr = string(tempBytes)</span>
                }

                <span class="cov8" title="1">rendered, err := e.templateEngine.Render(templateStr, ctx)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to render text template", zap.Error(err))
                        return nil, fmt.Errorf("failed to render text template: %w", err)
                }</span>
                <span class="cov8" title="1">body = []byte(rendered)</span>
        default:<span class="cov0" title="0">
                // 默认JSON处理
                rendered, err := e.templateEngine.RenderJSON(httpResp.Body, ctx)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to render template", zap.Error(err))
                        return nil, fmt.Errorf("failed to render template: %w", err)
                }</span>
                <span class="cov0" title="0">body, err = json.Marshal(rendered)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        // 设置默认 Content-Type
        <span class="cov8" title="1">if httpResp.Headers == nil </span><span class="cov8" title="1">{
                httpResp.Headers = make(map[string]string)
        }</span>
        <span class="cov8" title="1">if _, ok := httpResp.Headers["Content-Type"]; !ok </span><span class="cov8" title="1">{
                httpResp.Headers["Content-Type"] = e.getDefaultContentType(httpResp.ContentType)
        }</span>

        // 构建统一响应模型
        <span class="cov8" title="1">response := &amp;adapter.Response{
                StatusCode: httpResp.StatusCode,
                Headers:    httpResp.Headers,
                Body:       body,
                Metadata:   make(map[string]interface{}),
        }

        return response, nil</span>
}

// proxyResponse 生成代理响应
func (e *MockExecutor) proxyResponse(request *adapter.Request, rule *models.Rule) (*adapter.Response, error) <span class="cov8" title="1">{
        // 解析代理配置
        contentBytes, err := json.Marshal(rule.Response.Content)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to marshal proxy config", zap.Error(err))
                return nil, err
        }</span>

        <span class="cov8" title="1">var proxyConfig ProxyConfig
        if err := json.Unmarshal(contentBytes, &amp;proxyConfig); err != nil </span><span class="cov8" title="1">{
                logger.Error("failed to unmarshal proxy config", zap.Error(err))
                return nil, err
        }</span>

        // 执行代理请求
        <span class="cov8" title="1">return e.proxyExecutor.Execute(request, &amp;proxyConfig)</span>
}

// calculateDelay 计算延迟时间（毫秒）
func (e *MockExecutor) calculateDelay(config *models.DelayConfig) int <span class="cov8" title="1">{
        if config == nil </span><span class="cov8" title="1">{
                return 0
        }</span>

        <span class="cov8" title="1">switch config.Type </span>{
        case "fixed":<span class="cov8" title="1">
                return config.Fixed</span>
        case "random":<span class="cov8" title="1">
                if config.Max &lt;= config.Min </span><span class="cov8" title="1">{
                        return config.Min
                }</span>
                <span class="cov8" title="1">return config.Min + rand.Intn(config.Max-config.Min)</span>
        case "normal":<span class="cov8" title="1">
                // 实现正态分布延迟 - 使用Marsaglia polar method
                if config.StdDev &lt;= 0 </span><span class="cov8" title="1">{
                        // 标准差必须为正数
                        return config.Mean
                }</span>

                // 生成正态分布随机数
                <span class="cov8" title="1">normalRand := e.generateNormalRand(float64(config.Mean), float64(config.StdDev))

                // 确保结果为非负整数
                result := int(math.Round(normalRand))
                if result &lt; 0 </span><span class="cov0" title="0">{
                        result = 0
                }</span>

                <span class="cov8" title="1">return result</span>
        case "step":<span class="cov0" title="0">
                // 实现阶梯延迟 - 基于请求计数的阶梯延迟算法
                return e.calculateStepDelay(config, "")</span>
        default:<span class="cov8" title="1">
                return 0</span>
        }
}

// calculateStepDelay 计算阶梯延迟
func (e *MockExecutor) calculateStepDelay(config *models.DelayConfig, ruleID string) int <span class="cov8" title="1">{
        // 使用规则ID作为计数器键，实现计数器隔离
        counterKey := "default"
        if ruleID != "" </span><span class="cov8" title="1">{
                counterKey = ruleID
        }</span>

        // 增加计数器
        <span class="cov8" title="1">e.stepCountersMu.Lock()
        e.stepCounters[counterKey]++
        count := e.stepCounters[counterKey]
        e.stepCountersMu.Unlock()

        // 计算阶梯延迟
        baseDelay := config.Fixed
        step := config.Step
        limit := config.Limit

        if step &lt;= 0 </span><span class="cov8" title="1">{
                // 步长必须为正数
                return baseDelay
        }</span>

        // 计算阶梯值: baseDelay + (count-1) * step
        <span class="cov8" title="1">delay := baseDelay + int(count-1)*step

        // 如果设置了上限，则不超过上限
        if limit &gt; 0 &amp;&amp; delay &gt; limit </span><span class="cov8" title="1">{
                delay = limit
        }</span>

        <span class="cov8" title="1">return delay</span>
}

// ResetStepCounter 重置阶梯延迟计数器
func (e *MockExecutor) ResetStepCounter(ruleID string) <span class="cov8" title="1">{
        e.stepCountersMu.Lock()
        defer e.stepCountersMu.Unlock()

        if ruleID == "" </span><span class="cov8" title="1">{
                // 重置所有计数器
                e.stepCounters = make(map[string]int64)
        }</span> else<span class="cov8" title="1"> {
                // 重置特定规则的计数器
                delete(e.stepCounters, ruleID)
        }</span>

        <span class="cov8" title="1">logger.Info("reset step delay counter", zap.String("rule_id", ruleID))</span>
}

// GetStepCounter 获取阶梯延迟计数器值
func (e *MockExecutor) GetStepCounter(ruleID string) int64 <span class="cov8" title="1">{
        e.stepCountersMu.RLock()
        defer e.stepCountersMu.RUnlock()

        counterKey := "default"
        if ruleID != "" </span><span class="cov8" title="1">{
                counterKey = ruleID
        }</span>

        <span class="cov8" title="1">return e.stepCounters[counterKey]</span>
}

// generateNormalRand 使用Marsaglia polar method生成正态分布随机数
func (e *MockExecutor) generateNormalRand(mean, stdDev float64) float64 <span class="cov8" title="1">{
        e.normalRandMu.Lock()
        defer e.normalRandMu.Unlock()

        // 如果有缓存的随机数，直接使用
        if e.normalRandOK </span><span class="cov8" title="1">{
                e.normalRandOK = false
                return mean + stdDev*e.normalRandV
        }</span>

        // 生成新的正态分布随机数对
        <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                // 生成[-1, 1]范围内的均匀分布随机数
                u := 2.0*rand.Float64() - 1.0
                v := 2.0*rand.Float64() - 1.0

                // 计算s = u^2 + v^2
                s := u*u + v*v

                // 如果s在(0, 1)范围内，则接受
                if s &gt; 0.0 &amp;&amp; s &lt; 1.0 </span><span class="cov8" title="1">{
                        // 计算乘数
                        multiplier := math.Sqrt(-2.0 * math.Log(s) / s)

                        // 缓存其中一个值供下次使用
                        e.normalRandS = s
                        e.normalRandV = v * multiplier
                        e.normalRandOK = true

                        // 返回另一个值
                        return mean + stdDev*u*multiplier
                }</span>
        }
}

// getDefaultContentType 获取默认 Content-Type
func (e *MockExecutor) getDefaultContentType(contentType models.ContentType) string <span class="cov8" title="1">{
        switch contentType </span>{
        case models.ContentTypeJSON:<span class="cov8" title="1">
                return "application/json"</span>
        case models.ContentTypeXML:<span class="cov8" title="1">
                return "application/xml"</span>
        case models.ContentTypeHTML:<span class="cov8" title="1">
                return "text/html"</span>
        case models.ContentTypeText:<span class="cov8" title="1">
                return "text/plain"</span>
        case models.ContentTypeBinary:<span class="cov8" title="1">
                return "application/octet-stream"</span>
        default:<span class="cov8" title="1">
                return "application/json"</span>
        }
}

// GetDefaultResponse 获取默认 404 响应
func (e *MockExecutor) GetDefaultResponse() *adapter.Response <span class="cov8" title="1">{
        return &amp;adapter.Response{
                StatusCode: 404,
                Headers: map[string]string{
                        "Content-Type": "application/json",
                },
                Body: []byte(`{"error": "No matching rule found"}`),
        }
}</span>

// readFileResponse 从文件读取响应内容
func (e *MockExecutor) readFileResponse(filePath string) ([]byte, error) <span class="cov8" title="1">{
        // 打开文件
        file, err := os.Open(filePath)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to open file: %w", err)
        }</span>
        <span class="cov8" title="1">defer file.Close()

        // 读取文件内容
        data, err := io.ReadAll(file)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read file: %w", err)
        }</span>

        <span class="cov8" title="1">logger.Info("read file response",
                zap.String("file_path", filePath),
                zap.Int("size", len(data)))

        return data, nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package executor

import (
        "bytes"
        "encoding/json"
        "fmt"
        "io"
        "math/rand"
        "net/http"
        "time"

        "github.com/gomockserver/mockserver/internal/adapter"
        "github.com/gomockserver/mockserver/pkg/logger"
        "go.uber.org/zap"
)

// ProxyConfig 代理配置
type ProxyConfig struct {
        TargetURL       string                 `json:"target_url"`
        Timeout         int                    `json:"timeout"`          // 超时时间（秒）
        ModifyRequest   *RequestModifier       `json:"modify_request"`   // 请求修改器
        ModifyResponse  *ResponseModifier      `json:"modify_response"`  // 响应修改器
        InjectDelay     int                    `json:"inject_delay"`     // 注入延迟（毫秒）
        ErrorRate       float64                `json:"error_rate"`       // 错误率（0-1）
        ErrorStatusCode int                    `json:"error_status_code"` // 错误状态码
        FollowRedirect  bool                   `json:"follow_redirect"`  // 是否跟随重定向
}

// RequestModifier 请求修改器
type RequestModifier struct {
        Headers map[string]string      `json:"headers"`  // 添加/修改的请求头
        Query   map[string]string      `json:"query"`    // 添加/修改的查询参数
        Body    map[string]interface{} `json:"body"`     // 修改请求体（仅JSON）
        RemoveHeaders []string           `json:"remove_headers"` // 移除的请求头
}

// ResponseModifier 响应修改器
type ResponseModifier struct {
        Headers      map[string]string      `json:"headers"`       // 添加/修改的响应头
        BodyReplace  map[string]interface{} `json:"body_replace"`  // 替换响应体字段
        StatusCode   int                    `json:"status_code"`   // 修改状态码
        RemoveHeaders []string              `json:"remove_headers"` // 移除的响应头
}

// ProxyExecutor 代理执行器
type ProxyExecutor struct {
        client *http.Client
}

// NewProxyExecutor 创建代理执行器
func NewProxyExecutor() *ProxyExecutor <span class="cov8" title="1">{
        return &amp;ProxyExecutor{
                client: &amp;http.Client{
                        Timeout: 30 * time.Second,
                },
        }
}</span>

// Execute 执行代理请求
func (p *ProxyExecutor) Execute(request *adapter.Request, config *ProxyConfig) (*adapter.Response, error) <span class="cov8" title="1">{
        // 检查是否应该模拟错误
        if config.ErrorRate &gt; 0 </span><span class="cov8" title="1">{
                if shouldInjectError(config.ErrorRate) </span><span class="cov8" title="1">{
                        statusCode := config.ErrorStatusCode
                        if statusCode == 0 </span><span class="cov8" title="1">{
                                statusCode = 500 // 默认500错误
                        }</span>
                        <span class="cov8" title="1">logger.Info("injecting error response",
                                zap.Float64("error_rate", config.ErrorRate),
                                zap.Int("status_code", statusCode))
                        
                        return &amp;adapter.Response{
                                StatusCode: statusCode,
                                Headers: map[string]string{
                                        "Content-Type": "application/json",
                                },
                                Body: []byte(fmt.Sprintf(`{"error": "injected error", "status_code": %d}`, statusCode)),
                        }, nil</span>
                }
        }

        // 注入延迟
        <span class="cov8" title="1">if config.InjectDelay &gt; 0 </span><span class="cov8" title="1">{
                time.Sleep(time.Duration(config.InjectDelay) * time.Millisecond)
        }</span>

        // 构建目标URL
        <span class="cov8" title="1">targetURL := config.TargetURL
        if request.Path != "" </span><span class="cov8" title="1">{
                targetURL = targetURL + request.Path
        }</span>

        // 提取HTTP方法
        <span class="cov8" title="1">method := "GET"
        if request.Metadata != nil </span><span class="cov8" title="1">{
                if m, ok := request.Metadata["method"].(string); ok </span><span class="cov8" title="1">{
                        method = m
                }</span>
        }

        // 创建HTTP请求
        <span class="cov8" title="1">var reqBody io.Reader
        if len(request.Body) &gt; 0 </span><span class="cov8" title="1">{
                // 如果需要修改请求体
                if config.ModifyRequest != nil &amp;&amp; config.ModifyRequest.Body != nil </span><span class="cov8" title="1">{
                        modifiedBody, err := p.modifyRequestBody(request.Body, config.ModifyRequest.Body)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Error("failed to modify request body", zap.Error(err))
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">reqBody = bytes.NewReader(modifiedBody)</span>
                } else<span class="cov8" title="1"> {
                        reqBody = bytes.NewReader(request.Body)
                }</span>
        }

        <span class="cov8" title="1">httpReq, err := http.NewRequest(method, targetURL, reqBody)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to create proxy request", zap.Error(err))
                return nil, err
        }</span>

        // 复制原始请求头
        <span class="cov8" title="1">for key, value := range request.Headers </span><span class="cov8" title="1">{
                httpReq.Header.Set(key, value)
        }</span>

        // 应用请求修改器
        <span class="cov8" title="1">if config.ModifyRequest != nil </span><span class="cov8" title="1">{
                p.applyRequestModifier(httpReq, config.ModifyRequest)
        }</span>

        // 设置超时
        <span class="cov8" title="1">if config.Timeout &gt; 0 </span><span class="cov8" title="1">{
                p.client.Timeout = time.Duration(config.Timeout) * time.Second
        }</span>

        // 设置是否跟随重定向
        <span class="cov8" title="1">if !config.FollowRedirect </span><span class="cov8" title="1">{
                p.client.CheckRedirect = func(req *http.Request, via []*http.Request) error </span><span class="cov8" title="1">{
                        return http.ErrUseLastResponse
                }</span>
        }

        // 执行请求
        <span class="cov8" title="1">logger.Info("proxying request",
                zap.String("method", method),
                zap.String("target_url", targetURL))
        
        resp, err := p.client.Do(httpReq)
        if err != nil </span><span class="cov8" title="1">{
                logger.Error("failed to proxy request", zap.Error(err))
                return nil, err
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        // 读取响应体
        respBody, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to read proxy response", zap.Error(err))
                return nil, err
        }</span>

        // 构建响应
        <span class="cov8" title="1">response := &amp;adapter.Response{
                StatusCode: resp.StatusCode,
                Headers:    make(map[string]string),
                Body:       respBody,
                Metadata:   make(map[string]interface{}),
        }

        // 复制响应头
        for key, values := range resp.Header </span><span class="cov8" title="1">{
                if len(values) &gt; 0 </span><span class="cov8" title="1">{
                        response.Headers[key] = values[0]
                }</span>
        }

        // 应用响应修改器
        <span class="cov8" title="1">if config.ModifyResponse != nil </span><span class="cov8" title="1">{
                err = p.applyResponseModifier(response, config.ModifyResponse)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to apply response modifier", zap.Error(err))
                        return nil, err
                }</span>
        }

        <span class="cov8" title="1">return response, nil</span>
}

// modifyRequestBody 修改请求体
func (p *ProxyExecutor) modifyRequestBody(originalBody []byte, modifications map[string]interface{}) ([]byte, error) <span class="cov8" title="1">{
        // 解析原始body
        var bodyMap map[string]interface{}
        if err := json.Unmarshal(originalBody, &amp;bodyMap); err != nil </span><span class="cov8" title="1">{
                // 如果不是JSON，返回原始body
                return originalBody, nil
        }</span>

        // 应用修改
        <span class="cov8" title="1">for key, value := range modifications </span><span class="cov8" title="1">{
                bodyMap[key] = value
        }</span>

        // 重新序列化
        <span class="cov8" title="1">return json.Marshal(bodyMap)</span>
}

// applyRequestModifier 应用请求修改器
func (p *ProxyExecutor) applyRequestModifier(req *http.Request, modifier *RequestModifier) <span class="cov8" title="1">{
        // 添加/修改请求头
        if modifier.Headers != nil </span><span class="cov8" title="1">{
                for key, value := range modifier.Headers </span><span class="cov8" title="1">{
                        req.Header.Set(key, value)
                }</span>
        }

        // 移除请求头
        <span class="cov8" title="1">if modifier.RemoveHeaders != nil </span><span class="cov8" title="1">{
                for _, key := range modifier.RemoveHeaders </span><span class="cov8" title="1">{
                        req.Header.Del(key)
                }</span>
        }

        // 修改查询参数
        <span class="cov8" title="1">if modifier.Query != nil </span><span class="cov8" title="1">{
                q := req.URL.Query()
                for key, value := range modifier.Query </span><span class="cov8" title="1">{
                        q.Set(key, value)
                }</span>
                <span class="cov8" title="1">req.URL.RawQuery = q.Encode()</span>
        }
}

// applyResponseModifier 应用响应修改器
func (p *ProxyExecutor) applyResponseModifier(resp *adapter.Response, modifier *ResponseModifier) error <span class="cov8" title="1">{
        // 修改状态码
        if modifier.StatusCode &gt; 0 </span><span class="cov8" title="1">{
                resp.StatusCode = modifier.StatusCode
        }</span>

        // 添加/修改响应头
        <span class="cov8" title="1">if modifier.Headers != nil </span><span class="cov8" title="1">{
                for key, value := range modifier.Headers </span><span class="cov8" title="1">{
                        resp.Headers[key] = value
                }</span>
        }

        // 移除响应头
        <span class="cov8" title="1">if modifier.RemoveHeaders != nil </span><span class="cov8" title="1">{
                for _, key := range modifier.RemoveHeaders </span><span class="cov8" title="1">{
                        delete(resp.Headers, key)
                }</span>
        }

        // 替换响应体字段（仅JSON）
        <span class="cov8" title="1">if modifier.BodyReplace != nil &amp;&amp; len(modifier.BodyReplace) &gt; 0 </span><span class="cov8" title="1">{
                var bodyMap map[string]interface{}
                if err := json.Unmarshal(resp.Body, &amp;bodyMap); err == nil </span><span class="cov8" title="1">{
                        // 应用替换
                        for key, value := range modifier.BodyReplace </span><span class="cov8" title="1">{
                                bodyMap[key] = value
                        }</span>
                        // 重新序列化
                        <span class="cov8" title="1">modifiedBody, err := json.Marshal(bodyMap)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">resp.Body = modifiedBody</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// shouldInjectError 判断是否应该注入错误
func shouldInjectError(errorRate float64) bool <span class="cov8" title="1">{
        if errorRate &lt;= 0 </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">if errorRate &gt;= 1.0 </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">return rand.Float64() &lt; errorRate</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package executor

import (
        "bytes"
        "encoding/base64"
        "encoding/json"
        "fmt"
        "math/rand"
        "text/template"
        "time"

        "github.com/google/uuid"
        "github.com/gomockserver/mockserver/internal/adapter"
        "github.com/gomockserver/mockserver/internal/models"
)

// TemplateEngine 模板引擎
type TemplateEngine struct {
        funcMap template.FuncMap
}

// NewTemplateEngine 创建模板引擎
func NewTemplateEngine() *TemplateEngine <span class="cov8" title="1">{
        engine := &amp;TemplateEngine{}
        engine.funcMap = engine.buildFuncMap()
        return engine
}</span>

// buildFuncMap 构建模板函数映射
func (e *TemplateEngine) buildFuncMap() template.FuncMap <span class="cov8" title="1">{
        return template.FuncMap{
                // 时间相关函数
                "timestamp": func() int64 </span><span class="cov8" title="1">{
                        return time.Now().Unix()
                }</span>,
                "timestampMilli": func() int64 <span class="cov8" title="1">{
                        return time.Now().UnixMilli()
                }</span>,
                "now": func(format string) string <span class="cov8" title="1">{
                        if format == "" </span><span class="cov0" title="0">{
                                format = "2006-01-02 15:04:05"
                        }</span>
                        <span class="cov8" title="1">return time.Now().Format(format)</span>
                },
                "date": func(format string) string <span class="cov8" title="1">{
                        if format == "" </span><span class="cov8" title="1">{
                                format = "2006-01-02"
                        }</span>
                        <span class="cov8" title="1">return time.Now().Format(format)</span>
                },
                "time": func(format string) string <span class="cov8" title="1">{
                        if format == "" </span><span class="cov8" title="1">{
                                format = "15:04:05"
                        }</span>
                        <span class="cov8" title="1">return time.Now().Format(format)</span>
                },

                // 随机数相关函数
                "uuid": func() string <span class="cov8" title="1">{
                        return uuid.New().String()
                }</span>,
                "uuidShort": func() string <span class="cov8" title="1">{
                        id := uuid.New().String()
                        return id[:8]
                }</span>,
                "random": func(min, max int) int <span class="cov8" title="1">{
                        if max &lt;= min </span><span class="cov8" title="1">{
                                return min
                        }</span>
                        <span class="cov8" title="1">return min + rand.Intn(max-min)</span>
                },
                "randomString": func(length int) string <span class="cov8" title="1">{
                        const charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
                        result := make([]byte, length)
                        for i := range result </span><span class="cov8" title="1">{
                                result[i] = charset[rand.Intn(len(charset))]
                        }</span>
                        <span class="cov8" title="1">return string(result)</span>
                },
                "randomInt": func() int <span class="cov8" title="1">{
                        return rand.Int()
                }</span>,
                "randomFloat": func() float64 <span class="cov8" title="1">{
                        return rand.Float64()
                }</span>,

                // 编码相关函数
                "base64": func(s string) string <span class="cov8" title="1">{
                        return base64.StdEncoding.EncodeToString([]byte(s))
                }</span>,
                "base64Decode": func(s string) (string, error) <span class="cov8" title="1">{
                        decoded, err := base64.StdEncoding.DecodeString(s)
                        if err != nil </span><span class="cov0" title="0">{
                                return "", err
                        }</span>
                        <span class="cov8" title="1">return string(decoded), nil</span>
                },

                // 字符串相关函数
                "concat": func(strs ...string) string <span class="cov8" title="1">{
                        var result string
                        for _, s := range strs </span><span class="cov8" title="1">{
                                result += s
                        }</span>
                        <span class="cov8" title="1">return result</span>
                },
                "quote": func(s string) string <span class="cov8" title="1">{
                        return fmt.Sprintf("\"%s\"", s)
                }</span>,

                // JSON 相关函数
                "toJSON": func(v interface{}) (string, error) <span class="cov8" title="1">{
                        bytes, err := json.Marshal(v)
                        if err != nil </span><span class="cov0" title="0">{
                                return "", err
                        }</span>
                        <span class="cov8" title="1">return string(bytes), nil</span>
                },
                "toJSONPretty": func(v interface{}) (string, error) <span class="cov8" title="1">{
                        bytes, err := json.MarshalIndent(v, "", "  ")
                        if err != nil </span><span class="cov0" title="0">{
                                return "", err
                        }</span>
                        <span class="cov8" title="1">return string(bytes), nil</span>
                },
        }
}

// TemplateContext 模板上下文
type TemplateContext struct {
        Request     *RequestContext     `json:"request"`
        Rule        *RuleContext        `json:"rule"`
        Environment *EnvironmentContext `json:"environment"`
}

// RequestContext 请求上下文
type RequestContext struct {
        Method  string                 `json:"method"`
        Path    string                 `json:"path"`
        Headers map[string]string      `json:"headers"`
        Query   map[string]string      `json:"query"`
        Body    interface{}            `json:"body"`
        IP      string                 `json:"ip"`
}

// RuleContext 规则上下文
type RuleContext struct {
        ID       string `json:"id"`
        Name     string `json:"name"`
        Priority int    `json:"priority"`
}

// EnvironmentContext 环境上下文
type EnvironmentContext struct {
        Variables map[string]interface{} `json:"variables"`
}

// BuildContext 构建模板上下文
func (e *TemplateEngine) BuildContext(request *adapter.Request, rule *models.Rule, env *models.Environment) *TemplateContext <span class="cov8" title="1">{
        // 提取HTTP特定信息
        method := ""
        query := make(map[string]string)
        if request.Metadata != nil </span><span class="cov8" title="1">{
                if m, ok := request.Metadata["method"].(string); ok </span><span class="cov8" title="1">{
                        method = m
                }</span>
                <span class="cov8" title="1">if q, ok := request.Metadata["query"].(map[string]string); ok </span><span class="cov8" title="1">{
                        query = q
                }</span>
        }

        <span class="cov8" title="1">ctx := &amp;TemplateContext{
                Request: &amp;RequestContext{
                        Method:  method,
                        Path:    request.Path,
                        Headers: request.Headers,
                        Query:   query,
                        IP:      request.SourceIP,
                },
                Rule: &amp;RuleContext{
                        ID:       rule.ID,
                        Name:     rule.Name,
                        Priority: rule.Priority,
                },
                Environment: &amp;EnvironmentContext{
                        Variables: make(map[string]interface{}),
                },
        }

        // 解析请求体
        if len(request.Body) &gt; 0 </span><span class="cov8" title="1">{
                var body interface{}
                if err := json.Unmarshal(request.Body, &amp;body); err == nil </span><span class="cov8" title="1">{
                        ctx.Request.Body = body
                }</span> else<span class="cov0" title="0"> {
                        ctx.Request.Body = string(request.Body)
                }</span>
        }

        // 设置环境变量
        <span class="cov8" title="1">if env != nil &amp;&amp; env.Variables != nil </span><span class="cov8" title="1">{
                ctx.Environment.Variables = env.Variables
        }</span>

        <span class="cov8" title="1">return ctx</span>
}

// Render 渲染模板
func (e *TemplateEngine) Render(templateStr string, context *TemplateContext) (string, error) <span class="cov8" title="1">{
        // 创建模板
        tmpl, err := template.New("response").Funcs(e.funcMap).Parse(templateStr)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to parse template: %w", err)
        }</span>

        // 渲染模板
        <span class="cov8" title="1">var buf bytes.Buffer
        if err := tmpl.Execute(&amp;buf, context); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to execute template: %w", err)
        }</span>

        <span class="cov8" title="1">return buf.String(), nil</span>
}

// RenderJSON 渲染JSON模板
func (e *TemplateEngine) RenderJSON(templateObj interface{}, context *TemplateContext) (interface{}, error) <span class="cov8" title="1">{
        return e.renderJSONRecursive(templateObj, context)
}</span>

// renderJSONRecursive 递归渲染JSON对象
func (e *TemplateEngine) renderJSONRecursive(obj interface{}, context *TemplateContext) (interface{}, error) <span class="cov8" title="1">{
        switch v := obj.(type) </span>{
        case string:<span class="cov8" title="1">
                // 如果是字符串，检查是否包含模板语法
                if len(v) &gt; 0 &amp;&amp; (v[0] == '{' &amp;&amp; v[len(v)-1] == '}' || contains(v, "{{")) </span><span class="cov8" title="1">{
                        rendered, err := e.Render(v, context)
                        if err != nil </span><span class="cov0" title="0">{
                                return v, nil // 如果渲染失败，返回原始字符串
                        }</span>
                        <span class="cov8" title="1">return rendered, nil</span>
                }
                <span class="cov8" title="1">return v, nil</span>
        
        case map[string]interface{}:<span class="cov8" title="1">
                // 递归处理map
                result := make(map[string]interface{})
                for key, val := range v </span><span class="cov8" title="1">{
                        rendered, err := e.renderJSONRecursive(val, context)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">result[key] = rendered</span>
                }
                <span class="cov8" title="1">return result, nil</span>
        
        case []interface{}:<span class="cov0" title="0">
                // 递归处理数组
                result := make([]interface{}, len(v))
                for i, val := range v </span><span class="cov0" title="0">{
                        rendered, err := e.renderJSONRecursive(val, context)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">result[i] = rendered</span>
                }
                <span class="cov0" title="0">return result, nil</span>
        
        default:<span class="cov0" title="0">
                // 其他类型直接返回
                return v, nil</span>
        }
}

// contains 检查字符串是否包含子串
func contains(s, substr string) bool <span class="cov8" title="1">{
        for i := 0; i &lt;= len(s)-len(substr); i++ </span><span class="cov8" title="1">{
                if s[i:i+len(substr)] == substr </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package metrics

import (
        "fmt"

        "github.com/prometheus/client_golang/prometheus"
        "github.com/prometheus/client_golang/prometheus/promauto"
)

// Metrics 系统指标收集器
type Metrics struct {
        // HTTP 请求指标
        HTTPRequestsTotal   *prometheus.CounterVec
        HTTPRequestDuration *prometheus.HistogramVec
        HTTPRequestsInFlight prometheus.Gauge

        // WebSocket 指标
        WebSocketConnections prometheus.Gauge
        WebSocketMessagesTotal *prometheus.CounterVec

        // 规则匹配指标
        RuleMatchesTotal   *prometheus.CounterVec
        RuleMatchDuration  *prometheus.HistogramVec
        RulesTotal         prometheus.Gauge

        // 系统资源指标
        GoroutinesCount prometheus.Gauge
        MemoryUsage     prometheus.Gauge
        CPUUsage        prometheus.Gauge

        // 数据库指标
        DBQueryDuration    *prometheus.HistogramVec
        DBConnectionsTotal prometheus.Gauge

        // 错误指标
        ErrorsTotal *prometheus.CounterVec
}

// New 创建指标收集器
func New() *Metrics <span class="cov8" title="1">{
        return &amp;Metrics{
                // HTTP 请求指标
                HTTPRequestsTotal: promauto.NewCounterVec(
                        prometheus.CounterOpts{
                                Namespace: "mockserver",
                                Subsystem: "http",
                                Name:      "requests_total",
                                Help:      "Total number of HTTP requests",
                        },
                        []string{"method", "path", "status"},
                ),
                HTTPRequestDuration: promauto.NewHistogramVec(
                        prometheus.HistogramOpts{
                                Namespace: "mockserver",
                                Subsystem: "http",
                                Name:      "request_duration_seconds",
                                Help:      "HTTP request duration in seconds",
                                Buckets:   prometheus.DefBuckets,
                        },
                        []string{"method", "path"},
                ),
                HTTPRequestsInFlight: promauto.NewGauge(
                        prometheus.GaugeOpts{
                                Namespace: "mockserver",
                                Subsystem: "http",
                                Name:      "requests_in_flight",
                                Help:      "Number of HTTP requests currently being processed",
                        },
                ),

                // WebSocket 指标
                WebSocketConnections: promauto.NewGauge(
                        prometheus.GaugeOpts{
                                Namespace: "mockserver",
                                Subsystem: "websocket",
                                Name:      "connections",
                                Help:      "Current number of WebSocket connections",
                        },
                ),
                WebSocketMessagesTotal: promauto.NewCounterVec(
                        prometheus.CounterOpts{
                                Namespace: "mockserver",
                                Subsystem: "websocket",
                                Name:      "messages_total",
                                Help:      "Total number of WebSocket messages",
                        },
                        []string{"direction"}, // send, receive
                ),

                // 规则匹配指标
                RuleMatchesTotal: promauto.NewCounterVec(
                        prometheus.CounterOpts{
                                Namespace: "mockserver",
                                Subsystem: "rule",
                                Name:      "matches_total",
                                Help:      "Total number of rule matches",
                        },
                        []string{"rule_id", "project_id", "matched"},
                ),
                RuleMatchDuration: promauto.NewHistogramVec(
                        prometheus.HistogramOpts{
                                Namespace: "mockserver",
                                Subsystem: "rule",
                                Name:      "match_duration_seconds",
                                Help:      "Rule matching duration in seconds",
                                Buckets:   []float64{0.001, 0.005, 0.01, 0.025, 0.05, 0.1},
                        },
                        []string{"project_id"},
                ),
                RulesTotal: promauto.NewGauge(
                        prometheus.GaugeOpts{
                                Namespace: "mockserver",
                                Subsystem: "rule",
                                Name:      "total",
                                Help:      "Total number of active rules",
                        },
                ),

                // 系统资源指标
                GoroutinesCount: promauto.NewGauge(
                        prometheus.GaugeOpts{
                                Namespace: "mockserver",
                                Subsystem: "system",
                                Name:      "goroutines",
                                Help:      "Number of goroutines",
                        },
                ),
                MemoryUsage: promauto.NewGauge(
                        prometheus.GaugeOpts{
                                Namespace: "mockserver",
                                Subsystem: "system",
                                Name:      "memory_bytes",
                                Help:      "Memory usage in bytes",
                        },
                ),
                CPUUsage: promauto.NewGauge(
                        prometheus.GaugeOpts{
                                Namespace: "mockserver",
                                Subsystem: "system",
                                Name:      "cpu_usage_percent",
                                Help:      "CPU usage percentage",
                        },
                ),

                // 数据库指标
                DBQueryDuration: promauto.NewHistogramVec(
                        prometheus.HistogramOpts{
                                Namespace: "mockserver",
                                Subsystem: "db",
                                Name:      "query_duration_seconds",
                                Help:      "Database query duration in seconds",
                                Buckets:   []float64{0.001, 0.005, 0.01, 0.025, 0.05, 0.1, 0.5, 1.0},
                        },
                        []string{"operation", "collection"},
                ),
                DBConnectionsTotal: promauto.NewGauge(
                        prometheus.GaugeOpts{
                                Namespace: "mockserver",
                                Subsystem: "db",
                                Name:      "connections",
                                Help:      "Number of database connections",
                        },
                ),

                // 错误指标
                ErrorsTotal: promauto.NewCounterVec(
                        prometheus.CounterOpts{
                                Namespace: "mockserver",
                                Subsystem: "errors",
                                Name:      "total",
                                Help:      "Total number of errors",
                        },
                        []string{"type", "component"},
                ),
        }
}</span>

// RecordHTTPRequest 记录 HTTP 请求
func (m *Metrics) RecordHTTPRequest(method, path string, status int, duration float64) <span class="cov8" title="1">{
        statusClass := fmt.Sprintf("%dxx", status/100)
        m.HTTPRequestsTotal.WithLabelValues(method, path, statusClass).Inc()
        m.HTTPRequestDuration.WithLabelValues(method, path).Observe(duration)
}</span>

// RecordRuleMatch 记录规则匹配
func (m *Metrics) RecordRuleMatch(ruleID, projectID string, matched bool, duration float64) <span class="cov8" title="1">{
        matchedStr := "false"
        if matched </span><span class="cov8" title="1">{
                matchedStr = "true"
        }</span>
        <span class="cov8" title="1">m.RuleMatchesTotal.WithLabelValues(ruleID, projectID, matchedStr).Inc()
        m.RuleMatchDuration.WithLabelValues(projectID).Observe(duration)</span>
}

// RecordDBQuery 记录数据库查询
func (m *Metrics) RecordDBQuery(operation, collection string, duration float64) <span class="cov8" title="1">{
        m.DBQueryDuration.WithLabelValues(operation, collection).Observe(duration)
}</span>

// RecordError 记录错误
func (m *Metrics) RecordError(errorType, component string) <span class="cov8" title="1">{
        m.ErrorsTotal.WithLabelValues(errorType, component).Inc()
}</span>

// IncrementWSConnections WebSocket 连接数增加
func (m *Metrics) IncrementWSConnections() <span class="cov8" title="1">{
        m.WebSocketConnections.Inc()
}</span>

// DecrementWSConnections WebSocket 连接数减少
func (m *Metrics) DecrementWSConnections() <span class="cov8" title="1">{
        m.WebSocketConnections.Dec()
}</span>

// RecordWSMessage 记录 WebSocket 消息
func (m *Metrics) RecordWSMessage(direction string) <span class="cov8" title="1">{
        m.WebSocketMessagesTotal.WithLabelValues(direction).Inc()
}</span>

// UpdateSystemMetrics 更新系统指标
func (m *Metrics) UpdateSystemMetrics(goroutines int, memoryBytes uint64, cpuPercent float64) <span class="cov8" title="1">{
        m.GoroutinesCount.Set(float64(goroutines))
        m.MemoryUsage.Set(float64(memoryBytes))
        m.CPUUsage.Set(cpuPercent)
}</span>

// SetRulesTotal 设置规则总数
func (m *Metrics) SetRulesTotal(count int) <span class="cov8" title="1">{
        m.RulesTotal.Set(float64(count))
}</span>

// SetDBConnections 设置数据库连接数
func (m *Metrics) SetDBConnections(count int) <span class="cov8" title="1">{
        m.DBConnectionsTotal.Set(float64(count))
}</span>

// IncrementHTTPRequestsInFlight HTTP 请求进行中数量增加
func (m *Metrics) IncrementHTTPRequestsInFlight() <span class="cov8" title="1">{
        m.HTTPRequestsInFlight.Inc()
}</span>

// DecrementHTTPRequestsInFlight HTTP 请求进行中数量减少
func (m *Metrics) DecrementHTTPRequestsInFlight() <span class="cov8" title="1">{
        m.HTTPRequestsInFlight.Dec()
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package middleware

import (
        "github.com/gin-contrib/cors"
        "github.com/gin-gonic/gin"
        "time"
)

// CORSConfig CORS 配置
type CORSConfig struct {
        AllowOrigins     []string
        AllowMethods     []string
        AllowHeaders     []string
        ExposeHeaders    []string
        AllowCredentials bool
        MaxAge           time.Duration
}

// DefaultCORSConfig 默认 CORS 配置
func DefaultCORSConfig() CORSConfig <span class="cov8" title="1">{
        return CORSConfig{
                AllowOrigins: []string{
                        "http://localhost:5173", // 前端开发服务器
                        "http://localhost:8080", // 前端生产环境（集成部署）
                },
                AllowMethods: []string{
                        "GET", "POST", "PUT", "DELETE", "OPTIONS", "PATCH",
                },
                AllowHeaders: []string{
                        "Content-Type",
                        "Authorization",  // 预留用于 v0.9.0
                        "X-Request-ID",   // 前端添加的请求追踪 ID
                },
                ExposeHeaders: []string{
                        "X-Request-ID",
                },
                AllowCredentials: true,
                MaxAge:           12 * time.Hour,
        }
}</span>

// CORS 创建 CORS 中间件
func CORS(config ...CORSConfig) gin.HandlerFunc <span class="cov8" title="1">{
        // 如果没有提供配置，使用默认配置
        cfg := DefaultCORSConfig()
        if len(config) &gt; 0 </span><span class="cov8" title="1">{
                cfg = config[0]
        }</span>

        <span class="cov8" title="1">corsConfig := cors.Config{
                AllowOrigins:     cfg.AllowOrigins,
                AllowMethods:     cfg.AllowMethods,
                AllowHeaders:     cfg.AllowHeaders,
                ExposeHeaders:    cfg.ExposeHeaders,
                AllowCredentials: cfg.AllowCredentials,
                MaxAge:           cfg.MaxAge,
        }

        return cors.New(corsConfig)</span>
}

// CORSWithDynamicOrigin 创建支持动态源的 CORS 中间件
// 用于支持更灵活的 CORS 配置（例如：允许所有 localhost 端口）
func CORSWithDynamicOrigin() gin.HandlerFunc <span class="cov8" title="1">{
        return cors.New(cors.Config{
                AllowOriginFunc: func(origin string) bool </span><span class="cov8" title="1">{
                        // 允许所有 localhost 源
                        if origin == "http://localhost:5173" || origin == "http://localhost:8080" </span><span class="cov8" title="1">{
                                return true
                        }</span>
                        // 生产环境可以根据配置文件或环境变量添加允许的域名
                        <span class="cov8" title="1">return false</span>
                },
                AllowMethods: []string{
                        "GET", "POST", "PUT", "DELETE", "OPTIONS", "PATCH",
                },
                AllowHeaders: []string{
                        "Content-Type",
                        "Authorization",
                        "X-Request-ID",
                },
                ExposeHeaders: []string{
                        "X-Request-ID",
                },
                AllowCredentials: true,
                MaxAge:           12 * time.Hour,
        })
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package middleware

import (
        "bytes"
        "encoding/json"
        "io"
        "strings"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/gomockserver/mockserver/internal/models"
        "github.com/gomockserver/mockserver/internal/repository"
        "github.com/gomockserver/mockserver/pkg/logger"
        "go.uber.org/zap"
)

// RequestLoggerMiddleware 请求日志记录中间件
type RequestLoggerMiddleware struct {
        repo    repository.RequestLogRepository
        enabled bool
}

// NewRequestLoggerMiddleware 创建请求日志中间件
func NewRequestLoggerMiddleware(repo repository.RequestLogRepository) *RequestLoggerMiddleware <span class="cov8" title="1">{
        return &amp;RequestLoggerMiddleware{
                repo:    repo,
                enabled: true,
        }
}</span>

// SetEnabled 设置是否启用
func (m *RequestLoggerMiddleware) SetEnabled(enabled bool) <span class="cov8" title="1">{
        m.enabled = enabled
}</span>

// responseWriter 自定义 ResponseWriter 用于捕获响应
type responseWriter struct {
        gin.ResponseWriter
        body *bytes.Buffer
}

func (w *responseWriter) Write(b []byte) (int, error) <span class="cov8" title="1">{
        w.body.Write(b)
        return w.ResponseWriter.Write(b)
}</span>

func (w *responseWriter) WriteString(s string) (int, error) <span class="cov8" title="1">{
        w.body.WriteString(s)
        return w.ResponseWriter.WriteString(s)
}</span>

// Handler 日志记录处理器
func (m *RequestLoggerMiddleware) Handler() gin.HandlerFunc <span class="cov8" title="1">{
        return func(c *gin.Context) </span><span class="cov8" title="1">{
                if !m.enabled </span><span class="cov8" title="1">{
                        c.Next()
                        return
                }</span>

                // 记录开始时间
                <span class="cov8" title="1">startTime := time.Now()

                // 读取请求体
                var requestBody []byte
                if c.Request.Body != nil </span><span class="cov8" title="1">{
                        requestBody, _ = io.ReadAll(c.Request.Body)
                        // 重新设置请求体，供后续处理使用
                        c.Request.Body = io.NopCloser(bytes.NewBuffer(requestBody))
                }</span>

                // 创建自定义 ResponseWriter
                <span class="cov8" title="1">blw := &amp;responseWriter{
                        ResponseWriter: c.Writer,
                        body:           bytes.NewBufferString(""),
                }
                c.Writer = blw

                // 处理请求
                c.Next()

                // 计算耗时
                duration := time.Since(startTime).Milliseconds()

                // 从上下文获取项目和环境信息
                projectID, _ := c.Get("project_id")
                environmentID, _ := c.Get("environment_id")
                ruleID, _ := c.Get("rule_id")
                requestID, _ := c.Get("request_id")

                // 构建请求日志
                requestLog := &amp;models.RequestLog{
                        RequestID:     getStringValue(requestID),
                        ProjectID:     getStringValue(projectID),
                        EnvironmentID: getStringValue(environmentID),
                        RuleID:        getStringValue(ruleID),
                        Protocol:      m.getProtocol(c),
                        Method:        c.Request.Method,
                        Path:          c.Request.URL.Path,
                        StatusCode:    c.Writer.Status(),
                        Duration:      duration,
                        SourceIP:      c.ClientIP(),
                        Timestamp:     startTime,
                        Request:       m.buildRequestData(c, requestBody),
                        Response:      m.buildResponseData(c, blw.body.Bytes()),
                }

                // 异步保存日志（避免阻塞请求）
                go func() </span><span class="cov8" title="1">{
                        ctx := c.Request.Context()
                        if err := m.repo.Create(ctx, requestLog); err != nil </span><span class="cov0" title="0">{
                                logger.Error("failed to save request log",
                                        zap.String("request_id", requestLog.RequestID),
                                        zap.Error(err))
                        }</span>
                }()
        }
}

// getProtocol 获取协议类型
func (m *RequestLoggerMiddleware) getProtocol(c *gin.Context) models.ProtocolType <span class="cov8" title="1">{
        // 检查是否是 WebSocket 升级请求
        if c.Request.Header.Get("Upgrade") == "websocket" </span><span class="cov8" title="1">{
                return models.ProtocolWebSocket
        }</span>
        <span class="cov8" title="1">return models.ProtocolHTTP</span>
}

// buildRequestData 构建请求数据
func (m *RequestLoggerMiddleware) buildRequestData(c *gin.Context, body []byte) map[string]interface{} <span class="cov8" title="1">{
        data := make(map[string]interface{})

        // 基本信息
        data["method"] = c.Request.Method
        data["path"] = c.Request.URL.Path
        data["query"] = c.Request.URL.RawQuery
        data["headers"] = m.sanitizeHeaders(c.Request.Header)

        // 请求体
        if len(body) &gt; 0 </span><span class="cov8" title="1">{
                // 尝试解析为 JSON
                var jsonBody interface{}
                if err := json.Unmarshal(body, &amp;jsonBody); err == nil </span><span class="cov8" title="1">{
                        data["body"] = jsonBody
                }</span> else<span class="cov8" title="1"> {
                        // 如果不是 JSON，限制长度存储为字符串
                        bodyStr := string(body)
                        if len(bodyStr) &gt; 1000 </span><span class="cov8" title="1">{
                                bodyStr = bodyStr[:1000] + "... (truncated)"
                        }</span>
                        <span class="cov8" title="1">data["body"] = bodyStr</span>
                }
        }

        <span class="cov8" title="1">return data</span>
}

// buildResponseData 构建响应数据
func (m *RequestLoggerMiddleware) buildResponseData(c *gin.Context, body []byte) map[string]interface{} <span class="cov8" title="1">{
        data := make(map[string]interface{})

        data["status_code"] = c.Writer.Status()
        data["headers"] = m.sanitizeHeaders(c.Writer.Header())

        // 响应体
        if len(body) &gt; 0 </span><span class="cov8" title="1">{
                // 尝试解析为 JSON
                var jsonBody interface{}
                if err := json.Unmarshal(body, &amp;jsonBody); err == nil </span><span class="cov8" title="1">{
                        data["body"] = jsonBody
                }</span> else<span class="cov8" title="1"> {
                        // 如果不是 JSON，限制长度存储为字符串
                        bodyStr := string(body)
                        if len(bodyStr) &gt; 1000 </span><span class="cov0" title="0">{
                                bodyStr = bodyStr[:1000] + "... (truncated)"
                        }</span>
                        <span class="cov8" title="1">data["body"] = bodyStr</span>
                }
        }

        <span class="cov8" title="1">return data</span>
}

// sanitizeHeaders 清理敏感头信息
func (m *RequestLoggerMiddleware) sanitizeHeaders(headers map[string][]string) map[string]string <span class="cov8" title="1">{
        result := make(map[string]string)
        sensitiveHeaders := map[string]bool{
                "authorization": true,
                "cookie":        true,
                "set-cookie":    true,
                "x-api-key":     true,
        }

        for key, values := range headers </span><span class="cov8" title="1">{
                lowerKey := strings.ToLower(key)
                if sensitiveHeaders[lowerKey] </span><span class="cov8" title="1">{
                        result[key] = "***REDACTED***"
                }</span> else<span class="cov8" title="1"> if len(values) &gt; 0 </span><span class="cov8" title="1">{
                        result[key] = values[0]
                }</span>
        }

        <span class="cov8" title="1">return result</span>
}

// getStringValue 安全获取字符串值
func getStringValue(v interface{}) string <span class="cov8" title="1">{
        if v == nil </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">if str, ok := v.(string); ok </span><span class="cov8" title="1">{
                return str
        }</span>
        <span class="cov8" title="1">return ""</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package models

import "fmt"

// ErrorCode 错误码结构
type ErrorCode struct {
        Code      int    // 错误码
        Message   string // 错误信息（英文）
        ZhMessage string // 错误信息（中文）
}

// Error 实现 error 接口
func (e ErrorCode) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("[%d] %s", e.Code, e.Message)
}</span>

// ErrorResponse API错误响应结构
type ErrorResponse struct {
        Error ErrorDetail `json:"error"`
}

// ErrorDetail 错误详情
type ErrorDetail struct {
        Code      int    `json:"code"`
        Message   string `json:"message"`
        Details   string `json:"details,omitempty"`
        RequestID string `json:"request_id,omitempty"`
}

// ============================================
// 通用错误 1000-1999
// ============================================

var (
        // ErrInvalidParameter 无效参数
        ErrInvalidParameter = ErrorCode{1001, "Invalid parameter", "参数无效"}
        // ErrMissingParameter 缺少必填参数
        ErrMissingParameter = ErrorCode{1002, "Missing required parameter", "缺少必填参数"}
        // ErrInvalidFormat 格式无效
        ErrInvalidFormat = ErrorCode{1003, "Invalid format", "格式无效"}
        // ErrInvalidObjectID 无效的ObjectID
        ErrInvalidObjectID = ErrorCode{1004, "Invalid ObjectID format", "无效的ObjectID格式"}
        // ErrUnauthorized 未授权
        ErrUnauthorized = ErrorCode{1010, "Unauthorized", "未授权"}
        // ErrForbidden 禁止访问
        ErrForbidden = ErrorCode{1011, "Forbidden", "禁止访问"}
        // ErrRateLimited 请求过于频繁
        ErrRateLimited = ErrorCode{1020, "Too many requests", "请求过于频繁"}
)

// ============================================
// 项目相关 2000-2999
// ============================================

var (
        // ErrProjectNotFound 项目不存在
        ErrProjectNotFound = ErrorCode{2001, "Project not found", "项目不存在"}
        // ErrProjectExists 项目已存在
        ErrProjectExists = ErrorCode{2002, "Project already exists", "项目已存在"}
        // ErrProjectNameInvalid 项目名称无效
        ErrProjectNameInvalid = ErrorCode{2003, "Invalid project name", "项目名称无效"}
        // ErrProjectCreateFailed 创建项目失败
        ErrProjectCreateFailed = ErrorCode{2010, "Failed to create project", "创建项目失败"}
        // ErrProjectUpdateFailed 更新项目失败
        ErrProjectUpdateFailed = ErrorCode{2011, "Failed to update project", "更新项目失败"}
        // ErrProjectDeleteFailed 删除项目失败
        ErrProjectDeleteFailed = ErrorCode{2012, "Failed to delete project", "删除项目失败"}
)

// ============================================
// 环境相关 3000-3999
// ============================================

var (
        // ErrEnvironmentNotFound 环境不存在
        ErrEnvironmentNotFound = ErrorCode{3001, "Environment not found", "环境不存在"}
        // ErrEnvironmentExists 环境已存在
        ErrEnvironmentExists = ErrorCode{3002, "Environment already exists", "环境已存在"}
        // ErrEnvironmentNameInvalid 环境名称无效
        ErrEnvironmentNameInvalid = ErrorCode{3003, "Invalid environment name", "环境名称无效"}
        // ErrEnvironmentCreateFailed 创建环境失败
        ErrEnvironmentCreateFailed = ErrorCode{3010, "Failed to create environment", "创建环境失败"}
        // ErrEnvironmentUpdateFailed 更新环境失败
        ErrEnvironmentUpdateFailed = ErrorCode{3011, "Failed to update environment", "更新环境失败"}
        // ErrEnvironmentDeleteFailed 删除环境失败
        ErrEnvironmentDeleteFailed = ErrorCode{3012, "Failed to delete environment", "删除环境失败"}
)

// ============================================
// 规则相关 4000-4999
// ============================================

var (
        // ErrRuleNotFound 规则不存在
        ErrRuleNotFound = ErrorCode{4001, "Rule not found", "规则不存在"}
        // ErrRuleMatchFailed 未找到匹配的规则
        ErrRuleMatchFailed = ErrorCode{4002, "No matching rule found", "未找到匹配的规则"}
        // ErrRuleNameInvalid 规则名称无效
        ErrRuleNameInvalid = ErrorCode{4003, "Invalid rule name", "规则名称无效"}
        // ErrRulePriorityInvalid 规则优先级无效
        ErrRulePriorityInvalid = ErrorCode{4004, "Invalid rule priority", "规则优先级无效"}
        // ErrRuleConditionInvalid 规则匹配条件无效
        ErrRuleConditionInvalid = ErrorCode{4005, "Invalid rule match condition", "规则匹配条件无效"}
        // ErrRuleResponseInvalid 规则响应配置无效
        ErrRuleResponseInvalid = ErrorCode{4006, "Invalid rule response", "规则响应配置无效"}
        // ErrRuleCreateFailed 创建规则失败
        ErrRuleCreateFailed = ErrorCode{4010, "Failed to create rule", "创建规则失败"}
        // ErrRuleUpdateFailed 更新规则失败
        ErrRuleUpdateFailed = ErrorCode{4011, "Failed to update rule", "更新规则失败"}
        // ErrRuleDeleteFailed 删除规则失败
        ErrRuleDeleteFailed = ErrorCode{4012, "Failed to delete rule", "删除规则失败"}
        // ErrRuleImportFailed 导入规则失败
        ErrRuleImportFailed = ErrorCode{4020, "Failed to import rules", "导入规则失败"}
        // ErrRuleExportFailed 导出规则失败
        ErrRuleExportFailed = ErrorCode{4021, "Failed to export rules", "导出规则失败"}
        // ErrRuleCloneFailed 复制规则失败
        ErrRuleCloneFailed = ErrorCode{4022, "Failed to clone rule", "复制规则失败"}
)

// ============================================
// 批量操作相关 6000-6999
// ============================================

var (
        // ErrBatchOperationFailed 批量操作失败
        ErrBatchOperationFailed = ErrorCode{6001, "Batch operation failed", "批量操作失败"}
        // ErrBatchPartialSuccess 批量操作部分成功
        ErrBatchPartialSuccess = ErrorCode{6002, "Batch operation partially succeeded", "批量操作部分成功"}
        // ErrBatchInvalidInput 批量操作输入无效
        ErrBatchInvalidInput = ErrorCode{6003, "Invalid batch operation input", "批量操作输入无效"}
        // ErrBatchEmptyInput 批量操作输入为空
        ErrBatchEmptyInput = ErrorCode{6004, "Batch operation input is empty", "批量操作输入为空"}
)

// ============================================
// 导入导出相关 7000-7999
// ============================================

var (
        // ErrImportDataInvalid 导入数据无效
        ErrImportDataInvalid = ErrorCode{7001, "Import data is invalid", "导入数据无效"}
        // ErrExportFailed 导出操作失败
        ErrExportFailed = ErrorCode{7002, "Export operation failed", "导出操作失败"}
        // ErrImportConflict 导入数据冲突
        ErrImportConflict = ErrorCode{7003, "Import data conflicts with existing data", "导入数据与现有数据冲突"}
        // ErrUnsupportedVersion 不支持的数据版本
        ErrUnsupportedVersion = ErrorCode{7004, "Unsupported import data version", "不支持的导入数据版本"}
        // ErrImportStrategyInvalid 导入策略无效
        ErrImportStrategyInvalid = ErrorCode{7005, "Invalid import strategy", "导入策略无效"}
        // ErrExportTypeInvalid 导出类型无效
        ErrExportTypeInvalid = ErrorCode{7006, "Invalid export type", "导出类型无效"}
)

// ============================================
// 数据库相关 5000-5999
// ============================================

var (
        // ErrDatabaseConnection 数据库连接失败
        ErrDatabaseConnection = ErrorCode{5001, "Database connection failed", "数据库连接失败"}
        // ErrDatabaseQuery 数据库查询失败
        ErrDatabaseQuery = ErrorCode{5002, "Database query failed", "数据库查询失败"}
        // ErrDatabaseInsert 数据库插入失败
        ErrDatabaseInsert = ErrorCode{5003, "Database insert failed", "数据库插入失败"}
        // ErrDatabaseUpdate 数据库更新失败
        ErrDatabaseUpdate = ErrorCode{5004, "Database update failed", "数据库更新失败"}
        // ErrDatabaseDelete 数据库删除失败
        ErrDatabaseDelete = ErrorCode{5005, "Database delete failed", "数据库删除失败"}
        // ErrDatabaseTransaction 数据库事务失败
        ErrDatabaseTransaction = ErrorCode{5010, "Database transaction failed", "数据库事务失败"}
)

// ============================================
// 系统错误 9000-9999
// ============================================

var (
        // ErrInternalServer 服务器内部错误
        ErrInternalServer = ErrorCode{9001, "Internal server error", "服务器内部错误"}
        // ErrServiceUnavailable 服务不可用
        ErrServiceUnavailable = ErrorCode{9002, "Service unavailable", "服务不可用"}
        // ErrTimeout 请求超时
        ErrTimeout = ErrorCode{9003, "Request timeout", "请求超时"}
        // ErrConfigError 配置错误
        ErrConfigError = ErrorCode{9010, "Configuration error", "配置错误"}
        // ErrUnknown 未知错误
        ErrUnknown = ErrorCode{9999, "Unknown error", "未知错误"}
)

// NewErrorResponse 创建错误响应
func NewErrorResponse(code ErrorCode, details string, requestID string) ErrorResponse <span class="cov0" title="0">{
        return ErrorResponse{
                Error: ErrorDetail{
                        Code:      code.Code,
                        Message:   code.Message,
                        Details:   details,
                        RequestID: requestID,
                },
        }
}</span>

// NewErrorResponseZh 创建中文错误响应
func NewErrorResponseZh(code ErrorCode, details string, requestID string) ErrorResponse <span class="cov0" title="0">{
        return ErrorResponse{
                Error: ErrorDetail{
                        Code:      code.Code,
                        Message:   code.ZhMessage,
                        Details:   details,
                        RequestID: requestID,
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">// Package monitoring provides monitoring and metrics collection for the mock server.
package monitoring

import (
        "sync/atomic"
)

// Metrics holds all the application metrics
type Metrics struct {
        // Regex cache metrics
        RegexCacheHits   int64 `json:"regex_cache_hits"`
        RegexCacheMisses int64 `json:"regex_cache_misses"`
        RegexCacheSize   int64 `json:"regex_cache_size"`
        
        // Request metrics
        TotalRequests    int64 `json:"total_requests"`
        MatchedRequests  int64 `json:"matched_requests"`
        UnmatchedRequests int64 `json:"unmatched_requests"`
        
        // Rule metrics
        TotalRules       int64 `json:"total_rules"`
        EnabledRules     int64 `json:"enabled_rules"`
}

// Global metrics instance
var globalMetrics = &amp;Metrics{}

// GetMetrics returns the current metrics
func GetMetrics() *Metrics <span class="cov8" title="1">{
        return globalMetrics
}</span>

// IncrementRegexCacheHits increments the regex cache hits counter
func IncrementRegexCacheHits() <span class="cov8" title="1">{
        atomic.AddInt64(&amp;globalMetrics.RegexCacheHits, 1)
}</span>

// IncrementRegexCacheMisses increments the regex cache misses counter
func IncrementRegexCacheMisses() <span class="cov8" title="1">{
        atomic.AddInt64(&amp;globalMetrics.RegexCacheMisses, 1)
}</span>

// SetRegexCacheSize sets the current regex cache size
func SetRegexCacheSize(size int64) <span class="cov8" title="1">{
        atomic.StoreInt64(&amp;globalMetrics.RegexCacheSize, size)
}</span>

// IncrementTotalRequests increments the total requests counter
func IncrementTotalRequests() <span class="cov8" title="1">{
        atomic.AddInt64(&amp;globalMetrics.TotalRequests, 1)
}</span>

// IncrementMatchedRequests increments the matched requests counter
func IncrementMatchedRequests() <span class="cov8" title="1">{
        atomic.AddInt64(&amp;globalMetrics.MatchedRequests, 1)
}</span>

// IncrementUnmatchedRequests increments the unmatched requests counter
func IncrementUnmatchedRequests() <span class="cov8" title="1">{
        atomic.AddInt64(&amp;globalMetrics.UnmatchedRequests, 1)
}</span>

// SetTotalRules sets the total rules count
func SetTotalRules(count int64) <span class="cov8" title="1">{
        atomic.StoreInt64(&amp;globalMetrics.TotalRules, count)
}</span>

// SetEnabledRules sets the enabled rules count
func SetEnabledRules(count int64) <span class="cov8" title="1">{
        atomic.StoreInt64(&amp;globalMetrics.EnabledRules, count)
}</span>

// ResetMetrics resets all metrics to zero
func ResetMetrics() <span class="cov8" title="1">{
        atomic.StoreInt64(&amp;globalMetrics.RegexCacheHits, 0)
        atomic.StoreInt64(&amp;globalMetrics.RegexCacheMisses, 0)
        atomic.StoreInt64(&amp;globalMetrics.RegexCacheSize, 0)
        atomic.StoreInt64(&amp;globalMetrics.TotalRequests, 0)
        atomic.StoreInt64(&amp;globalMetrics.MatchedRequests, 0)
        atomic.StoreInt64(&amp;globalMetrics.UnmatchedRequests, 0)
        atomic.StoreInt64(&amp;globalMetrics.TotalRules, 0)
        atomic.StoreInt64(&amp;globalMetrics.EnabledRules, 0)
}</pre>
		
		<pre class="file" id="file16" style="display: none">package repository

import (
        "context"
        "fmt"
        "time"

        "github.com/gomockserver/mockserver/internal/config"
        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/mongo"
        "go.mongodb.org/mongo-driver/mongo/options"
)

var (
        client   *mongo.Client
        database *mongo.Database
)

// Init 初始化数据库连接
func Init(cfg *config.Config) error <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), cfg.Database.MongoDB.Timeout)
        defer cancel()

        // 创建客户端选项
        clientOptions := options.Client().
                ApplyURI(cfg.Database.MongoDB.URI).
                SetMinPoolSize(uint64(cfg.Database.MongoDB.Pool.Min)).
                SetMaxPoolSize(uint64(cfg.Database.MongoDB.Pool.Max))

        // 连接数据库
        var err error
        client, err = mongo.Connect(ctx, clientOptions)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to connect to MongoDB: %w", err)
        }</span>

        // 验证连接
        <span class="cov0" title="0">if err = client.Ping(ctx, nil); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to ping MongoDB: %w", err)
        }</span>

        // 获取数据库实例
        <span class="cov0" title="0">database = client.Database(cfg.Database.MongoDB.Database)

        // 创建索引
        if err := createIndexes(ctx); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create indexes: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// createIndexes 创建索引
func createIndexes(ctx context.Context) error <span class="cov0" title="0">{
        // Rules 集合索引
        rulesCollection := database.Collection("rules")
        rulesIndexes := []mongo.IndexModel{
                {
                        Keys: bson.D{
                                {Key: "project_id", Value: 1},
                                {Key: "environment_id", Value: 1},
                        },
                },
                {
                        Keys: bson.D{{Key: "protocol", Value: 1}},
                },
                {
                        Keys: bson.D{{Key: "enabled", Value: 1}},
                },
                {
                        Keys: bson.D{{Key: "priority", Value: 1}},
                },
                {
                        Keys: bson.D{{Key: "tags", Value: 1}},
                },
                {
                        Keys: bson.D{{Key: "created_at", Value: 1}},
                },
        }
        if _, err := rulesCollection.Indexes().CreateMany(ctx, rulesIndexes); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Projects 集合索引
        <span class="cov0" title="0">projectsCollection := database.Collection("projects")
        projectsIndexes := []mongo.IndexModel{
                {
                        Keys: bson.D{{Key: "workspace_id", Value: 1}},
                },
        }
        if _, err := projectsCollection.Indexes().CreateMany(ctx, projectsIndexes); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Environments 集合索引
        <span class="cov0" title="0">environmentsCollection := database.Collection("environments")
        environmentsIndexes := []mongo.IndexModel{
                {
                        Keys: bson.D{{Key: "project_id", Value: 1}},
                },
        }
        if _, err := environmentsCollection.Indexes().CreateMany(ctx, environmentsIndexes); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Logs 集合索引(带 TTL)
        <span class="cov0" title="0">logsCollection := database.Collection("logs")
        ttlSeconds := int32(7 * 24 * 60 * 60)
        logsIndexes := []mongo.IndexModel{
                {
                        Keys: bson.D{{Key: "request_id", Value: 1}},
                },
                {
                        Keys: bson.D{{Key: "rule_id", Value: 1}},
                },
                {
                        Keys: bson.D{{Key: "protocol", Value: 1}},
                },
                {
                        Keys:    bson.D{{Key: "timestamp", Value: 1}},
                        Options: &amp;options.IndexOptions{ExpireAfterSeconds: &amp;ttlSeconds}, // 7天过期
                },
                {
                        Keys: bson.D{
                                {Key: "project_id", Value: 1},
                                {Key: "environment_id", Value: 1},
                        },
                },
        }
        if _, err := logsCollection.Indexes().CreateMany(ctx, logsIndexes); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Versions 集合索引
        <span class="cov0" title="0">versionsCollection := database.Collection("versions")
        versionsIndexes := []mongo.IndexModel{
                {
                        Keys: bson.D{{Key: "rule_id", Value: 1}},
                },
                {
                        Keys: bson.D{{Key: "created_at", Value: 1}},
                },
        }
        if _, err := versionsCollection.Indexes().CreateMany(ctx, versionsIndexes); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Users 集合索引
        <span class="cov0" title="0">usersCollection := database.Collection("users")
        unique := true
        usersIndexes := []mongo.IndexModel{
                {
                        Keys:    bson.D{{Key: "username", Value: 1}},
                        Options: &amp;options.IndexOptions{Unique: &amp;unique},
                },
                {
                        Keys:    bson.D{{Key: "email", Value: 1}},
                        Options: &amp;options.IndexOptions{Unique: &amp;unique},
                },
        }
        if _, err := usersCollection.Indexes().CreateMany(ctx, usersIndexes); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetDatabase 获取数据库实例
func GetDatabase() *mongo.Database <span class="cov0" title="0">{
        return database
}</span>

// GetCollection 获取集合
func GetCollection(name string) *mongo.Collection <span class="cov0" title="0">{
        return database.Collection(name)
}</span>

// Close 关闭数据库连接
func Close() error <span class="cov0" title="0">{
        if client != nil </span><span class="cov0" title="0">{
                ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
                defer cancel()
                return client.Disconnect(ctx)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package repository

import (
        "context"
        "time"

        "github.com/gomockserver/mockserver/internal/models"
        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/bson/primitive"
        "go.mongodb.org/mongo-driver/mongo"
        "go.mongodb.org/mongo-driver/mongo/options"
)

// ProjectRepository 项目仓库接口
type ProjectRepository interface {
        Create(ctx context.Context, project *models.Project) error
        Update(ctx context.Context, project *models.Project) error
        Delete(ctx context.Context, id string) error
        FindByID(ctx context.Context, id string) (*models.Project, error)
        FindByWorkspace(ctx context.Context, workspaceID string) ([]*models.Project, error)
        List(ctx context.Context, skip, limit int64) ([]*models.Project, int64, error)
}

type projectRepository struct {
        collection *mongo.Collection
}

// NewProjectRepository 创建项目仓库
func NewProjectRepository() ProjectRepository <span class="cov0" title="0">{
        return &amp;projectRepository{
                collection: GetCollection("projects"),
        }
}</span>

// Create 创建项目
func (r *projectRepository) Create(ctx context.Context, project *models.Project) error <span class="cov0" title="0">{
        project.CreatedAt = time.Now()
        project.UpdatedAt = time.Now()

        result, err := r.collection.InsertOne(ctx, project)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if oid, ok := result.InsertedID.(primitive.ObjectID); ok </span><span class="cov0" title="0">{
                project.ID = oid.Hex()
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Update 更新项目
func (r *projectRepository) Update(ctx context.Context, project *models.Project) error <span class="cov0" title="0">{
        project.UpdatedAt = time.Now()

        objectID, err := primitive.ObjectIDFromHex(project.ID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">filter := bson.M{"_id": objectID}
        // 排除 _id 字段，避免更新不可变字段
        update := bson.M{"$set": bson.M{
                "name":         project.Name,
                "workspace_id": project.WorkspaceID,
                "description":  project.Description,
                "updated_at":   project.UpdatedAt,
        }}

        _, err = r.collection.UpdateOne(ctx, filter, update)
        return err</span>
}

// Delete 删除项目
func (r *projectRepository) Delete(ctx context.Context, id string) error <span class="cov0" title="0">{
        objectID, err := primitive.ObjectIDFromHex(id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">filter := bson.M{"_id": objectID}
        _, err = r.collection.DeleteOne(ctx, filter)
        return err</span>
}

// FindByID 根据ID查找项目
func (r *projectRepository) FindByID(ctx context.Context, id string) (*models.Project, error) <span class="cov0" title="0">{
        objectID, err := primitive.ObjectIDFromHex(id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">filter := bson.M{"_id": objectID}

        var project models.Project
        err = r.collection.FindOne(ctx, filter).Decode(&amp;project)
        if err != nil </span><span class="cov0" title="0">{
                if err == mongo.ErrNoDocuments </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov0" title="0">return &amp;project, nil</span>
}

// FindByWorkspace 查找工作空间下的所有项目
func (r *projectRepository) FindByWorkspace(ctx context.Context, workspaceID string) ([]*models.Project, error) <span class="cov0" title="0">{
        filter := bson.M{"workspace_id": workspaceID}

        cursor, err := r.collection.Find(ctx, filter)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer cursor.Close(ctx)

        var projects []*models.Project
        if err = cursor.All(ctx, &amp;projects); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return projects, nil</span>
}

// List 列出项目（支持分页）
func (r *projectRepository) List(ctx context.Context, skip, limit int64) ([]*models.Project, int64, error) <span class="cov0" title="0">{
        filter := bson.M{}

        // 获取总数
        total, err := r.collection.CountDocuments(ctx, filter)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        // 查询数据
        <span class="cov0" title="0">opts := options.Find().
                SetSkip(skip).
                SetLimit(limit).
                SetSort(bson.D{primitive.E{Key: "created_at", Value: -1}})

        cursor, err := r.collection.Find(ctx, filter, opts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>
        <span class="cov0" title="0">defer cursor.Close(ctx)

        var projects []*models.Project
        if err = cursor.All(ctx, &amp;projects); err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">return projects, total, nil</span>
}

// EnvironmentRepository 环境仓库接口
type EnvironmentRepository interface {
        Create(ctx context.Context, environment *models.Environment) error
        Update(ctx context.Context, environment *models.Environment) error
        Delete(ctx context.Context, id string) error
        FindByID(ctx context.Context, id string) (*models.Environment, error)
        FindByProject(ctx context.Context, projectID string) ([]*models.Environment, error)
}

type environmentRepository struct {
        collection *mongo.Collection
}

// NewEnvironmentRepository 创建环境仓库
func NewEnvironmentRepository() EnvironmentRepository <span class="cov0" title="0">{
        return &amp;environmentRepository{
                collection: GetCollection("environments"),
        }
}</span>

// Create 创建环境
func (r *environmentRepository) Create(ctx context.Context, environment *models.Environment) error <span class="cov0" title="0">{
        environment.CreatedAt = time.Now()
        environment.UpdatedAt = time.Now()

        result, err := r.collection.InsertOne(ctx, environment)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if oid, ok := result.InsertedID.(primitive.ObjectID); ok </span><span class="cov0" title="0">{
                environment.ID = oid.Hex()
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Update 更新环境
func (r *environmentRepository) Update(ctx context.Context, environment *models.Environment) error <span class="cov0" title="0">{
        environment.UpdatedAt = time.Now()

        objectID, err := primitive.ObjectIDFromHex(environment.ID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">filter := bson.M{"_id": objectID}
        // 排除 _id 字段，避免更新不可变字段
        update := bson.M{"$set": bson.M{
                "name":       environment.Name,
                "project_id": environment.ProjectID,
                "base_url":   environment.BaseURL,
                "variables":  environment.Variables,
                "updated_at": environment.UpdatedAt,
        }}

        _, err = r.collection.UpdateOne(ctx, filter, update)
        return err</span>
}

// Delete 删除环境
func (r *environmentRepository) Delete(ctx context.Context, id string) error <span class="cov0" title="0">{
        objectID, err := primitive.ObjectIDFromHex(id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">filter := bson.M{"_id": objectID}
        _, err = r.collection.DeleteOne(ctx, filter)
        return err</span>
}

// FindByID 根据ID查找环境
func (r *environmentRepository) FindByID(ctx context.Context, id string) (*models.Environment, error) <span class="cov0" title="0">{
        objectID, err := primitive.ObjectIDFromHex(id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">filter := bson.M{"_id": objectID}

        var environment models.Environment
        err = r.collection.FindOne(ctx, filter).Decode(&amp;environment)
        if err != nil </span><span class="cov0" title="0">{
                if err == mongo.ErrNoDocuments </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov0" title="0">return &amp;environment, nil</span>
}

// FindByProject 查找项目下的所有环境
func (r *environmentRepository) FindByProject(ctx context.Context, projectID string) ([]*models.Environment, error) <span class="cov0" title="0">{
        filter := bson.M{"project_id": projectID}

        cursor, err := r.collection.Find(ctx, filter)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer cursor.Close(ctx)

        var environments []*models.Environment
        if err = cursor.All(ctx, &amp;environments); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return environments, nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package repository

import (
        "context"
        "time"

        "github.com/gomockserver/mockserver/internal/models"
        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/bson/primitive"
        "go.mongodb.org/mongo-driver/mongo"
        "go.mongodb.org/mongo-driver/mongo/options"
)

// RequestLogRepository 请求日志仓库接口
type RequestLogRepository interface {
        Create(ctx context.Context, log *models.RequestLog) error
        FindByID(ctx context.Context, id string) (*models.RequestLog, error)
        List(ctx context.Context, filter RequestLogFilter) ([]*models.RequestLog, int64, error)
        DeleteBefore(ctx context.Context, before time.Time) (int64, error)
        DeleteByProjectID(ctx context.Context, projectID string) error
        CountByProjectID(ctx context.Context, projectID string, startTime, endTime time.Time) (int64, error)
        GetStatistics(ctx context.Context, projectID, environmentID string, startTime, endTime time.Time) (*RequestLogStatistics, error)
}

// RequestLogFilter 请求日志查询过滤器
type RequestLogFilter struct {
        ProjectID     string
        EnvironmentID string
        RuleID        string
        Protocol      models.ProtocolType
        Method        string
        Path          string
        StatusCode    int
        SourceIP      string
        StartTime     time.Time
        EndTime       time.Time
        Page          int
        PageSize      int
        SortBy        string
        SortOrder     int // 1: asc, -1: desc
}

// RequestLogStatistics 请求日志统计信息
type RequestLogStatistics struct {
        TotalRequests   int64              `json:"total_requests"`
        SuccessRequests int64              `json:"success_requests"`
        ErrorRequests   int64              `json:"error_requests"`
        AvgDuration     float64            `json:"avg_duration"`
        MaxDuration     int64              `json:"max_duration"`
        MinDuration     int64              `json:"min_duration"`
        ProtocolStats   map[string]int64   `json:"protocol_stats"`
        StatusCodeStats map[string]int64   `json:"status_code_stats"`
        TopPaths        []PathStat         `json:"top_paths"`
        TopRules        []RuleStat         `json:"top_rules"`
        HourlyStats     []HourlyStat       `json:"hourly_stats"`
}

// PathStat 路径统计
type PathStat struct {
        Path  string `json:"path"`
        Count int64  `json:"count"`
}

// RuleStat 规则统计
type RuleStat struct {
        RuleID string `json:"rule_id"`
        Count  int64  `json:"count"`
}

// HourlyStat 小时统计
type HourlyStat struct {
        Hour  string `json:"hour"`
        Count int64  `json:"count"`
}

type mongoRequestLogRepository struct {
        collection *mongo.Collection
}

// NewMongoRequestLogRepository 创建 MongoDB 请求日志仓库
func NewMongoRequestLogRepository(db *mongo.Database) RequestLogRepository <span class="cov8" title="1">{
        return &amp;mongoRequestLogRepository{
                collection: db.Collection("request_logs"),
        }
}</span>

// EnsureIndexes 创建索引
func (r *mongoRequestLogRepository) EnsureIndexes(ctx context.Context) error <span class="cov0" title="0">{
        indexes := []mongo.IndexModel{
                {
                        Keys: bson.D{
                                {Key: "timestamp", Value: -1},
                                {Key: "project_id", Value: 1},
                                {Key: "environment_id", Value: 1},
                        },
                },
                {
                        Keys: bson.D{{Key: "request_id", Value: 1}},
                        Options: options.Index().SetUnique(true),
                },
                {
                        Keys: bson.D{{Key: "rule_id", Value: 1}},
                },
                {
                        Keys: bson.D{{Key: "status_code", Value: 1}},
                },
                {
                        Keys: bson.D{{Key: "source_ip", Value: 1}},
                },
                {
                        Keys: bson.D{{Key: "protocol", Value: 1}},
                },
                {
                        Keys: bson.D{{Key: "timestamp", Value: 1}},
                        Options: options.Index().SetExpireAfterSeconds(7 * 24 * 60 * 60), // 7天自动过期
                },
        }

        _, err := r.collection.Indexes().CreateMany(ctx, indexes)
        return err
}</span>

// Create 创建请求日志
func (r *mongoRequestLogRepository) Create(ctx context.Context, log *models.RequestLog) error <span class="cov8" title="1">{
        if log.ID == "" </span><span class="cov8" title="1">{
                log.ID = primitive.NewObjectID().Hex()
        }</span>
        <span class="cov8" title="1">if log.Timestamp.IsZero() </span><span class="cov8" title="1">{
                log.Timestamp = time.Now()
        }</span>
        
        <span class="cov8" title="1">_, err := r.collection.InsertOne(ctx, log)
        return err</span>
}

// FindByID 根据 ID 查询请求日志
func (r *mongoRequestLogRepository) FindByID(ctx context.Context, id string) (*models.RequestLog, error) <span class="cov8" title="1">{
        var log models.RequestLog
        err := r.collection.FindOne(ctx, bson.M{"_id": id}).Decode(&amp;log)
        if err != nil </span><span class="cov8" title="1">{
                if err == mongo.ErrNoDocuments </span><span class="cov8" title="1">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov8" title="1">return &amp;log, nil</span>
}

// List 列表查询请求日志
func (r *mongoRequestLogRepository) List(ctx context.Context, filter RequestLogFilter) ([]*models.RequestLog, int64, error) <span class="cov8" title="1">{
        // 构建查询条件
        query := bson.M{}
        
        if filter.ProjectID != "" </span><span class="cov8" title="1">{
                query["project_id"] = filter.ProjectID
        }</span>
        <span class="cov8" title="1">if filter.EnvironmentID != "" </span><span class="cov0" title="0">{
                query["environment_id"] = filter.EnvironmentID
        }</span>
        <span class="cov8" title="1">if filter.RuleID != "" </span><span class="cov0" title="0">{
                query["rule_id"] = filter.RuleID
        }</span>
        <span class="cov8" title="1">if filter.Protocol != "" </span><span class="cov8" title="1">{
                query["protocol"] = filter.Protocol
        }</span>
        <span class="cov8" title="1">if filter.Method != "" </span><span class="cov8" title="1">{
                query["method"] = filter.Method
        }</span>
        <span class="cov8" title="1">if filter.Path != "" </span><span class="cov0" title="0">{
                query["path"] = bson.M{"$regex": filter.Path}
        }</span>
        <span class="cov8" title="1">if filter.StatusCode &gt; 0 </span><span class="cov0" title="0">{
                query["status_code"] = filter.StatusCode
        }</span>
        <span class="cov8" title="1">if filter.SourceIP != "" </span><span class="cov0" title="0">{
                query["source_ip"] = filter.SourceIP
        }</span>
        <span class="cov8" title="1">if !filter.StartTime.IsZero() || !filter.EndTime.IsZero() </span><span class="cov0" title="0">{
                timeQuery := bson.M{}
                if !filter.StartTime.IsZero() </span><span class="cov0" title="0">{
                        timeQuery["$gte"] = filter.StartTime
                }</span>
                <span class="cov0" title="0">if !filter.EndTime.IsZero() </span><span class="cov0" title="0">{
                        timeQuery["$lte"] = filter.EndTime
                }</span>
                <span class="cov0" title="0">query["timestamp"] = timeQuery</span>
        }

        // 统计总数
        <span class="cov8" title="1">total, err := r.collection.CountDocuments(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        // 分页和排序
        <span class="cov8" title="1">opts := options.Find()
        if filter.Page &gt; 0 &amp;&amp; filter.PageSize &gt; 0 </span><span class="cov8" title="1">{
                skip := int64((filter.Page - 1) * filter.PageSize)
                limit := int64(filter.PageSize)
                opts.SetSkip(skip).SetLimit(limit)
        }</span>

        <span class="cov8" title="1">sortBy := "timestamp"
        if filter.SortBy != "" </span><span class="cov0" title="0">{
                sortBy = filter.SortBy
        }</span>
        <span class="cov8" title="1">sortOrder := -1
        if filter.SortOrder != 0 </span><span class="cov0" title="0">{
                sortOrder = filter.SortOrder
        }</span>
        <span class="cov8" title="1">opts.SetSort(bson.D{{Key: sortBy, Value: sortOrder}})

        // 查询
        cursor, err := r.collection.Find(ctx, query, opts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>
        <span class="cov8" title="1">defer cursor.Close(ctx)

        var logs []*models.RequestLog
        if err = cursor.All(ctx, &amp;logs); err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov8" title="1">return logs, total, nil</span>
}

// DeleteBefore 删除指定时间之前的日志
func (r *mongoRequestLogRepository) DeleteBefore(ctx context.Context, before time.Time) (int64, error) <span class="cov8" title="1">{
        result, err := r.collection.DeleteMany(ctx, bson.M{
                "timestamp": bson.M{"$lt": before},
        })
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov8" title="1">return result.DeletedCount, nil</span>
}

// DeleteByProjectID 删除指定项目的所有日志
func (r *mongoRequestLogRepository) DeleteByProjectID(ctx context.Context, projectID string) error <span class="cov0" title="0">{
        _, err := r.collection.DeleteMany(ctx, bson.M{"project_id": projectID})
        return err
}</span>

// CountByProjectID 统计指定项目的日志数量
func (r *mongoRequestLogRepository) CountByProjectID(ctx context.Context, projectID string, startTime, endTime time.Time) (int64, error) <span class="cov0" title="0">{
        query := bson.M{"project_id": projectID}
        
        if !startTime.IsZero() || !endTime.IsZero() </span><span class="cov0" title="0">{
                timeQuery := bson.M{}
                if !startTime.IsZero() </span><span class="cov0" title="0">{
                        timeQuery["$gte"] = startTime
                }</span>
                <span class="cov0" title="0">if !endTime.IsZero() </span><span class="cov0" title="0">{
                        timeQuery["$lte"] = endTime
                }</span>
                <span class="cov0" title="0">query["timestamp"] = timeQuery</span>
        }

        <span class="cov0" title="0">return r.collection.CountDocuments(ctx, query)</span>
}

// GetStatistics 获取统计信息
func (r *mongoRequestLogRepository) GetStatistics(ctx context.Context, projectID, environmentID string, startTime, endTime time.Time) (*RequestLogStatistics, error) <span class="cov8" title="1">{
        matchStage := bson.M{}
        if projectID != "" </span><span class="cov8" title="1">{
                matchStage["project_id"] = projectID
        }</span>
        <span class="cov8" title="1">if environmentID != "" </span><span class="cov8" title="1">{
                matchStage["environment_id"] = environmentID
        }</span>
        <span class="cov8" title="1">if !startTime.IsZero() || !endTime.IsZero() </span><span class="cov8" title="1">{
                timeQuery := bson.M{}
                if !startTime.IsZero() </span><span class="cov8" title="1">{
                        timeQuery["$gte"] = startTime
                }</span>
                <span class="cov8" title="1">if !endTime.IsZero() </span><span class="cov8" title="1">{
                        timeQuery["$lte"] = endTime
                }</span>
                <span class="cov8" title="1">matchStage["timestamp"] = timeQuery</span>
        }

        <span class="cov8" title="1">stats := &amp;RequestLogStatistics{
                ProtocolStats:   make(map[string]int64),
                StatusCodeStats: make(map[string]int64),
                TopPaths:        []PathStat{},
                TopRules:        []RuleStat{},
                HourlyStats:     []HourlyStat{},
        }

        // 基础统计
        pipeline := mongo.Pipeline{
                {{Key: "$match", Value: matchStage}},
                {{Key: "$group", Value: bson.M{
                        "_id":             nil,
                        "total_requests":  bson.M{"$sum": 1},
                        "success_count":   bson.M{"$sum": bson.M{"$cond": []interface{}{bson.M{"$and": []interface{}{bson.M{"$gte": []interface{}{"$status_code", 200}}, bson.M{"$lt": []interface{}{"$status_code", 400}}}}, 1, 0}}},
                        "error_count":     bson.M{"$sum": bson.M{"$cond": []interface{}{bson.M{"$gte": []interface{}{"$status_code", 400}}, 1, 0}}},
                        "avg_duration":    bson.M{"$avg": "$duration"},
                        "max_duration":    bson.M{"$max": "$duration"},
                        "min_duration":    bson.M{"$min": "$duration"},
                }}},
        }

        cursor, err := r.collection.Aggregate(ctx, pipeline)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer cursor.Close(ctx)

        if cursor.Next(ctx) </span><span class="cov8" title="1">{
                var result struct {
                        TotalRequests  int64   `bson:"total_requests"`
                        SuccessCount   int64   `bson:"success_count"`
                        ErrorCount     int64   `bson:"error_count"`
                        AvgDuration    float64 `bson:"avg_duration"`
                        MaxDuration    int64   `bson:"max_duration"`
                        MinDuration    int64   `bson:"min_duration"`
                }
                if err := cursor.Decode(&amp;result); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">stats.TotalRequests = result.TotalRequests
                stats.SuccessRequests = result.SuccessCount
                stats.ErrorRequests = result.ErrorCount
                stats.AvgDuration = result.AvgDuration
                stats.MaxDuration = result.MaxDuration
                stats.MinDuration = result.MinDuration</span>
        }

        // 协议统计
        <span class="cov8" title="1">protocolPipeline := mongo.Pipeline{
                {{Key: "$match", Value: matchStage}},
                {{Key: "$group", Value: bson.M{
                        "_id":   "$protocol",
                        "count": bson.M{"$sum": 1},
                }}},
        }
        protocolCursor, err := r.collection.Aggregate(ctx, protocolPipeline)
        if err == nil </span><span class="cov8" title="1">{
                defer protocolCursor.Close(ctx)
                for protocolCursor.Next(ctx) </span><span class="cov8" title="1">{
                        var result struct {
                                Protocol string `bson:"_id"`
                                Count    int64  `bson:"count"`
                        }
                        if err := protocolCursor.Decode(&amp;result); err == nil </span><span class="cov8" title="1">{
                                stats.ProtocolStats[result.Protocol] = result.Count
                        }</span>
                }
        }

        // 状态码统计
        <span class="cov8" title="1">statusPipeline := mongo.Pipeline{
                {{Key: "$match", Value: matchStage}},
                {{Key: "$group", Value: bson.M{
                        "_id":   "$status_code",
                        "count": bson.M{"$sum": 1},
                }}},
        }
        statusCursor, err := r.collection.Aggregate(ctx, statusPipeline)
        if err == nil </span><span class="cov8" title="1">{
                defer statusCursor.Close(ctx)
                for statusCursor.Next(ctx) </span><span class="cov8" title="1">{
                        var result struct {
                                StatusCode int   `bson:"_id"`
                                Count      int64 `bson:"count"`
                        }
                        if err := statusCursor.Decode(&amp;result); err == nil </span><span class="cov8" title="1">{
                                stats.StatusCodeStats[string(rune(result.StatusCode+'0'))] = result.Count
                        }</span>
                }
        }

        <span class="cov8" title="1">return stats, nil</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package repository

import (
        "context"
        "time"

        "github.com/gomockserver/mockserver/internal/models"
        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/bson/primitive"
        "go.mongodb.org/mongo-driver/mongo"
        "go.mongodb.org/mongo-driver/mongo/options"
)

// RuleRepository 规则仓库接口
type RuleRepository interface {
        Create(ctx context.Context, rule *models.Rule) error
        Update(ctx context.Context, rule *models.Rule) error
        Delete(ctx context.Context, id string) error
        FindByID(ctx context.Context, id string) (*models.Rule, error)
        FindByEnvironment(ctx context.Context, projectID, environmentID string) ([]*models.Rule, error)
        FindEnabledByEnvironment(ctx context.Context, projectID, environmentID string) ([]*models.Rule, error)
        List(ctx context.Context, filter map[string]interface{}, skip, limit int64) ([]*models.Rule, int64, error)
}

type ruleRepository struct {
        collection *mongo.Collection
}

// NewRuleRepository 创建规则仓库
func NewRuleRepository() RuleRepository <span class="cov0" title="0">{
        return &amp;ruleRepository{
                collection: GetCollection("rules"),
        }
}</span>

// Create 创建规则
func (r *ruleRepository) Create(ctx context.Context, rule *models.Rule) error <span class="cov0" title="0">{
        rule.CreatedAt = time.Now()
        rule.UpdatedAt = time.Now()

        result, err := r.collection.InsertOne(ctx, rule)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if oid, ok := result.InsertedID.(primitive.ObjectID); ok </span><span class="cov0" title="0">{
                rule.ID = oid.Hex()
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Update 更新规则
func (r *ruleRepository) Update(ctx context.Context, rule *models.Rule) error <span class="cov0" title="0">{
        rule.UpdatedAt = time.Now()

        objectID, err := primitive.ObjectIDFromHex(rule.ID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">filter := bson.M{"_id": objectID}
        // 排除 _id 字段，避免更新不可变字段
        update := bson.M{"$set": bson.M{
                "name":            rule.Name,
                "project_id":      rule.ProjectID,
                "environment_id":  rule.EnvironmentID,
                "protocol":        rule.Protocol,
                "match_type":      rule.MatchType,
                "priority":        rule.Priority,
                "enabled":         rule.Enabled,
                "match_condition": rule.MatchCondition,
                "response":        rule.Response,
                "tags":            rule.Tags,
                "creator":         rule.Creator,
                "updated_at":      rule.UpdatedAt,
        }}

        _, err = r.collection.UpdateOne(ctx, filter, update)
        return err</span>
}

// Delete 删除规则
func (r *ruleRepository) Delete(ctx context.Context, id string) error <span class="cov0" title="0">{
        objectID, err := primitive.ObjectIDFromHex(id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">filter := bson.M{"_id": objectID}
        _, err = r.collection.DeleteOne(ctx, filter)
        return err</span>
}

// FindByID 根据ID查找规则
func (r *ruleRepository) FindByID(ctx context.Context, id string) (*models.Rule, error) <span class="cov0" title="0">{
        objectID, err := primitive.ObjectIDFromHex(id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">filter := bson.M{"_id": objectID}

        var rule models.Rule
        err = r.collection.FindOne(ctx, filter).Decode(&amp;rule)
        if err != nil </span><span class="cov0" title="0">{
                if err == mongo.ErrNoDocuments </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov0" title="0">return &amp;rule, nil</span>
}

// FindByEnvironment 查找环境下的所有规则
func (r *ruleRepository) FindByEnvironment(ctx context.Context, projectID, environmentID string) ([]*models.Rule, error) <span class="cov0" title="0">{
        filter := bson.M{
                "project_id":     projectID,
                "environment_id": environmentID,
        }

        opts := options.Find().SetSort(bson.D{{Key: "priority", Value: -1}})

        cursor, err := r.collection.Find(ctx, filter, opts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer cursor.Close(ctx)

        var rules []*models.Rule
        if err = cursor.All(ctx, &amp;rules); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return rules, nil</span>
}

// FindEnabledByEnvironment 查找环境下所有启用的规则
func (r *ruleRepository) FindEnabledByEnvironment(ctx context.Context, projectID, environmentID string) ([]*models.Rule, error) <span class="cov0" title="0">{
        filter := bson.M{
                "project_id":     projectID,
                "environment_id": environmentID,
                "enabled":        true,
        }

        opts := options.Find().SetSort(bson.D{{Key: "priority", Value: -1}})

        cursor, err := r.collection.Find(ctx, filter, opts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer cursor.Close(ctx)

        var rules []*models.Rule
        if err = cursor.All(ctx, &amp;rules); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return rules, nil</span>
}

// List 列出规则（支持分页和过滤）
func (r *ruleRepository) List(ctx context.Context, filter map[string]interface{}, skip, limit int64) ([]*models.Rule, int64, error) <span class="cov0" title="0">{
        // 转换过滤条件
        mongoFilter := bson.M{}
        for k, v := range filter </span><span class="cov0" title="0">{
                mongoFilter[k] = v
        }</span>

        // 获取总数
        <span class="cov0" title="0">total, err := r.collection.CountDocuments(ctx, mongoFilter)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        // 查询数据
        <span class="cov0" title="0">opts := options.Find().
                SetSkip(skip).
                SetLimit(limit).
                SetSort(bson.D{{Key: "created_at", Value: -1}})

        cursor, err := r.collection.Find(ctx, mongoFilter, opts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>
        <span class="cov0" title="0">defer cursor.Close(ctx)

        var rules []*models.Rule
        if err = cursor.All(ctx, &amp;rules); err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">return rules, total, nil</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package service

import (
        "runtime"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/gomockserver/mockserver/internal/api"
        "github.com/gomockserver/mockserver/internal/middleware"
        "github.com/gomockserver/mockserver/internal/models"
        "github.com/gomockserver/mockserver/pkg/logger"
        "go.uber.org/zap"
)

// AdminService 管理服务
type AdminService struct {
        ruleHandler         *api.RuleHandler
        projectHandler      *api.ProjectHandler
        statisticsHandler   *api.StatisticsHandler
        mockHandler         *api.MockHandler
        importExportService ImportExportService
}

// NewAdminService 创建管理服务
func NewAdminService(
        ruleHandler *api.RuleHandler,
        projectHandler *api.ProjectHandler,
        statisticsHandler *api.StatisticsHandler,
        importExportService ImportExportService,
) *AdminService <span class="cov8" title="1">{
        return &amp;AdminService{
                ruleHandler:         ruleHandler,
                projectHandler:      projectHandler,
                statisticsHandler:   statisticsHandler,
                mockHandler:         api.NewMockHandler(),
                importExportService: importExportService,
        }
}</span>

// StartAdminServer 启动管理服务器
func StartAdminServer(addr string, service *AdminService) error <span class="cov0" title="0">{
        gin.SetMode(gin.ReleaseMode)
        r := gin.New()
        r.Use(gin.Recovery())
        // 使用新的 CORS 中间件
        r.Use(middleware.CORS())

        // API 路由组
        v1 := r.Group("/api/v1")
        </span><span class="cov0" title="0">{
                // 规则管理 API
                rules := v1.Group("/rules")
                </span><span class="cov0" title="0">{
                        rules.GET("", service.ruleHandler.ListRules)
                        rules.POST("", service.ruleHandler.CreateRule)
                        rules.GET("/:id", service.ruleHandler.GetRule)
                        rules.PUT("/:id", service.ruleHandler.UpdateRule)
                        rules.DELETE("/:id", service.ruleHandler.DeleteRule)
                        rules.POST("/:id/enable", service.ruleHandler.EnableRule)
                        rules.POST("/:id/disable", service.ruleHandler.DisableRule)
                }</span>

                // 项目管理 API
                <span class="cov0" title="0">projects := v1.Group("/projects")
                </span><span class="cov0" title="0">{
                        projects.GET("", service.projectHandler.ListProjects)
                        projects.POST("", service.projectHandler.CreateProject)
                        projects.GET("/:id", service.projectHandler.GetProject)
                        projects.PUT("/:id", service.projectHandler.UpdateProject)
                        projects.DELETE("/:id", service.projectHandler.DeleteProject)
                        
                        // 环境管理 API (在项目下)
                        environments := projects.Group("/:id/environments")
                        </span><span class="cov0" title="0">{
                                environments.GET("", service.projectHandler.ListEnvironments)
                                environments.POST("", service.projectHandler.CreateEnvironment)
                                environments.GET("/:env_id", service.projectHandler.GetEnvironment)
                                environments.PUT("/:env_id", service.projectHandler.UpdateEnvironment)
                                environments.DELETE("/:env_id", service.projectHandler.DeleteEnvironment)
                        }</span>
                }

                // 系统管理 API
                <span class="cov0" title="0">system := v1.Group("/system")
                </span><span class="cov0" title="0">{
                        system.GET("/health", HealthCheck)
                        system.GET("/version", GetVersion)
                        system.GET("/info", GetSystemInfo)
                }</span>

                // 统计 API
                <span class="cov0" title="0">statistics := v1.Group("/statistics")
                </span><span class="cov0" title="0">{
                        statistics.GET("/dashboard", service.getDashboardStatistics)
                        statistics.GET("/projects", service.getProjectStatistics)
                        statistics.GET("/rules", service.getRuleStatistics)
                        statistics.GET("/request-trend", service.getRequestTrend)
                        statistics.GET("/response-time-distribution", service.getResponseTimeDistribution)
                }</span>

                // Mock API
                <span class="cov0" title="0">mock := v1.Group("/mock")
                </span><span class="cov0" title="0">{
                        mock.POST("/test", service.mockHandler.SendMockRequest)
                        mock.GET("/history", service.mockHandler.GetMockHistory)
                        mock.DELETE("/history", service.mockHandler.ClearMockHistory)
                        mock.DELETE("/history/:id", service.mockHandler.DeleteMockHistoryItem)
                }</span>

                // 导入导出 API
                <span class="cov0" title="0">if service.importExportService != nil </span><span class="cov0" title="0">{
                        importExport := v1.Group("/import-export")
                        </span><span class="cov0" title="0">{
                                importExport.GET("/projects/:id/export", service.ExportProject)
                                importExport.POST("/rules/export", service.ExportRules)
                                importExport.POST("/import", service.ImportData)
                                importExport.POST("/validate", service.ValidateImportData)
                        }</span>
                }
        }

        <span class="cov0" title="0">logger.Info("starting admin server", zap.String("address", addr))
        return r.Run(addr)</span>
}

var startTime = time.Now()

func HealthCheck(c *gin.Context) <span class="cov8" title="1">{
        uptime := time.Since(startTime).Seconds()
        c.JSON(200, gin.H{
                "status":   "healthy",
                "database": true,
                "cache":    true,
                "uptime":   int(uptime),
        })
}</span>

func GetVersion(c *gin.Context) <span class="cov8" title="1">{
        c.JSON(200, gin.H{
                "version": "0.6.0",
                "name":    "MockServer",
        })
}</span>

func GetSystemInfo(c *gin.Context) <span class="cov8" title="1">{
        c.JSON(200, gin.H{
                "version":          "0.6.0",
                "build_time":       "2025-11-18",
                "go_version":       runtime.Version(),
                "admin_api_url":    "http://localhost:8080/api/v1",
                "mock_service_url": "http://localhost:9090",
        })
}</span>

// ExportProject 导出项目
func (s *AdminService) ExportProject(c *gin.Context) <span class="cov0" title="0">{
        projectID := c.Param("id")
        if projectID == "" </span><span class="cov0" title="0">{
                c.JSON(400, gin.H{"error": "project_id is required"})
                return
        }</span>

        <span class="cov0" title="0">includeMetadata := c.DefaultQuery("include_metadata", "false") == "true"

        exportData, err := s.importExportService.ExportProject(c.Request.Context(), projectID, includeMetadata)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to export project", zap.String("project_id", projectID), zap.Error(err))
                c.JSON(500, gin.H{"error": "failed to export project: " + err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(200, exportData)</span>
}

// ExportRules 导出规则
func (s *AdminService) ExportRules(c *gin.Context) <span class="cov0" title="0">{
        var req models.ExportRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(400, gin.H{"error": "invalid request: " + err.Error()})
                return
        }</span>

        <span class="cov0" title="0">exportData, err := s.importExportService.ExportRules(c.Request.Context(), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to export rules", zap.Error(err))
                c.JSON(500, gin.H{"error": "failed to export rules: " + err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(200, exportData)</span>
}

// ImportData 导入数据
func (s *AdminService) ImportData(c *gin.Context) <span class="cov0" title="0">{
        var req models.ImportRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(400, gin.H{"error": "invalid request: " + err.Error()})
                return
        }</span>

        // 设置默认策略
        <span class="cov0" title="0">if req.Strategy == "" </span><span class="cov0" title="0">{
                req.Strategy = models.ImportStrategySkip
        }</span>

        <span class="cov0" title="0">result, err := s.importExportService.ImportData(c.Request.Context(), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to import data", zap.Error(err))
                c.JSON(500, gin.H{"error": "failed to import data: " + err.Error()})
                return
        }</span>

        // 根据结果返回适当的状态码
        <span class="cov0" title="0">statusCode := 200
        if !result.Success </span><span class="cov0" title="0">{
                statusCode = 207 // 部分成功
        }</span>

        <span class="cov0" title="0">c.JSON(statusCode, result)</span>
}

// ValidateImportData 验证导入数据
func (s *AdminService) ValidateImportData(c *gin.Context) <span class="cov0" title="0">{
        var data models.ExportData
        if err := c.ShouldBindJSON(&amp;data); err != nil </span><span class="cov0" title="0">{
                c.JSON(400, gin.H{"error": "invalid data format: " + err.Error()})
                return
        }</span>

        <span class="cov0" title="0">if err := s.importExportService.ValidateImportData(c.Request.Context(), &amp;data); err != nil </span><span class="cov0" title="0">{
                c.JSON(400, gin.H{"error": "validation failed: " + err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(200, gin.H{
                "message": "validation successful",
                "data": gin.H{
                        "rule_count":        len(data.Data.Rules),
                        "environment_count": len(data.Data.Environments),
                        "has_project":       data.Data.Project != nil,
                },
        })</span>
}

// getDashboardStatistics 获取仪表盘统计数据
func (s *AdminService) getDashboardStatistics(c *gin.Context) <span class="cov0" title="0">{
        // 这里返回模拟数据，实际应该从数据库查询
        c.JSON(200, gin.H{
                "total_projects":     0,
                "total_environments": 0,
                "total_rules":        0,
                "total_requests":     0,
                "enabled_rules":      0,
                "disabled_rules":     0,
                "requests_today":     0,
        })
}</span>

// getProjectStatistics 获取项目统计
func (s *AdminService) getProjectStatistics(c *gin.Context) <span class="cov0" title="0">{
        // 返回空数组，实际应该从数据库查询
        c.JSON(200, []interface{}{})
}</span>

// getRuleStatistics 获取规则统计
func (s *AdminService) getRuleStatistics(c *gin.Context) <span class="cov0" title="0">{
        // 返回空数组，实际应该从数据库查询
        c.JSON(200, []interface{}{})
}</span>

// getRequestTrend 获取请求趋势
func (s *AdminService) getRequestTrend(c *gin.Context) <span class="cov0" title="0">{
        // 返回空数组，实际应该从数据库查询
        c.JSON(200, []interface{}{})
}</span>

// getResponseTimeDistribution 获取响应时间分布
func (s *AdminService) getResponseTimeDistribution(c *gin.Context) <span class="cov0" title="0">{
        // 返回空数组，实际应该从数据库查询
        c.JSON(200, []interface{}{})
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">package service

import (
        "context"
        "fmt"

        "github.com/gomockserver/mockserver/internal/models"
        "github.com/gomockserver/mockserver/internal/repository"
        "go.uber.org/zap"
)

// BatchOperationService 批量操作服务接口
type BatchOperationService interface {
        // BatchEnable 批量启用规则
        BatchEnable(ctx context.Context, ruleIDs []string) (*models.BatchOperationResult, error)
        // BatchDisable 批量禁用规则
        BatchDisable(ctx context.Context, ruleIDs []string) (*models.BatchOperationResult, error)
        // BatchDelete 批量删除规则
        BatchDelete(ctx context.Context, ruleIDs []string) (*models.BatchOperationResult, error)
        // BatchUpdate 批量更新规则
        BatchUpdate(ctx context.Context, ruleIDs []string, updates map[string]interface{}) (*models.BatchOperationResult, error)
}

type batchOperationService struct {
        ruleRepo repository.RuleRepository
        logger   *zap.Logger
}

// NewBatchOperationService 创建批量操作服务
func NewBatchOperationService(ruleRepo repository.RuleRepository, logger *zap.Logger) BatchOperationService <span class="cov8" title="1">{
        return &amp;batchOperationService{
                ruleRepo: ruleRepo,
                logger:   logger,
        }
}</span>

// BatchEnable 批量启用规则
func (s *batchOperationService) BatchEnable(ctx context.Context, ruleIDs []string) (*models.BatchOperationResult, error) <span class="cov8" title="1">{
        return s.batchUpdateEnabled(ctx, ruleIDs, true)
}</span>

// BatchDisable 批量禁用规则
func (s *batchOperationService) BatchDisable(ctx context.Context, ruleIDs []string) (*models.BatchOperationResult, error) <span class="cov8" title="1">{
        return s.batchUpdateEnabled(ctx, ruleIDs, false)
}</span>

// batchUpdateEnabled 批量更新启用状态
func (s *batchOperationService) batchUpdateEnabled(ctx context.Context, ruleIDs []string, enabled bool) (*models.BatchOperationResult, error) <span class="cov8" title="1">{
        result := &amp;models.BatchOperationResult{
                TotalCount:   len(ruleIDs),
                SuccessCount: 0,
                FailedCount:  0,
                FailedIDs:    []string{},
                Errors:       []string{},
        }

        for _, ruleID := range ruleIDs </span><span class="cov8" title="1">{
                rule, err := s.ruleRepo.FindByID(ctx, ruleID)
                if err != nil </span><span class="cov8" title="1">{
                        s.handleError(result, ruleID, models.ErrBatchOperationFailed.Message)
                        continue</span>
                }
                <span class="cov8" title="1">if rule == nil </span><span class="cov8" title="1">{
                        s.handleError(result, ruleID, models.ErrRuleNotFound.Message)
                        continue</span>
                }

                <span class="cov8" title="1">rule.Enabled = enabled
                if err := s.ruleRepo.Update(ctx, rule); err != nil </span><span class="cov8" title="1">{
                        s.handleError(result, ruleID, models.ErrBatchOperationFailed.Message)
                        continue</span>
                }

                <span class="cov8" title="1">result.SuccessCount++
                s.logger.Info("Updated rule enabled status",
                        zap.String("rule_id", ruleID),
                        zap.Bool("enabled", enabled),
                )</span>
        }

        <span class="cov8" title="1">result.Success = result.FailedCount == 0
        return result, nil</span>
}

// BatchDelete 批量删除规则
func (s *batchOperationService) BatchDelete(ctx context.Context, ruleIDs []string) (*models.BatchOperationResult, error) <span class="cov8" title="1">{
        result := &amp;models.BatchOperationResult{
                TotalCount:   len(ruleIDs),
                SuccessCount: 0,
                FailedCount:  0,
                FailedIDs:    []string{},
                Errors:       []string{},
        }

        for _, ruleID := range ruleIDs </span><span class="cov8" title="1">{
                if err := s.ruleRepo.Delete(ctx, ruleID); err != nil </span><span class="cov8" title="1">{
                        s.handleError(result, ruleID, models.ErrBatchOperationFailed.Message)
                        continue</span>
                }

                <span class="cov8" title="1">result.SuccessCount++
                s.logger.Info("Deleted rule", zap.String("rule_id", ruleID))</span>
        }

        <span class="cov8" title="1">result.Success = result.FailedCount == 0
        return result, nil</span>
}

// BatchUpdate 批量更新规则
func (s *batchOperationService) BatchUpdate(ctx context.Context, ruleIDs []string, updates map[string]interface{}) (*models.BatchOperationResult, error) <span class="cov8" title="1">{
        result := &amp;models.BatchOperationResult{
                TotalCount:   len(ruleIDs),
                SuccessCount: 0,
                FailedCount:  0,
                FailedIDs:    []string{},
                Errors:       []string{},
        }

        // 验证更新字段
        allowedFields := map[string]bool{
                "priority": true,
                "tags":     true,
                "enabled":  true,
        }

        for field := range updates </span><span class="cov8" title="1">{
                if !allowedFields[field] </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("%s: field '%s' is not allowed for batch update", models.ErrBatchInvalidInput.Message, field)
                }</span>
        }

        <span class="cov8" title="1">for _, ruleID := range ruleIDs </span><span class="cov8" title="1">{
                rule, err := s.ruleRepo.FindByID(ctx, ruleID)
                if err != nil </span><span class="cov0" title="0">{
                        s.handleError(result, ruleID, models.ErrBatchOperationFailed.Message)
                        continue</span>
                }
                <span class="cov8" title="1">if rule == nil </span><span class="cov0" title="0">{
                        s.handleError(result, ruleID, models.ErrRuleNotFound.Message)
                        continue</span>
                }

                // 应用更新
                <span class="cov8" title="1">if priority, ok := updates["priority"].(int); ok </span><span class="cov8" title="1">{
                        rule.Priority = priority
                }</span>
                <span class="cov8" title="1">if priority, ok := updates["priority"].(float64); ok </span><span class="cov8" title="1">{
                        rule.Priority = int(priority)
                }</span>
                <span class="cov8" title="1">if tags, ok := updates["tags"].([]string); ok </span><span class="cov8" title="1">{
                        rule.Tags = tags
                }</span>
                <span class="cov8" title="1">if tagsInterface, ok := updates["tags"].([]interface{}); ok </span><span class="cov8" title="1">{
                        tags := make([]string, len(tagsInterface))
                        for i, t := range tagsInterface </span><span class="cov8" title="1">{
                                if str, ok := t.(string); ok </span><span class="cov8" title="1">{
                                        tags[i] = str
                                }</span>
                        }
                        <span class="cov8" title="1">rule.Tags = tags</span>
                }
                <span class="cov8" title="1">if enabled, ok := updates["enabled"].(bool); ok </span><span class="cov8" title="1">{
                        rule.Enabled = enabled
                }</span>

                <span class="cov8" title="1">if err := s.ruleRepo.Update(ctx, rule); err != nil </span><span class="cov0" title="0">{
                        s.handleError(result, ruleID, models.ErrBatchOperationFailed.Message)
                        continue</span>
                }

                <span class="cov8" title="1">result.SuccessCount++
                s.logger.Info("Batch updated rule", zap.String("rule_id", ruleID))</span>
        }

        <span class="cov8" title="1">result.Success = result.FailedCount == 0
        return result, nil</span>
}

// handleError 处理错误
func (s *batchOperationService) handleError(result *models.BatchOperationResult, ruleID string, errorMsg string) <span class="cov8" title="1">{
        result.FailedCount++
        result.FailedIDs = append(result.FailedIDs, ruleID)
        result.Errors = append(result.Errors, errorMsg)
        s.logger.Error("Batch operation failed", zap.String("rule_id", ruleID), zap.String("error", errorMsg))
}</span>

// ExecuteBatchOperation 执行批量操作（统一入口）
func ExecuteBatchOperation(
        ctx context.Context,
        service BatchOperationService,
        req *models.BatchOperationRequest,
) (*models.BatchOperationResult, error) <span class="cov8" title="1">{
        if len(req.RuleIDs) == 0 </span><span class="cov8" title="1">{
                return nil, models.ErrBatchEmptyInput
        }</span>

        <span class="cov8" title="1">switch req.Operation </span>{
        case "enable":<span class="cov8" title="1">
                return service.BatchEnable(ctx, req.RuleIDs)</span>
        case "disable":<span class="cov8" title="1">
                return service.BatchDisable(ctx, req.RuleIDs)</span>
        case "delete":<span class="cov8" title="1">
                return service.BatchDelete(ctx, req.RuleIDs)</span>
        case "update":<span class="cov8" title="1">
                if len(req.Updates) == 0 </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("%s: updates cannot be empty for update operation", models.ErrBatchInvalidInput.Message)
                }</span>
                <span class="cov8" title="1">return service.BatchUpdate(ctx, req.RuleIDs, req.Updates)</span>
        default:<span class="cov8" title="1">
                return nil, fmt.Errorf("%s: unknown operation: %s", models.ErrBatchInvalidInput.Message, req.Operation)</span>
        }
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package service

import (
        "context"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/gomockserver/mockserver/pkg/logger"
        "go.mongodb.org/mongo-driver/mongo"
        "go.uber.org/zap"
)

var (
        // ServerStartTime 服务器启动时间
        ServerStartTime time.Time
        // Version 应用版本号
        Version = "0.6.2"
        // AppName 应用名称
        AppName = "MockServer"
)

func init() <span class="cov8" title="1">{
        ServerStartTime = time.Now()
}</span>

// HealthStatus 健康状态
type HealthStatus string

const (
        // StatusHealthy 健康
        StatusHealthy HealthStatus = "healthy"
        // StatusDegraded 降级（部分功能不可用）
        StatusDegraded HealthStatus = "degraded"
        // StatusUnhealthy 不健康
        StatusUnhealthy HealthStatus = "unhealthy"
)

// ComponentStatus 组件状态
type ComponentStatus struct {
        Status  HealthStatus `json:"status"`
        Message string       `json:"message,omitempty"`
        Details interface{}  `json:"details,omitempty"`
}

// HealthResponse 健康检查响应
type HealthResponse struct {
        Status     HealthStatus               `json:"status"`
        Version    string                     `json:"version"`
        AppName    string                     `json:"app_name"`
        Uptime     string                     `json:"uptime"`
        Timestamp  string                     `json:"timestamp"`
        Components map[string]ComponentStatus `json:"components,omitempty"`
}

// HealthChecker 健康检查器
type HealthChecker struct {
        mongoClient *mongo.Client
}

// NewHealthChecker 创建健康检查器
func NewHealthChecker(mongoClient *mongo.Client) *HealthChecker <span class="cov8" title="1">{
        return &amp;HealthChecker{
                mongoClient: mongoClient,
        }
}</span>

// Check 执行健康检查
func (h *HealthChecker) Check(c *gin.Context) <span class="cov8" title="1">{
        ctx := c.Request.Context()
        detailed := c.Query("detailed") == "true"

        response := HealthResponse{
                Status:    StatusHealthy,
                Version:   Version,
                AppName:   AppName,
                Uptime:    formatUptime(time.Since(ServerStartTime)),
                Timestamp: time.Now().UTC().Format(time.RFC3339),
        }

        // 如果需要详细信息，检查各组件状态
        if detailed &amp;&amp; h.mongoClient != nil </span><span class="cov8" title="1">{
                components := make(map[string]ComponentStatus)

                // 检查数据库连接
                dbStatus := h.checkDatabase(ctx)
                components["database"] = dbStatus

                // 如果数据库不健康，整体状态降级
                if dbStatus.Status == StatusUnhealthy </span><span class="cov0" title="0">{
                        response.Status = StatusDegraded
                }</span>

                <span class="cov8" title="1">response.Components = components</span>
        }

        // 根据整体状态返回不同的 HTTP 状态码
        <span class="cov8" title="1">statusCode := 200
        switch response.Status </span>{
        case StatusUnhealthy:<span class="cov0" title="0">
                statusCode = 503</span>
        case StatusDegraded:<span class="cov0" title="0">
                statusCode = 200</span> // 降级时仍然返回 200，但在响应中标记
        }

        <span class="cov8" title="1">c.JSON(statusCode, response)</span>
}

// checkDatabase 检查数据库连接状态
func (h *HealthChecker) checkDatabase(ctx context.Context) ComponentStatus <span class="cov8" title="1">{
        if h.mongoClient == nil </span><span class="cov8" title="1">{
                return ComponentStatus{
                        Status:  StatusHealthy,
                        Message: "database not configured",
                }
        }</span>

        // 使用超时上下文进行 ping
        <span class="cov8" title="1">pingCtx, cancel := context.WithTimeout(ctx, 2*time.Second)
        defer cancel()

        err := h.mongoClient.Ping(pingCtx, nil)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("database health check failed", zap.Error(err))
                return ComponentStatus{
                        Status:  StatusUnhealthy,
                        Message: "database connection failed",
                        Details: map[string]interface{}{
                                "error": err.Error(),
                        },
                }
        }</span>

        <span class="cov8" title="1">return ComponentStatus{
                Status:  StatusHealthy,
                Message: "database connection established",
        }</span>
}

// formatUptime 格式化运行时间
func formatUptime(d time.Duration) string <span class="cov8" title="1">{
        days := int(d.Hours()) / 24
        hours := int(d.Hours()) % 24
        minutes := int(d.Minutes()) % 60
        seconds := int(d.Seconds()) % 60

        if days &gt; 0 </span><span class="cov8" title="1">{
                return formatString("%dd %dh %dm %ds", days, hours, minutes, seconds)
        }</span>
        <span class="cov8" title="1">if hours &gt; 0 </span><span class="cov8" title="1">{
                return formatString("%dh %dm %ds", hours, minutes, seconds)
        }</span>
        <span class="cov8" title="1">if minutes &gt; 0 </span><span class="cov8" title="1">{
                return formatString("%dm %ds", minutes, seconds)
        }</span>
        <span class="cov8" title="1">return formatString("%ds", seconds)</span>
}

func formatString(format string, args ...interface{}) string <span class="cov8" title="1">{
        // 简单格式化实现
        switch len(args) </span>{
        case 1:<span class="cov8" title="1">
                return formatWithOneArg(format, args[0].(int))</span>
        case 2:<span class="cov8" title="1">
                return formatWithTwoArgs(format, args[0].(int), args[1].(int))</span>
        case 3:<span class="cov8" title="1">
                return formatWithThreeArgs(format, args[0].(int), args[1].(int), args[2].(int))</span>
        case 4:<span class="cov8" title="1">
                return formatWithFourArgs(format, args[0].(int), args[1].(int), args[2].(int), args[3].(int))</span>
        default:<span class="cov0" title="0">
                return ""</span>
        }
}

func formatWithOneArg(format string, a int) string <span class="cov8" title="1">{
        // %ds 格式
        result := ""
        for i := 0; i &lt; len(format); i++ </span><span class="cov8" title="1">{
                if format[i] == '%' &amp;&amp; i+1 &lt; len(format) &amp;&amp; format[i+1] == 'd' </span><span class="cov8" title="1">{
                        result += intToString(a)
                        i++
                }</span> else<span class="cov8" title="1"> {
                        result += string(format[i])
                }</span>
        }
        <span class="cov8" title="1">return result</span>
}

func formatWithTwoArgs(format string, a, b int) string <span class="cov8" title="1">{
        result := ""
        args := []int{a, b}
        argIdx := 0
        for i := 0; i &lt; len(format); i++ </span><span class="cov8" title="1">{
                if format[i] == '%' &amp;&amp; i+1 &lt; len(format) &amp;&amp; format[i+1] == 'd' &amp;&amp; argIdx &lt; len(args) </span><span class="cov8" title="1">{
                        result += intToString(args[argIdx])
                        argIdx++
                        i++
                }</span> else<span class="cov8" title="1"> {
                        result += string(format[i])
                }</span>
        }
        <span class="cov8" title="1">return result</span>
}

func formatWithThreeArgs(format string, a, b, c int) string <span class="cov8" title="1">{
        result := ""
        args := []int{a, b, c}
        argIdx := 0
        for i := 0; i &lt; len(format); i++ </span><span class="cov8" title="1">{
                if format[i] == '%' &amp;&amp; i+1 &lt; len(format) &amp;&amp; format[i+1] == 'd' &amp;&amp; argIdx &lt; len(args) </span><span class="cov8" title="1">{
                        result += intToString(args[argIdx])
                        argIdx++
                        i++
                }</span> else<span class="cov8" title="1"> {
                        result += string(format[i])
                }</span>
        }
        <span class="cov8" title="1">return result</span>
}

func formatWithFourArgs(format string, a, b, c, d int) string <span class="cov8" title="1">{
        result := ""
        args := []int{a, b, c, d}
        argIdx := 0
        for i := 0; i &lt; len(format); i++ </span><span class="cov8" title="1">{
                if format[i] == '%' &amp;&amp; i+1 &lt; len(format) &amp;&amp; format[i+1] == 'd' &amp;&amp; argIdx &lt; len(args) </span><span class="cov8" title="1">{
                        result += intToString(args[argIdx])
                        argIdx++
                        i++
                }</span> else<span class="cov8" title="1"> {
                        result += string(format[i])
                }</span>
        }
        <span class="cov8" title="1">return result</span>
}

func intToString(n int) string <span class="cov8" title="1">{
        if n == 0 </span><span class="cov8" title="1">{
                return "0"
        }</span>
        <span class="cov8" title="1">var result string
        for n &gt; 0 </span><span class="cov8" title="1">{
                digit := n % 10
                result = string(rune('0'+digit)) + result
                n /= 10
        }</span>
        <span class="cov8" title="1">return result</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package service

import (
        "context"
        "errors"
        "fmt"
        "strings"
        "time"

        "github.com/gomockserver/mockserver/internal/models"
        "github.com/gomockserver/mockserver/internal/repository"
        "go.uber.org/zap"
)

// ImportExportService 导入导出服务接口
type ImportExportService interface {
        // ExportRules 导出规则
        ExportRules(ctx context.Context, req *models.ExportRequest) (*models.ExportData, error)
        // ExportProject 导出整个项目
        ExportProject(ctx context.Context, projectID string, includeMetadata bool) (*models.ExportData, error)
        // ImportData 导入数据
        ImportData(ctx context.Context, req *models.ImportRequest) (*models.ImportResult, error)
        // ValidateImportData 验证导入数据
        ValidateImportData(ctx context.Context, data *models.ExportData) error
}

type importExportService struct {
        ruleRepo    repository.RuleRepository
        projectRepo repository.ProjectRepository
        envRepo     repository.EnvironmentRepository
        logger      *zap.Logger
}

// NewImportExportService 创建导入导出服务
func NewImportExportService(
        ruleRepo repository.RuleRepository,
        projectRepo repository.ProjectRepository,
        envRepo repository.EnvironmentRepository,
        logger *zap.Logger,
) ImportExportService <span class="cov8" title="1">{
        return &amp;importExportService{
                ruleRepo:    ruleRepo,
                projectRepo: projectRepo,
                envRepo:     envRepo,
                logger:      logger,
        }
}</span>

// ExportRules 导出规则
func (s *importExportService) ExportRules(ctx context.Context, req *models.ExportRequest) (*models.ExportData, error) <span class="cov8" title="1">{
        exportData := &amp;models.ExportData{
                Version:    "1.0",
                ExportTime: time.Now(),
                Data: models.ExportDataContent{
                        Rules: []models.RuleExportData{},
                },
        }

        // 根据请求参数确定导出类型
        if req.IncludeProject </span><span class="cov8" title="1">{
                exportData.ExportType = models.ExportTypeProject
        }</span> else<span class="cov8" title="1"> if req.IncludeEnvs </span><span class="cov8" title="1">{
                exportData.ExportType = models.ExportTypeEnvironment
        }</span> else<span class="cov8" title="1"> {
                exportData.ExportType = models.ExportTypeRules
        }</span>

        // 导出项目信息
        <span class="cov8" title="1">if req.IncludeProject &amp;&amp; req.ProjectID != "" </span><span class="cov8" title="1">{
                project, err := s.projectRepo.FindByID(ctx, req.ProjectID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to find project: %w", err)
                }</span>
                <span class="cov8" title="1">if project != nil </span><span class="cov8" title="1">{
                        exportData.Data.Project = &amp;models.ProjectExportData{
                                Name:        project.Name,
                                WorkspaceID: project.WorkspaceID,
                                Description: project.Description,
                        }
                }</span>
        }

        // 导出环境信息
        <span class="cov8" title="1">envMap := make(map[string]string) // envID -&gt; envName
        if req.IncludeEnvs &amp;&amp; req.ProjectID != "" </span><span class="cov8" title="1">{
                envs, err := s.envRepo.FindByProject(ctx, req.ProjectID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to find environments: %w", err)
                }</span>
                <span class="cov8" title="1">for _, env := range envs </span><span class="cov8" title="1">{
                        envMap[env.ID] = env.Name
                        exportData.Data.Environments = append(exportData.Data.Environments, models.EnvironmentExportData{
                                Name:      env.Name,
                                BaseURL:   env.BaseURL,
                                Variables: env.Variables,
                        })
                }</span>
        }

        // 导出规则
        <span class="cov8" title="1">var rules []*models.Rule
        var err error

        if len(req.RuleIDs) &gt; 0 </span><span class="cov8" title="1">{
                // 按规则ID列表导出
                for _, ruleID := range req.RuleIDs </span><span class="cov8" title="1">{
                        rule, err := s.ruleRepo.FindByID(ctx, ruleID)
                        if err != nil </span><span class="cov0" title="0">{
                                s.logger.Error("Failed to find rule", zap.String("rule_id", ruleID), zap.Error(err))
                                continue</span>
                        }
                        <span class="cov8" title="1">if rule != nil </span><span class="cov8" title="1">{
                                rules = append(rules, rule)
                        }</span>
                }
        } else<span class="cov8" title="1"> if req.EnvironmentID != "" &amp;&amp; req.ProjectID != "" </span><span class="cov8" title="1">{
                // 按环境导出
                rules, err = s.ruleRepo.FindByEnvironment(ctx, req.ProjectID, req.EnvironmentID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to find rules by environment: %w", err)
                }</span>
        } else<span class="cov8" title="1"> if req.ProjectID != "" </span><span class="cov8" title="1">{
                // 按项目导出所有规则
                filter := map[string]interface{}{"project_id": req.ProjectID}
                rules, _, err = s.ruleRepo.List(ctx, filter, 0, 10000) // 最多导出10000条
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to find rules by project: %w", err)
                }</span>
        }

        // 转换规则为导出格式
        <span class="cov8" title="1">for _, rule := range rules </span><span class="cov8" title="1">{
                ruleData := models.RuleExportData{
                        Name:           rule.Name,
                        EnvironmentID:  rule.EnvironmentID,
                        Protocol:       rule.Protocol,
                        MatchType:      rule.MatchType,
                        Priority:       rule.Priority,
                        Enabled:        rule.Enabled,
                        MatchCondition: rule.MatchCondition,
                        Response:       rule.Response,
                        Tags:           rule.Tags,
                }

                // 添加环境名称
                if envName, ok := envMap[rule.EnvironmentID]; ok </span><span class="cov8" title="1">{
                        ruleData.EnvironmentName = envName
                }</span>

                <span class="cov8" title="1">exportData.Data.Rules = append(exportData.Data.Rules, ruleData)</span>
        }

        // 添加元数据
        <span class="cov8" title="1">if req.IncludeMetadata </span><span class="cov8" title="1">{
                exportData.Metadata = &amp;models.ExportMetadata{
                        Comment: fmt.Sprintf("Exported %d rules", len(exportData.Data.Rules)),
                }
        }</span>

        <span class="cov8" title="1">return exportData, nil</span>
}

// ExportProject 导出整个项目
func (s *importExportService) ExportProject(ctx context.Context, projectID string, includeMetadata bool) (*models.ExportData, error) <span class="cov8" title="1">{
        req := &amp;models.ExportRequest{
                ProjectID:       projectID,
                IncludeProject:  true,
                IncludeEnvs:     true,
                IncludeMetadata: includeMetadata,
        }
        return s.ExportRules(ctx, req)
}</span>

// ValidateImportData 验证导入数据
func (s *importExportService) ValidateImportData(ctx context.Context, data *models.ExportData) error <span class="cov8" title="1">{
        // 检查版本
        if data.Version != "1.0" </span><span class="cov8" title="1">{
                return fmt.Errorf("unsupported data version: %s", data.Version)
        }</span>

        // 检查导出类型
        <span class="cov8" title="1">validTypes := map[models.ExportType]bool{
                models.ExportTypeRules:       true,
                models.ExportTypeEnvironment: true,
                models.ExportTypeProject:     true,
        }
        if !validTypes[data.ExportType] </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid export type: %s", data.ExportType)
        }</span>

        // 检查规则数据
        <span class="cov8" title="1">if len(data.Data.Rules) == 0 </span><span class="cov8" title="1">{
                return errors.New("no rules to import")
        }</span>

        // 验证每条规则的必填字段
        <span class="cov8" title="1">for i, rule := range data.Data.Rules </span><span class="cov8" title="1">{
                if rule.Name == "" </span><span class="cov8" title="1">{
                        return fmt.Errorf("rule %d: name is required", i)
                }</span>
                <span class="cov8" title="1">if rule.Protocol == "" </span><span class="cov8" title="1">{
                        return fmt.Errorf("rule %d (%s): protocol is required", i, rule.Name)
                }</span>
                <span class="cov8" title="1">if rule.MatchType == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("rule %d (%s): match_type is required", i, rule.Name)
                }</span>
                <span class="cov8" title="1">if rule.MatchCondition == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("rule %d (%s): match_condition is required", i, rule.Name)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// ImportData 导入数据
func (s *importExportService) ImportData(ctx context.Context, req *models.ImportRequest) (*models.ImportResult, error) <span class="cov8" title="1">{
        result := &amp;models.ImportResult{
                Success:        true,
                EnvironmentIDs: make(map[string]string),
                Errors:         []models.ImportError{},
        }

        // 验证数据
        if err := s.ValidateImportData(ctx, &amp;req.Data); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("validation failed: %w", err)
        }</span>

        // 处理项目
        <span class="cov8" title="1">projectID := req.TargetProjectID
        if req.CreateProject &amp;&amp; req.Data.Data.Project != nil </span><span class="cov8" title="1">{
                // 创建新项目
                project := &amp;models.Project{
                        Name:        req.Data.Data.Project.Name,
                        WorkspaceID: req.Data.Data.Project.WorkspaceID,
                        Description: req.Data.Data.Project.Description,
                }
                if err := s.projectRepo.Create(ctx, project); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to create project: %w", err)
                }</span>
                <span class="cov8" title="1">projectID = project.ID
                result.ProjectID = projectID
                s.logger.Info("Created project", zap.String("project_id", projectID), zap.String("name", project.Name))</span>
        } else<span class="cov8" title="1"> if projectID == "" &amp;&amp; req.Data.Data.Project == nil </span><span class="cov8" title="1">{
                return nil, errors.New("project_id is required or create_project must be true")
        }</span>

        // 处理环境
        <span class="cov8" title="1">envNameToID := make(map[string]string)
        if req.CreateEnvs &amp;&amp; len(req.Data.Data.Environments) &gt; 0 </span><span class="cov8" title="1">{
                for _, envData := range req.Data.Data.Environments </span><span class="cov8" title="1">{
                        env := &amp;models.Environment{
                                Name:      envData.Name,
                                ProjectID: projectID,
                                BaseURL:   envData.BaseURL,
                                Variables: envData.Variables,
                        }
                        if err := s.envRepo.Create(ctx, env); err != nil </span><span class="cov0" title="0">{
                                s.logger.Error("Failed to create environment", zap.String("name", envData.Name), zap.Error(err))
                                continue</span>
                        }
                        <span class="cov8" title="1">envNameToID[envData.Name] = env.ID
                        result.EnvironmentIDs[envData.Name] = env.ID
                        s.logger.Info("Created environment", zap.String("env_id", env.ID), zap.String("name", env.Name))</span>
                }
        } else<span class="cov8" title="1"> if req.TargetEnvID != "" </span><span class="cov8" title="1">{
                // 使用指定的目标环境
                env, err := s.envRepo.FindByID(ctx, req.TargetEnvID)
                if err != nil || env == nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("target environment not found: %s", req.TargetEnvID)
                }</span>
                <span class="cov8" title="1">envNameToID["default"] = req.TargetEnvID</span>
        }

        // 导入规则
        <span class="cov8" title="1">for _, ruleData := range req.Data.Data.Rules </span><span class="cov8" title="1">{
                // 确定目标环境ID
                targetEnvID := req.TargetEnvID
                if targetEnvID == "" </span><span class="cov8" title="1">{
                        // 根据环境名称查找
                        if ruleData.EnvironmentName != "" </span><span class="cov8" title="1">{
                                if envID, ok := envNameToID[ruleData.EnvironmentName]; ok </span><span class="cov8" title="1">{
                                        targetEnvID = envID
                                }</span>
                        }
                        <span class="cov8" title="1">if targetEnvID == "" &amp;&amp; len(envNameToID) &gt; 0 </span><span class="cov0" title="0">{
                                // 使用第一个环境
                                for _, envID := range envNameToID </span><span class="cov0" title="0">{
                                        targetEnvID = envID
                                        break</span>
                                }
                        }
                }

                <span class="cov8" title="1">if targetEnvID == "" </span><span class="cov0" title="0">{
                        result.Errors = append(result.Errors, models.ImportError{
                                RuleName: ruleData.Name,
                                Error:    "no target environment found",
                        })
                        result.Success = false
                        continue</span>
                }

                // 检查规则是否已存在
                <span class="cov8" title="1">existingRules, _ := s.ruleRepo.FindByEnvironment(ctx, projectID, targetEnvID)
                var existingRule *models.Rule
                for _, r := range existingRules </span><span class="cov8" title="1">{
                        if r.Name == ruleData.Name </span><span class="cov8" title="1">{
                                existingRule = r
                                break</span>
                        }
                }

                // 根据策略处理
                <span class="cov8" title="1">switch req.Strategy </span>{
                case models.ImportStrategySkip:<span class="cov8" title="1">
                        if existingRule != nil </span><span class="cov8" title="1">{
                                result.Skipped++
                                s.logger.Info("Skipped existing rule", zap.String("name", ruleData.Name))
                                continue</span>
                        }
                case models.ImportStrategyOverwrite:<span class="cov8" title="1">
                        if existingRule != nil </span><span class="cov8" title="1">{
                                // 更新现有规则
                                existingRule.MatchType = ruleData.MatchType
                                existingRule.Priority = ruleData.Priority
                                existingRule.Enabled = ruleData.Enabled
                                existingRule.MatchCondition = ruleData.MatchCondition
                                existingRule.Response = ruleData.Response
                                existingRule.Tags = ruleData.Tags

                                if err := s.ruleRepo.Update(ctx, existingRule); err != nil </span><span class="cov0" title="0">{
                                        result.Errors = append(result.Errors, models.ImportError{
                                                RuleName: ruleData.Name,
                                                Error:    err.Error(),
                                        })
                                        result.Success = false
                                        continue</span>
                                }
                                <span class="cov8" title="1">result.Updated++
                                result.RuleIDs = append(result.RuleIDs, existingRule.ID)
                                s.logger.Info("Updated rule", zap.String("rule_id", existingRule.ID), zap.String("name", ruleData.Name))
                                continue</span>
                        }
                case models.ImportStrategyAppend:<span class="cov0" title="0">
                        if existingRule != nil </span><span class="cov0" title="0">{
                                // 自动重命名
                                ruleData.Name = s.generateUniqueName(ctx, projectID, targetEnvID, ruleData.Name)
                        }</span>
                }

                // 创建新规则
                <span class="cov8" title="1">rule := &amp;models.Rule{
                        Name:           ruleData.Name,
                        ProjectID:      projectID,
                        EnvironmentID:  targetEnvID,
                        Protocol:       ruleData.Protocol,
                        MatchType:      ruleData.MatchType,
                        Priority:       ruleData.Priority,
                        Enabled:        ruleData.Enabled,
                        MatchCondition: ruleData.MatchCondition,
                        Response:       ruleData.Response,
                        Tags:           ruleData.Tags,
                }

                if err := s.ruleRepo.Create(ctx, rule); err != nil </span><span class="cov0" title="0">{
                        result.Errors = append(result.Errors, models.ImportError{
                                RuleName: ruleData.Name,
                                Error:    err.Error(),
                        })
                        result.Success = false
                        continue</span>
                }

                <span class="cov8" title="1">result.Created++
                result.RuleIDs = append(result.RuleIDs, rule.ID)
                s.logger.Info("Created rule", zap.String("rule_id", rule.ID), zap.String("name", rule.Name))</span>
        }

        // 如果有任何错误，标记为不完全成功
        <span class="cov8" title="1">if len(result.Errors) &gt; 0 </span><span class="cov0" title="0">{
                result.Success = false
        }</span>

        <span class="cov8" title="1">return result, nil</span>
}

// generateUniqueName 生成唯一名称
func (s *importExportService) generateUniqueName(ctx context.Context, projectID, envID, baseName string) string <span class="cov8" title="1">{
        existingRules, _ := s.ruleRepo.FindByEnvironment(ctx, projectID, envID)
        nameMap := make(map[string]bool)
        for _, r := range existingRules </span><span class="cov8" title="1">{
                nameMap[r.Name] = true
        }</span>

        // 尝试添加后缀
        <span class="cov8" title="1">for i := 1; i &lt;= 100; i++ </span><span class="cov8" title="1">{
                newName := fmt.Sprintf("%s_copy_%d", baseName, i)
                if !nameMap[newName] </span><span class="cov8" title="1">{
                        return newName
                }</span>
        }

        // 使用时间戳
        <span class="cov0" title="0">return fmt.Sprintf("%s_copy_%d", baseName, time.Now().Unix())</span>
}

// CloneRuleService 规则克隆服务接口
type CloneRuleService interface {
        // CloneRule 克隆规则
        CloneRule(ctx context.Context, ruleID string, req *models.CloneRuleRequest) (*models.Rule, error)
}

type cloneRuleService struct {
        ruleRepo repository.RuleRepository
        logger   *zap.Logger
}

// NewCloneRuleService 创建规则克隆服务
func NewCloneRuleService(ruleRepo repository.RuleRepository, logger *zap.Logger) CloneRuleService <span class="cov8" title="1">{
        return &amp;cloneRuleService{
                ruleRepo: ruleRepo,
                logger:   logger,
        }
}</span>

// CloneRule 克隆规则
func (s *cloneRuleService) CloneRule(ctx context.Context, ruleID string, req *models.CloneRuleRequest) (*models.Rule, error) <span class="cov8" title="1">{
        // 查找源规则
        sourceRule, err := s.ruleRepo.FindByID(ctx, ruleID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to find source rule: %w", err)
        }</span>
        <span class="cov8" title="1">if sourceRule == nil </span><span class="cov8" title="1">{
                return nil, errors.New("source rule not found")
        }</span>

        // 创建新规则（复制所有字段）
        <span class="cov8" title="1">newRule := &amp;models.Rule{
                Name:           sourceRule.Name,
                ProjectID:      sourceRule.ProjectID,
                EnvironmentID:  req.TargetEnvironmentID,
                Protocol:       sourceRule.Protocol,
                MatchType:      sourceRule.MatchType,
                Priority:       sourceRule.Priority,
                Enabled:        sourceRule.Enabled,
                MatchCondition: sourceRule.MatchCondition,
                Response:       sourceRule.Response,
                Tags:           sourceRule.Tags,
                Creator:        sourceRule.Creator,
        }

        // 应用目标项目（如果指定）
        if req.TargetProjectID != "" </span><span class="cov8" title="1">{
                newRule.ProjectID = req.TargetProjectID
        }</span>

        // 应用新名称
        <span class="cov8" title="1">if req.NewName != "" </span><span class="cov8" title="1">{
                newRule.Name = req.NewName
        }</span> else<span class="cov8" title="1"> {
                // 自动添加 "_copy" 后缀
                newRule.Name = s.generateCopyName(sourceRule.Name)
        }</span>

        // 应用新优先级
        <span class="cov8" title="1">if req.NewPriority != nil </span><span class="cov8" title="1">{
                newRule.Priority = *req.NewPriority
        }</span>

        // 创建规则
        <span class="cov8" title="1">if err := s.ruleRepo.Create(ctx, newRule); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create cloned rule: %w", err)
        }</span>

        <span class="cov8" title="1">s.logger.Info("Cloned rule",
                zap.String("source_id", ruleID),
                zap.String("new_id", newRule.ID),
                zap.String("new_name", newRule.Name),
        )

        return newRule, nil</span>
}

// generateCopyName 生成复制名称
func (s *cloneRuleService) generateCopyName(baseName string) string <span class="cov8" title="1">{
        if !strings.HasSuffix(baseName, "_copy") </span><span class="cov8" title="1">{
                return baseName + "_copy"
        }</span>
        <span class="cov8" title="1">return baseName</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package service

import (
        "context"
        "time"

        "github.com/gomockserver/mockserver/internal/repository"
        "github.com/gomockserver/mockserver/pkg/logger"
        "go.uber.org/zap"
)

// LogCleanupService 日志清理服务
type LogCleanupService struct {
        repo           repository.RequestLogRepository
        retentionDays  int
        cleanupEnabled bool
        stopChan       chan struct{}
}

// NewLogCleanupService 创建日志清理服务
func NewLogCleanupService(repo repository.RequestLogRepository, retentionDays int) *LogCleanupService <span class="cov8" title="1">{
        if retentionDays &lt;= 0 </span><span class="cov8" title="1">{
                retentionDays = 7 // 默认保留7天
        }</span>

        <span class="cov8" title="1">return &amp;LogCleanupService{
                repo:           repo,
                retentionDays:  retentionDays,
                cleanupEnabled: true,
                stopChan:       make(chan struct{}),
        }</span>
}

// Start 启动定时清理任务
func (s *LogCleanupService) Start() <span class="cov8" title="1">{
        logger.Info("log cleanup service started", zap.Int("retention_days", s.retentionDays))

        // 立即执行一次清理
        s.cleanup()

        // 每天凌晨2点执行清理
        ticker := time.NewTicker(1 * time.Hour)
        defer ticker.Stop()

        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ticker.C:<span class="cov0" title="0">
                        now := time.Now()
                        // 每天凌晨2点执行
                        if now.Hour() == 2 </span><span class="cov0" title="0">{
                                s.cleanup()
                        }</span>
                case &lt;-s.stopChan:<span class="cov8" title="1">
                        logger.Info("log cleanup service stopped")
                        return</span>
                }
        }
}

// Stop 停止清理服务
func (s *LogCleanupService) Stop() <span class="cov8" title="1">{
        close(s.stopChan)
}</span>

// cleanup 执行清理
func (s *LogCleanupService) cleanup() <span class="cov8" title="1">{
        if !s.cleanupEnabled </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">logger.Info("starting log cleanup", zap.Int("retention_days", s.retentionDays))

        before := time.Now().AddDate(0, 0, -s.retentionDays)
        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Minute)
        defer cancel()

        count, err := s.repo.DeleteBefore(ctx, before)
        if err != nil </span><span class="cov8" title="1">{
                logger.Error("failed to cleanup logs", zap.Error(err))
                return
        }</span>

        <span class="cov8" title="1">logger.Info("log cleanup completed",
                zap.Int64("deleted_count", count),
                zap.Time("before", before))</span>
}

// SetEnabled 设置是否启用自动清理
func (s *LogCleanupService) SetEnabled(enabled bool) <span class="cov8" title="1">{
        s.cleanupEnabled = enabled
}</span>

// SetRetentionDays 设置保留天数
func (s *LogCleanupService) SetRetentionDays(days int) <span class="cov8" title="1">{
        if days &gt; 0 </span><span class="cov8" title="1">{
                s.retentionDays = days
                logger.Info("log retention days updated", zap.Int("retention_days", days))
        }</span>
}

// ManualCleanup 手动触发清理
func (s *LogCleanupService) ManualCleanup(ctx context.Context, beforeDays int) (int64, error) <span class="cov8" title="1">{
        if beforeDays &lt;= 0 </span><span class="cov8" title="1">{
                beforeDays = s.retentionDays
        }</span>

        <span class="cov8" title="1">before := time.Now().AddDate(0, 0, -beforeDays)
        count, err := s.repo.DeleteBefore(ctx, before)
        if err != nil </span><span class="cov8" title="1">{
                logger.Error("manual cleanup failed", zap.Error(err))
                return 0, err
        }</span>

        <span class="cov8" title="1">logger.Info("manual cleanup completed",
                zap.Int64("deleted_count", count),
                zap.Int("before_days", beforeDays))

        return count, nil</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package service

import (
        "time"

        "github.com/gin-gonic/gin"
        "github.com/gomockserver/mockserver/pkg/logger"
        "go.uber.org/zap"
)

const (
        // RequestIDHeader 请求ID头部名称
        RequestIDHeader = "X-Request-ID"
        // RequestIDKey 请求ID在上下文中的key
        RequestIDKey = "request_id"
)

// RequestIDMiddleware 请求追踪中间件
// 为每个请求生成唯一的 request_id，并在整个调用链路中传递
func RequestIDMiddleware() gin.HandlerFunc <span class="cov8" title="1">{
        return func(c *gin.Context) </span><span class="cov8" title="1">{
                // 尝试从请求头获取 request_id
                requestID := c.GetHeader(RequestIDHeader)

                // 如果请求头中没有，则生成一个新的
                if requestID == "" </span><span class="cov8" title="1">{
                        requestID = generateRequestID()
                }</span>

                // 将 request_id 存储到上下文中
                <span class="cov8" title="1">c.Set(RequestIDKey, requestID)

                // 在响应头中返回 request_id
                c.Header(RequestIDHeader, requestID)

                c.Next()</span>
        }
}

// PerformanceMiddleware 性能监控中间件
// 记录请求处理时长和基本信息
func PerformanceMiddleware() gin.HandlerFunc <span class="cov8" title="1">{
        return func(c *gin.Context) </span><span class="cov8" title="1">{
                // 记录开始时间
                startTime := time.Now()
                path := c.Request.URL.Path
                method := c.Request.Method

                // 获取 request_id
                requestID, _ := c.Get(RequestIDKey)

                // 处理请求
                c.Next()

                // 计算耗时
                duration := time.Since(startTime)
                statusCode := c.Writer.Status()

                // 记录日志
                logger.Info("request completed",
                        zap.String("request_id", requestID.(string)),
                        zap.String("method", method),
                        zap.String("path", path),
                        zap.Int("status", statusCode),
                        zap.Duration("duration", duration),
                        zap.String("client_ip", c.ClientIP()),
                )

                // 如果请求耗时过长（超过1秒），记录警告
                if duration &gt; time.Second </span><span class="cov8" title="1">{
                        logger.Warn("slow request detected",
                                zap.String("request_id", requestID.(string)),
                                zap.String("method", method),
                                zap.String("path", path),
                                zap.Duration("duration", duration),
                        )
                }</span>
        }
}

// LoggingMiddleware 日志中间件
// 记录请求的基本信息
func LoggingMiddleware() gin.HandlerFunc <span class="cov8" title="1">{
        return func(c *gin.Context) </span><span class="cov8" title="1">{
                requestID, exists := c.Get(RequestIDKey)
                if !exists </span><span class="cov8" title="1">{
                        requestID = "unknown"
                }</span>

                <span class="cov8" title="1">logger.Debug("incoming request",
                        zap.String("request_id", requestID.(string)),
                        zap.String("method", c.Request.Method),
                        zap.String("path", c.Request.URL.Path),
                        zap.String("client_ip", c.ClientIP()),
                        zap.String("user_agent", c.Request.UserAgent()),
                )

                c.Next()</span>
        }
}

// generateRequestID 生成唯一的请求ID
func generateRequestID() string <span class="cov8" title="1">{
        // 使用时间戳 + 随机数生成简单的 request_id
        // 生产环境建议使用 UUID 或其他更强的唯一性保证
        timestamp := time.Now().UnixNano()
        return "req-" + int64ToString(timestamp)
}</span>

// int64ToString 将 int64 转换为字符串
func int64ToString(n int64) string <span class="cov8" title="1">{
        if n == 0 </span><span class="cov8" title="1">{
                return "0"
        }</span>

        <span class="cov8" title="1">isNegative := n &lt; 0
        if isNegative </span><span class="cov8" title="1">{
                n = -n
        }</span>

        <span class="cov8" title="1">var result string
        for n &gt; 0 </span><span class="cov8" title="1">{
                digit := n % 10
                result = string(rune('0'+digit)) + result
                n /= 10
        }</span>

        <span class="cov8" title="1">if isNegative </span><span class="cov8" title="1">{
                result = "-" + result
        }</span>

        <span class="cov8" title="1">return result</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package service

import (
        "context"

        "github.com/gin-gonic/gin"
        "github.com/gomockserver/mockserver/internal/adapter"
        "github.com/gomockserver/mockserver/internal/middleware"
        "github.com/gomockserver/mockserver/internal/models"
        "github.com/gomockserver/mockserver/pkg/logger"
        "go.uber.org/zap"
)

// MatchEngineInterface 匹配引擎接口
type MatchEngineInterface interface {
        Match(ctx context.Context, request *adapter.Request, projectID, environmentID string) (*models.Rule, error)
}

// MockExecutorInterface Mock 执行器接口
type MockExecutorInterface interface {
        Execute(request *adapter.Request, rule *models.Rule) (*adapter.Response, error)
        GetDefaultResponse() *adapter.Response
}

// MockService Mock 服务
type MockService struct {
        httpAdapter  *adapter.HTTPAdapter
        matchEngine  MatchEngineInterface
        mockExecutor MockExecutorInterface
}

// NewMockService 创建 Mock 服务
func NewMockService(matchEngine MatchEngineInterface, mockExecutor MockExecutorInterface) *MockService <span class="cov8" title="1">{
        return &amp;MockService{
                httpAdapter:  adapter.NewHTTPAdapter(),
                matchEngine:  matchEngine,
                mockExecutor: mockExecutor,
        }
}</span>

// HandleMockRequest 处理 Mock 请求
func (s *MockService) HandleMockRequest(c *gin.Context) <span class="cov8" title="1">{
        // 从路径中提取项目ID和环境ID
        // 请求格式：/:projectID/:environmentID/*path
        projectID := c.Param("projectID")
        environmentID := c.Param("environmentID")

        if projectID == "" || environmentID == "" </span><span class="cov8" title="1">{
                c.JSON(400, gin.H{
                        "error": "projectID and environmentID are required",
                })
                return
        }</span>

        // 解析请求为统一模型
        <span class="cov8" title="1">request, err := s.httpAdapter.Parse(c)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to parse request", zap.Error(err))
                c.JSON(500, gin.H{
                        "error": "Failed to parse request",
                })
                return
        }</span>

        // 匹配规则
        <span class="cov8" title="1">ctx := context.Background()
        rule, err := s.matchEngine.Match(ctx, request, projectID, environmentID)
        if err != nil </span><span class="cov8" title="1">{
                logger.Error("failed to match rule", zap.Error(err))
                c.JSON(500, gin.H{
                        "error": "Failed to match rule",
                })
                return
        }</span>

        <span class="cov8" title="1">var response *adapter.Response

        // 如果没有匹配的规则，返回默认响应
        if rule == nil </span><span class="cov8" title="1">{
                logger.Info("no rule matched, using default response",
                        zap.String("path", request.Path),
                        zap.String("project_id", projectID),
                        zap.String("environment_id", environmentID))
                response = s.mockExecutor.GetDefaultResponse()
        }</span> else<span class="cov8" title="1"> {
                // 执行 Mock 响应生成
                response, err = s.mockExecutor.Execute(request, rule)
                if err != nil </span><span class="cov8" title="1">{
                        logger.Error("failed to execute mock", zap.Error(err))
                        c.JSON(500, gin.H{
                                "error": "Failed to execute mock",
                        })
                        return
                }</span>
        }

        // 写入响应
        <span class="cov8" title="1">s.httpAdapter.WriteResponse(c, response)</span>
}

// StartMockServer 启动 Mock 服务器
func StartMockServer(addr string, service *MockService) error <span class="cov0" title="0">{
        gin.SetMode(gin.ReleaseMode)
        r := gin.New()
        r.Use(gin.Recovery())
        // 添加 CORS 支持，允许前端直接调用 Mock 服务
        r.Use(middleware.CORS())

        // Mock 请求处理路由
        // 格式：/:projectID/:environmentID/*path
        r.Any("/:projectID/:environmentID/*path", service.HandleMockRequest)

        logger.Info("starting mock server", zap.String("address", addr))
        return r.Run(addr)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
