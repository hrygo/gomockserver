# gomockserver核心交互流程文档

<cite>
**本文档中引用的文件**
- [mock_service.go](file://internal/service/mock_service.go)
- [http_adapter.go](file://internal/adapter/http_adapter.go)
- [match_engine.go](file://internal/engine/match_engine.go)
- [mock_executor.go](file://internal/executor/mock_executor.go)
- [middleware.go](file://internal/service/middleware.go)
- [models.go](file://internal/models/models.go)
- [adapter.go](file://internal/adapter/adapter.go)
- [mock_service_test.go](file://internal/service/mock_service_test.go)
</cite>

## 目录
1. [概述](#概述)
2. [系统架构](#系统架构)
3. [核心组件分析](#核心组件分析)
4. [HandleMockRequest核心流程](#handlemockrequest核心流程)
5. [匹配引擎优先级机制](#匹配引擎优先级机制)
6. [中间件集成](#中间件集成)
7. [错误处理与恢复](#错误处理与恢复)
8. [性能优化策略](#性能优化策略)
9. [故障排除指南](#故障排除指南)
10. [总结](#总结)

## 概述

gomockserver是一个高性能的Mock服务器，采用模块化架构设计，通过四个核心组件协同工作来处理HTTP请求的Mock响应。系统的核心交互流程围绕`HandleMockRequest`方法展开，该方法协调HTTPAdapter、MatchEngine和MockExecutor三个关键组件，实现了从请求解析到响应生成的完整生命周期管理。

## 系统架构

```mermaid
graph TB
subgraph "客户端层"
Client[HTTP客户端]
end
subgraph "中间件层"
CORS[CORS中间件]
Middleware[通用中间件]
end
subgraph "服务层"
Router[路由器]
MockService[Mock服务]
end
subgraph "适配器层"
HTTPAdapter[HTTP适配器]
end
subgraph "引擎层"
MatchEngine[匹配引擎]
end
subgraph "执行器层"
MockExecutor[Mock执行器]
end
subgraph "存储层"
RuleRepo[规则仓库]
end
Client --> CORS
CORS --> Router
Router --> MockService
MockService --> HTTPAdapter
MockService --> MatchEngine
MockService --> MockExecutor
MatchEngine --> RuleRepo
HTTPAdapter --> Router
MockExecutor --> Router
```

**图表来源**
- [mock_service.go](file://internal/service/mock_service.go#L101-L116)
- [http_adapter.go](file://internal/adapter/http_adapter.go#L14-L19)
- [match_engine.go](file://internal/engine/match_engine.go#L26-L40)

## 核心组件分析

### MockService - 服务协调器

MockService是整个系统的核心协调器，负责整合各个组件的功能。它维护着三个关键依赖：

```mermaid
classDiagram
class MockService {
+HTTPAdapter httpAdapter
+MatchEngineInterface matchEngine
+MockExecutorInterface mockExecutor
+HandleMockRequest(c *gin.Context)
+NewMockService(matchEngine, mockExecutor) *MockService
}
class MatchEngineInterface {
<<interface>>
+Match(ctx, request, projectID, environmentID) (*Rule, error)
}
class MockExecutorInterface {
<<interface>>
+Execute(request, rule) (*Response, error)
+GetDefaultResponse() *Response
}
MockService --> MatchEngineInterface
MockService --> MockExecutorInterface
```

**图表来源**
- [mock_service.go](file://internal/service/mock_service.go#L25-L38)

### HTTPAdapter - 协议适配器

HTTPAdapter负责将Gin框架的HTTP请求转换为统一的请求模型，并将统一的响应模型转换回HTTP响应格式。

```mermaid
classDiagram
class HTTPAdapter {
+Parse(rawRequest) (*Request, error)
+Build(response) (interface{}, error)
+WriteResponse(c *gin.Context, response)
}
class Request {
+string ID
+ProtocolType Protocol
+map[string]string Headers
+[]byte Body
+string SourceIP
+time.Time ReceivedAt
+map[string]interface{} Metadata
}
class Response {
+int StatusCode
+map[string]string Headers
+[]byte Body
+map[string]interface{} Metadata
}
HTTPAdapter --> Request
HTTPAdapter --> Response
```

**图表来源**
- [http_adapter.go](file://internal/adapter/http_adapter.go#L14-L19)
- [adapter.go](file://internal/adapter/adapter.go#L9-L39)

### MatchEngine - 规则匹配引擎

MatchEngine实现了智能的规则匹配机制，支持多种匹配类型和优先级处理。

```mermaid
classDiagram
class MatchEngine {
+RuleRepository ruleRepo
+LRURegexCache regexCache
+Match(ctx, request, projectID, environmentID) (*Rule, error)
+simpleMatch(request, rule) (bool, error)
+regexMatch(request, rule) (bool, error)
+scriptMatch(request, rule) (bool, error)
+compileRegex(pattern) (*regexp.Regexp, error)
}
class Rule {
+string ID
+string Name
+ProtocolType Protocol
+MatchType MatchType
+int Priority
+bool Enabled
+map[string]interface{} MatchCondition
+Response Response
}
MatchEngine --> Rule
```

**图表来源**
- [match_engine.go](file://internal/engine/match_engine.go#L26-L40)
- [models.go](file://internal/models/models.go#L48-L64)

### MockExecutor - 响应执行器

MockExecutor负责根据匹配的规则生成不同类型的响应，包括静态响应、动态响应和代理响应。

```mermaid
classDiagram
class MockExecutor {
+TemplateEngine templateEngine
+ProxyExecutor proxyExecutor
+Execute(request, rule) (*Response, error)
+staticResponse(request, rule) (*Response, error)
+dynamicResponse(request, rule, env) (*Response, error)
+proxyResponse(request, rule) (*Response, error)
+calculateDelay(config) int
+GetDefaultResponse() *Response
}
class ResponseType {
<<enumeration>>
Static
Dynamic
Proxy
Script
}
MockExecutor --> ResponseType
```

**图表来源**
- [mock_executor.go](file://internal/executor/mock_executor.go#L21-L46)

**章节来源**
- [mock_service.go](file://internal/service/mock_service.go#L25-L38)
- [http_adapter.go](file://internal/adapter/http_adapter.go#L14-L19)
- [match_engine.go](file://internal/engine/match_engine.go#L26-L40)
- [mock_executor.go](file://internal/executor/mock_executor.go#L21-L46)

## HandleMockRequest核心流程

`HandleMockRequest`方法是整个系统的核心入口点，它协调了四个关键步骤来处理HTTP请求。

```mermaid
sequenceDiagram
participant Client as 客户端
participant Router as 路由器
participant Service as MockService
participant Adapter as HTTPAdapter
participant Engine as MatchEngine
participant Executor as MockExecutor
Client->>Router : HTTP请求 / : projectID/ : environmentID/*path
Router->>Service : HandleMockRequest(context)
Note over Service : 第一步：参数提取
Service->>Service : 提取projectID和environmentID
alt 参数缺失
Service-->>Client : 400 Bad Request
else 参数有效
Service->>Adapter : Parse(context)
Adapter->>Adapter : 解析请求为统一模型
alt 解析失败
Service-->>Client : 500 Internal Server Error
else 解析成功
Service->>Engine : Match(request, projectID, environmentID)
loop 按优先级遍历规则
Engine->>Engine : 检查协议匹配
Engine->>Engine : 执行具体匹配逻辑
alt 匹配成功
Engine-->>Service : 返回匹配规则
else 不匹配
Engine->>Engine : 继续下一个规则
end
end
alt 无匹配规则
Service->>Executor : GetDefaultResponse()
Executor-->>Service : 默认404响应
else 有匹配规则
Service->>Executor : Execute(request, rule)
Executor-->>Service : 生成响应
end
Service->>Adapter : WriteResponse(context, response)
Adapter->>Adapter : 写入HTTP响应
Adapter-->>Client : HTTP响应
end
end
```

**图表来源**
- [mock_service.go](file://internal/service/mock_service.go#L42-L98)
- [http_adapter.go](file://internal/adapter/http_adapter.go#L21-L85)
- [match_engine.go](file://internal/engine/match_engine.go#L42-L77)
- [mock_executor.go](file://internal/executor/mock_executor.go#L48-L72)

### 详细流程分解

#### 1. URL参数提取阶段

系统首先从URL路径中提取`projectID`和`environmentID`参数：

```mermaid
flowchart TD
Start([请求到达]) --> ExtractParams["提取projectID和environmentID<br/>c.Param('projectID')<br/>c.Param('environmentID')"]
ExtractParams --> ValidateParams{"参数是否有效?"}
ValidateParams --> |否| Return400["返回400错误<br/>{'error': 'projectID and environmentID are required'}"]
ValidateParams --> |是| NextStep["继续处理"]
Return400 --> End([结束])
NextStep --> ParseRequest["解析HTTP请求"]
```

**图表来源**
- [mock_service.go](file://internal/service/mock_service.go#L44-L53)

#### 2. HTTP请求解析阶段

HTTPAdapter将Gin上下文转换为统一的请求模型：

```mermaid
flowchart TD
ParseStart([开始解析]) --> ReadBody["读取请求体<br/>io.ReadAll(c.Request.Body)"]
ReadBody --> ExtractHeaders["提取Headers<br/>遍历c.Request.Header"]
ExtractHeaders --> ExtractQuery["提取Query参数<br/>遍历c.Request.URL.Query()"]
ExtractQuery --> GetIP["获取客户端IP<br/>c.ClientIP()"]
GetIP --> NormalizePath["规范化路径<br/>移除前缀/:projectID/:environmentID"]
NormalizePath --> BuildRequest["构建统一请求模型"]
BuildRequest --> ParseEnd([解析完成])
```

**图表来源**
- [http_adapter.go](file://internal/adapter/http_adapter.go#L21-L85)

#### 3. 规则匹配阶段

MatchEngine按优先级顺序匹配规则：

```mermaid
flowchart TD
LoadRules["加载环境下所有启用的规则<br/>ruleRepo.FindEnabledByEnvironment()"] --> SortByPriority["按优先级排序规则"]
SortByPriority --> LoopRules["遍历规则列表"]
LoopRules --> CheckProtocol{"协议匹配?"}
CheckProtocol --> |否| NextRule["跳过，检查下一规则"]
CheckProtocol --> |是| SelectMatchType{"选择匹配类型"}
SelectMatchType --> |Simple| SimpleMatch["执行简单匹配<br/>matchPath, matchMethod, matchHeaders"]
SelectMatchType --> |Regex| RegexMatch["执行正则匹配<br/>编译并缓存正则表达式"]
SelectMatchType --> |Script| ScriptMatch["执行脚本匹配<br/>(暂未实现)"]
SimpleMatch --> MatchResult{"匹配成功?"}
RegexMatch --> MatchResult
ScriptMatch --> MatchResult
MatchResult --> |是| ReturnRule["返回匹配规则"]
MatchResult --> |否| NextRule
NextRule --> MoreRules{"还有规则?"}
MoreRules --> |是| LoopRules
MoreRules --> |否| ReturnNil["返回nil(无匹配)"]
ReturnRule --> End([匹配完成])
ReturnNil --> End
```

**图表来源**
- [match_engine.go](file://internal/engine/match_engine.go#L42-L77)

#### 4. 响应生成阶段

根据匹配结果或默认响应生成最终响应：

```mermaid
flowchart TD
CheckRule{"是否有匹配规则?"}
CheckRule --> |否| GetDefault["获取默认响应<br/>mockExecutor.GetDefaultResponse()"]
CheckRule --> |是| ExecuteRule["执行规则响应<br/>mockExecutor.Execute()"]
GetDefault --> Set404["设置404状态码"]
Set404 --> SetDefaultBody["设置默认错误消息"]
SetDefaultBody --> BuildResponse["构建响应对象"]
ExecuteRule --> CheckResponseType{"响应类型"}
CheckResponseType --> |Static| StaticResponse["生成静态响应"]
CheckResponseType --> |Dynamic| DynamicResponse["生成动态响应"]
CheckResponseType --> |Proxy| ProxyResponse["生成代理响应"]
StaticResponse --> ApplyDelay["应用延迟配置"]
DynamicResponse --> ApplyDelay
ProxyResponse --> ApplyDelay
ApplyDelay --> BuildResponse
BuildResponse --> WriteResponse["写入HTTP响应"]
WriteResponse --> End([响应完成])
```

**图表来源**
- [mock_service.go](file://internal/service/mock_service.go#L76-L98)
- [mock_executor.go](file://internal/executor/mock_executor.go#L48-L72)

**章节来源**
- [mock_service.go](file://internal/service/mock_service.go#L42-L98)
- [http_adapter.go](file://internal/adapter/http_adapter.go#L21-L85)
- [match_engine.go](file://internal/engine/match_engine.go#L42-L77)
- [mock_executor.go](file://internal/executor/mock_executor.go#L48-L72)

## 匹配引擎优先级机制

MatchEngine实现了智能的优先级处理机制，确保高优先级规则能够优先匹配。

### 优先级处理流程

```mermaid
flowchart TD
LoadRules["加载规则"] --> SortRules["按Priority字段排序<br/>降序排列"]
SortRules --> IterateRules["从最高优先级开始迭代"]
IterateRules --> CheckProtocol["检查协议匹配"]
CheckProtocol --> ProtocolMatch{"协议匹配?"}
ProtocolMatch --> |否| SkipRule["跳过此规则"]
ProtocolMatch --> |是| CheckMatchType["检查匹配类型"]
CheckMatchType --> SimpleMatch["简单匹配"]
CheckMatchType --> RegexMatch["正则匹配"]
CheckMatchType --> ScriptMatch["脚本匹配"]
SimpleMatch --> SimpleResult{"匹配结果"}
RegexMatch --> RegexResult{"匹配结果"}
ScriptMatch --> ScriptResult{"匹配结果"}
SimpleResult --> |成功| ReturnRule["返回规则"]
RegexResult --> |成功| ReturnRule
ScriptResult --> |成功| ReturnRule
SimpleResult --> |失败| NextRule["检查下一规则"]
RegexResult --> |失败| NextRule
ScriptResult --> |失败| NextRule
SkipRule --> NextRule
NextRule --> HasMore{"还有规则?"}
HasMore --> |是| IterateRules
HasMore --> |否| NoMatch["返回nil"]
ReturnRule --> End([匹配完成])
NoMatch --> End
```

**图表来源**
- [match_engine.go](file://internal/engine/match_engine.go#L42-L77)

### 多维度规则匹配

MatchEngine支持四种维度的规则匹配：

| 匹配维度 | 描述 | 支持的匹配类型 | 示例 |
|---------|------|---------------|------|
| **路径匹配** | 请求路径的匹配 | 简单字符串、正则表达式 | `/api/users`, `/api/users/\d+` |
| **方法匹配** | HTTP方法的匹配 | 字符串、数组 | `GET`, `[GET, POST]` |
| **Header匹配** | 请求头的匹配 | 键值对 | `Content-Type: application/json` |
| **Query匹配** | 查询参数的匹配 | 键值对、正则表达式 | `page=1`, `name=\w+` |

### 正则表达式缓存机制

为了提高性能，MatchEngine实现了LRU缓存机制来缓存编译后的正则表达式：

```mermaid
classDiagram
class LRURegexCache {
+map[string]*regexp.Regexp cache
+int capacity
+Get(key) (*regexp.Regexp, bool)
+Put(key, value)
+Size() int
}
class RegexCacheStats {
+int64 Hits
+int64 Misses
+int Size
}
LRURegexCache --> RegexCacheStats
```

**图表来源**
- [match_engine.go](file://internal/engine/match_engine.go#L19-L24)
- [match_engine.go](file://internal/engine/match_engine.go#L152-L178)

**章节来源**
- [match_engine.go](file://internal/engine/match_engine.go#L42-L77)
- [match_engine.go](file://internal/engine/match_engine.go#L152-L178)

## 中间件集成

gomockserver集成了多个中间件来提供日志记录、性能监控和错误恢复功能。

### 中间件栈结构

```mermaid
graph TD
Request[HTTP请求] --> CORS[CORS中间件]
CORS --> Recovery[恢复中间件]
Recovery --> RequestID[请求ID中间件]
RequestID --> Performance[性能监控中间件]
Performance --> Logging[日志中间件]
Logging --> Router[路由器]
Router --> MockService[Mock服务]
MockService --> Response[HTTP响应]
```

**图表来源**
- [mock_service.go](file://internal/service/mock_service.go#L101-L116)
- [middleware.go](file://internal/service/middleware.go#L18-L134)

### RequestIDMiddleware - 请求追踪

RequestIDMiddleware为每个请求生成唯一的请求ID，并在整个调用链路中传递：

```mermaid
sequenceDiagram
participant Client as 客户端
participant RequestID as RequestID中间件
participant Logger as 日志系统
Client->>RequestID : HTTP请求
RequestID->>RequestID : 检查请求头中的X-Request-ID
alt 请求头中有ID
RequestID->>RequestID : 使用现有ID
else 请求头中无ID
RequestID->>RequestID : 生成新ID<br/>generateRequestID()
end
RequestID->>RequestID : 存储到上下文<br/>c.Set(RequestIDKey, requestID)
RequestID->>RequestID : 添加到响应头<br/>c.Header(RequestIDHeader, requestID)
RequestID->>Logger : 记录请求ID
RequestID-->>Client : 继续处理
```

**图表来源**
- [middleware.go](file://internal/service/middleware.go#L18-L37)

### PerformanceMiddleware - 性能监控

PerformanceMiddleware记录请求处理时间和性能指标：

```mermaid
flowchart TD
StartTimer["记录开始时间<br/>startTime = time.Now()"] --> LogBasic["记录基本请求信息<br/>method, path, clientIP"]
LogBasic --> ProcessRequest["处理请求<br/>c.Next()"]
ProcessRequest --> CalcDuration["计算耗时<br/>duration = time.Since(startTime)"]
CalcDuration --> LogComplete["记录完成信息<br/>statusCode, duration"]
LogComplete --> CheckSlow{"耗时 > 1秒?"}
CheckSlow --> |是| LogWarning["记录性能警告"]
CheckSlow --> |否| End["结束"]
LogWarning --> End
```

**图表来源**
- [middleware.go](file://internal/service/middleware.go#L40-L78)

### LoggingMiddleware - 请求日志

LoggingMiddleware提供详细的请求日志记录：

```mermaid
flowchart TD
GetRequestID["获取请求ID<br/>c.Get(RequestIDKey)"] --> LogIncoming["记录传入请求<br/>method, path, clientIP"]
LogIncoming --> LogUserAgent["记录User-Agent"]
LogUserAgent --> Continue["继续处理<br/>c.Next()"]
Continue --> End["结束"]
```

**图表来源**
- [middleware.go](file://internal/service/middleware.go#L81-L99)

**章节来源**
- [middleware.go](file://internal/service/middleware.go#L18-L134)

## 错误处理与恢复

系统实现了多层次的错误处理机制，确保在各种异常情况下都能提供适当的响应。

### 错误处理层次

```mermaid
graph TD
subgraph "请求级别错误"
ParamError[参数错误<br/>400 Bad Request]
ParseError[解析错误<br/>500 Internal Server Error]
end
subgraph "业务逻辑错误"
MatchError[匹配错误<br/>500 Internal Server Error]
ExecuteError[执行错误<br/>500 Internal Server Error]
end
subgraph "系统级错误"
Recovery[恢复机制<br/>panic -> 500 Internal Server Error]
Timeout[超时处理<br/>连接超时/处理超时]
end
subgraph "响应级别错误"
DefaultResponse[默认响应<br/>404 Not Found]
ErrorResponse[错误响应<br/>JSON格式错误信息]
end
```

### 错误响应模式

| 错误类型 | HTTP状态码 | 响应格式 | 示例 |
|---------|-----------|---------|------|
| **参数缺失** | 400 | JSON | `{"error": "projectID and environmentID are required"}` |
| **解析失败** | 500 | JSON | `{"error": "Failed to parse request"}` |
| **匹配失败** | 500 | JSON | `{"error": "Failed to match rule"}` |
| **执行失败** | 500 | JSON | `{"error": "Failed to execute mock"}` |
| **无匹配规则** | 404 | JSON | `{"error": "No matching rule found"}` |

### 恢复机制

系统使用Gin框架的Recovery中间件来捕获和处理panic：

```mermaid
sequenceDiagram
participant Service as Mock服务
participant Recovery as 恢复中间件
participant Logger as 日志系统
participant Client as 客户端
Service->>Service : 处理请求
Service->>Service : 发生panic
Service->>Recovery : panic发生
Recovery->>Logger : 记录错误堆栈
Recovery->>Recovery : 恢复控制流
Recovery->>Client : 返回500 Internal Server Error
Recovery-->>Service : 继续执行
```

**图表来源**
- [mock_service.go](file://internal/service/mock_service.go#L104-L105)

**章节来源**
- [mock_service.go](file://internal/service/mock_service.go#L48-L62)
- [mock_service.go](file://internal/service/mock_service.go#L58-L62)
- [mock_service.go](file://internal/service/mock_service.go#L68-L73)
- [mock_service.go](file://internal/service/mock_service.go#L88-L93)

## 性能优化策略

### 缓存机制

系统实现了多层缓存来提升性能：

1. **正则表达式缓存**：MatchEngine使用LRU缓存来存储编译后的正则表达式
2. **规则缓存**：通过数据库查询优化减少重复查询
3. **响应缓存**：对于静态响应可以考虑实现响应缓存

### 并发处理

```mermaid
graph TD
Request[并发请求] --> Router[路由器]
Router --> Pool[协程池]
Pool --> Service1[MockService实例1]
Pool --> Service2[MockService实例2]
Pool --> Service3[MockService实例3]
Service1 --> Adapter1[HTTPAdapter]
Service2 --> Adapter2[HTTPAdapter]
Service3 --> Adapter3[HTTPAdapter]
Adapter1 --> Engine[MatchEngine]
Adapter2 --> Engine
Adapter3 --> Engine
Engine --> Repo[RuleRepository]
Repo --> Database[(数据库)]
```

### 延迟配置

MockExecutor支持多种延迟配置来模拟不同的网络条件：

| 延迟类型 | 配置参数 | 描述 | 使用场景 |
|---------|---------|------|---------|
| **固定延迟** | `Fixed` | 固定毫秒数 | 模拟稳定的网络延迟 |
| **随机延迟** | `Min`, `Max` | 在最小值和最大值之间随机 | 模拟不稳定的网络环境 |
| **正态分布延迟** | `Mean`, `StdDev` | 符合正态分布的延迟 | 更真实的网络行为 |
| **阶梯延迟** | `Step`, `Limit` | 按请求次数递增的延迟 | 模拟资源逐渐耗尽的情况 |

**章节来源**
- [match_engine.go](file://internal/engine/match_engine.go#L152-L178)
- [mock_executor.go](file://internal/executor/mock_executor.go#L292-L364)

## 故障排除指南

### 常见问题诊断

#### 1. 400 Bad Request错误

**症状**：客户端收到400错误，提示"projectID and environmentID are required"

**可能原因**：
- URL格式不正确，缺少projectID或environmentID参数
- 请求路径中包含特殊字符或空格

**解决方案**：
```bash
# 正确格式：/:projectID/:environmentID/*path
curl -X GET "http://localhost:8080/project-001/env-001/api/users"
```

#### 2. 500 Internal Server Error错误

**症状**：客户端收到500错误，提示"Failed to match rule"或"Failed to execute mock"

**诊断步骤**：
1. 检查日志输出，确认具体的错误信息
2. 验证数据库连接是否正常
3. 检查规则配置是否正确

#### 3. 404 Not Found响应

**症状**：客户端收到404响应，提示"No matching rule found"

**诊断步骤**：
1. 检查是否存在匹配的规则
2. 验证规则的优先级设置
3. 确认请求的协议、方法、路径等参数是否匹配

### 性能问题排查

#### 1. 响应缓慢

**诊断工具**：
- 使用PerformanceMiddleware记录的性能日志
- 检查正则表达式缓存命中率

**优化建议**：
- 减少复杂的正则表达式使用
- 优化规则优先级，让常用规则排在前面
- 考虑增加缓存层

#### 2. 内存使用过高

**诊断方法**：
- 监控正则表达式缓存大小
- 检查规则数量和复杂度

**优化建议**：
- 调整LRU缓存容量
- 优化规则设计，避免过度匹配

**章节来源**
- [mock_service_test.go](file://internal/service/mock_service_test.go#L61-L99)
- [middleware.go](file://internal/service/middleware.go#L40-L78)

## 总结

gomockserver通过精心设计的模块化架构，实现了高效、可扩展的Mock服务器功能。其核心交互流程围绕`HandleMockRequest`方法展开，通过HTTPAdapter、MatchEngine和MockExecutor三个核心组件的协同工作，完成了从请求解析到响应生成的完整生命周期管理。

### 关键特性

1. **模块化设计**：清晰的职责分离，便于维护和扩展
2. **智能匹配**：支持多种匹配类型和优先级处理
3. **性能优化**：多层缓存机制和并发处理
4. **错误处理**：完善的错误处理和恢复机制
5. **中间件集成**：丰富的中间件支持，提供完整的可观测性

### 最佳实践建议

1. **规则设计**：合理设置规则优先级，避免不必要的规则遍历
2. **性能监控**：充分利用中间件提供的监控功能
3. **错误处理**：在生产环境中配置适当的日志级别
4. **缓存优化**：根据实际使用情况调整缓存配置

通过深入理解这些核心交互流程和设计原理，开发者可以更好地利用gomockserver的强大功能，构建高质量的Mock服务。