diff --git a/internal/engine/match_engine.go b/internal/engine/match_engine.go
index 7d01806..9093de9 100644
--- a/internal/engine/match_engine.go
+++ b/internal/engine/match_engine.go
@@ -1,6 +1,9 @@
 package engine
 
 import (
+	"context"
+	"encoding/json"
+	"fmt"
 	"net"
 	"regexp"
 	"strings"
@@ -11,6 +14,7 @@ import (
 	"github.com/gomockserver/mockserver/internal/adapter"
 	"github.com/gomockserver/mockserver/internal/models"
 	"github.com/gomockserver/mockserver/internal/repository"
+	"github.com/gomockserver/mockserver/internal/monitoring"
 	"github.com/gomockserver/mockserver/pkg/logger"
 	"go.uber.org/zap"
 )
@@ -19,15 +23,20 @@ import (
 // MatchEngine 规则匹配引擎
 type MatchEngine struct {
 	ruleRepo     repository.RuleRepository
-	regexCache   map[string]*regexp.Regexp
-	regexCacheMu sync.RWMutex
+	regexCache   *LRURegexCache
+	cacheStats   RegexCacheStats
+	statsMu      sync.RWMutex
 }
 
+// RegexCacheStats 缓存统计信息
+type RegexCacheStats struct {
+	Hits   int64
+	Misses int64
+	Size   int
+}
+
 // NewMatchEngine 创建匹配引擎
 func NewMatchEngine(ruleRepo repository.RuleRepository) *MatchEngine {
 	return &MatchEngine{
-		ruleRepo:   ruleRepo,
-		regexCache: make(map[string]*regexp.Regexp),
+		ruleRepo:   ruleRepo,
+		regexCache: NewLRURegexCache(1000), // 默认缓存容量1000
 	}
 }
 
@@ -48,24 +57,32 @@ func NewMatchEngine(ruleRepo repository.RuleRepository) *MatchEngine {
 // Match 匹配规则
 func (e *MatchEngine) Match(ctx context.Context, request *adapter.Request, projectID, environmentID string) (*models.Rule, error) {
+	// Increment total requests counter
+	monitoring.IncrementTotalRequests()
+
 	// 加载环境下所有启用的规则
 	rules, err := e.ruleRepo.FindEnabledByEnvironment(ctx, projectID, environmentID)
 	if err != nil {
 		logger.Error("failed to load rules", zap.Error(err))
 		return nil, err
 	}
 
 	// 按优先级已排序，逐条匹配
 	for _, rule := range rules {
 		// 检查协议类型
 		if rule.Protocol != request.Protocol {
 			continue
 		}
 
 		// 根据匹配类型执行匹配
 		matched, err := e.matchRule(request, rule)
 		if err != nil {
 			logger.Warn("rule match error",
 				zap.String("rule_id", rule.ID),
 				zap.Error(err))
 			continue
 		}
 
 		if matched {
 			logger.Info("rule matched",
 				zap.String("rule_id", rule.ID),
 				zap.String("rule_name", rule.Name))
+			monitoring.IncrementMatchedRequests()
 			return rule, nil
 		}
 	}
 
+	// No rule matched
+	monitoring.IncrementUnmatchedRequests()
 	// 没有匹配的规则
 	return nil, nil
 }
 
@@ -153,24 +170,42 @@ func (e *MatchEngine) regexMatch(request *adapter.Request, rule *models.Rule) (b
 }
 
 // compileRegex 编译正则表达式并缓存
 func (e *MatchEngine) compileRegex(pattern string) (*regexp.Regexp, error) {
 	// 先尝试从缓存中获取
-	e.regexCacheMu.RLock()
-	if re, exists := e.regexCache[pattern]; exists {
-		e.regexCacheMu.RUnlock()
+	if re, exists := e.regexCache.Get(pattern); exists {
+		e.statsMu.Lock()
+		e.cacheStats.Hits++
+		e.statsMu.Unlock()
+		monitoring.IncrementRegexCacheHits()
 		return re, nil
 	}
-	e.regexCacheMu.RUnlock()
 
+	e.statsMu.Lock()
+	e.cacheStats.Misses++
+	e.statsMu.Unlock()
+	monitoring.IncrementRegexCacheMisses()
+
 	// 编译正则表达式
 	re, err := regexp.Compile(pattern)
 	if err != nil {
 		return nil, err
 	}
 
 	// 存入缓存
-	e.regexCacheMu.Lock()
-	e.regexCache[pattern] = re
-	e.regexCacheMu.Unlock()
+	e.regexCache.Put(pattern, re)
+	monitoring.SetRegexCacheSize(int64(e.regexCache.Size()))
 
 	return re, nil
 }
 
+// GetCacheStats 获取缓存统计信息
+func (e *MatchEngine) GetCacheStats() RegexCacheStats {
+	e.statsMu.RLock()
+	defer e.statsMu.RUnlock()
+	stats := e.cacheStats
+	stats.Size = e.regexCache.Size()
+	return stats
+}